Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    REDO
    CASE
    ERROR
    DEF
    SUPER
    FILE
    YIELD
    BREAK
    LINE
    RESCUE
    PSEUDO
    ALIAS
    ENSURE
    DEFINED
    RETRY
    NEXT
    UNTIL
    SELF
    UNDEF
    CLASS
    TRUE
    WHEN
    UNLESS
    MODULE
    NIL
    FALSE
    RETURN

Grammar

Rule 0     S' -> assign
Rule 1     assign -> variable ASS expr
Rule 2     assign -> variable ASS sexpr
Rule 3     math -> term arith term
Rule 4     math -> term arith math
Rule 5     math -> variable asig term
Rule 6     logic -> logic_term comparison BOOLEAN
Rule 7     logic -> logic_term comparison logic_term
Rule 8     logic -> logic_term comparison logic
Rule 9     logic_term -> variable
Rule 10    logic_term -> term
Rule 11    logic_term -> sterm
Rule 12    variable -> LOCAL
Rule 13    variable -> GLOBAL
Rule 14    variable -> CONSTANTS
Rule 15    variable -> INSTANCEVAR
Rule 16    variable -> CLASSVAR
Rule 17    asig -> ASS
Rule 18    asig -> ADDASS
Rule 19    asig -> SUBASS
Rule 20    asig -> MULASS
Rule 21    asig -> DIVASS
Rule 22    asig -> MODASS
Rule 23    asig -> EXPASS
Rule 24    expr -> math
Rule 25    expr -> term
Rule 26    expr -> variable
Rule 27    expr -> assign
Rule 28    sexpr -> sterm MUL term
Rule 29    sexpr -> sterm ADD sexpr
Rule 30    sexpr -> sterm
Rule 31    term -> NUMBER
Rule 32    sterm -> STRING
Rule 33    arith -> EXP
Rule 34    arith -> MUL
Rule 35    arith -> DIV
Rule 36    arith -> MOD
Rule 37    arith -> ADD
Rule 38    arith -> SUB
Rule 39    comparison -> EQUAL
Rule 40    comparison -> NOTEQ
Rule 41    comparison -> GREATHER
Rule 42    comparison -> LOWER
Rule 43    comparison -> GREATHEREQ
Rule 44    comparison -> LOWEREQ
Rule 45    logcompare -> ANDLOG
Rule 46    logcompare -> ORLOG
Rule 47    logcompare -> NOTLOG
Rule 48    logcompare -> AND
Rule 49    logcompare -> OR
Rule 50    logcompare -> NOT
Rule 51    salto -> NEWLINE
Rule 52    else -> ELSE expr END
Rule 53    elsif -> ELSIF logic expr
Rule 54    elsif -> ELSIF logic THEN expr
Rule 55    elsif -> ELSIF logic expr else
Rule 56    elsif -> ELSIF logic expr elsif
Rule 57    if -> IF logic expr END
Rule 58    if -> IF logic THEN expr END
Rule 59    if -> IF logic
Rule 60    if -> IF logic THEN
Rule 61    if -> if else
Rule 62    if -> if elsif END
Rule 63    code -> expr
Rule 64    code -> if
Rule 65    while -> WHILE logic code END
Rule 66    while -> WHILE logic DO salto code END
Rule 67    while -> WHILE logic DOBLEPOINT code END
Rule 68    while -> BEGIN code END WHILE logic
Rule 69    iterador -> variable
Rule 70    iterador -> variable , variable
Rule 71    expresiones -> term DOUBLESECUENCEPOINT term
Rule 72    for -> FOR iterador IN expresiones code END
Rule 73    for -> FOR iterador IN expresiones DO code END
Rule 74    for -> FOR iterador IN array code END
Rule 75    for -> FOR iterador IN array DO code END
Rule 76    assarray -> variable ASS array
Rule 77    assarray -> array
Rule 78    array -> LBRACK defarray RBRACK
Rule 79    defarray -> NUMBER
Rule 80    defarray -> NUMBER COMA defarray
Rule 81    defarray -> STRING
Rule 82    defarray -> STRING COMA defarray
Rule 83    defarray -> INT
Rule 84    defarray -> INT COMA defarray
Rule 85    defarray -> FLOAT
Rule 86    defarray -> FLOAT COMA defarray
Rule 87    defarray -> BOOLEAN
Rule 88    defarray -> BOOLEAN COMA defarray
Rule 89    index -> variable LBRACK INT RBRACK
Rule 90    slice -> variable LBRACK defslice RBRACK
Rule 91    defslice -> INT DOBLEPOINT INT
Rule 92    defslice -> INT DOBLEPOINT
Rule 93    defslice -> DOBLEPOINT INT

Terminals, with rules where they appear

,                    : 70
ADD                  : 29 37
ADDASS               : 18
ALIAS                : 
AND                  : 48
ANDLOG               : 45
ASS                  : 1 2 17 76
BEGIN                : 68
BOOLEAN              : 6 87 88
BREAK                : 
CASE                 : 
CLASS                : 
CLASSVAR             : 16
COMA                 : 80 82 84 86 88
CONSTANTS            : 14
DEF                  : 
DEFINED              : 
DIV                  : 35
DIVASS               : 21
DO                   : 66 73 75
DOBLEPOINT           : 67 91 92 93
DOUBLESECUENCEPOINT  : 71
ELSE                 : 52
ELSIF                : 53 54 55 56
END                  : 52 57 58 62 65 66 67 68 72 73 74 75
ENSURE               : 
EQUAL                : 39
ERROR                : 
EXP                  : 33
EXPASS               : 23
FALSE                : 
FILE                 : 
FLOAT                : 85 86
FOR                  : 72 73 74 75
GLOBAL               : 13
GREATHER             : 41
GREATHEREQ           : 43
IF                   : 57 58 59 60
IN                   : 72 73 74 75
INSTANCEVAR          : 15
INT                  : 83 84 89 91 91 92 93
LBRACK               : 78 89 90
LINE                 : 
LOCAL                : 12
LOWER                : 42
LOWEREQ              : 44
MOD                  : 36
MODASS               : 22
MODULE               : 
MUL                  : 28 34
MULASS               : 20
NEWLINE              : 51
NEXT                 : 
NIL                  : 
NOT                  : 50
NOTEQ                : 40
NOTLOG               : 47
NUMBER               : 31 79 80
OR                   : 49
ORLOG                : 46
PSEUDO               : 
RBRACK               : 78 89 90
REDO                 : 
RESCUE               : 
RETRY                : 
RETURN               : 
SELF                 : 
STRING               : 32 81 82
SUB                  : 38
SUBASS               : 19
SUPER                : 
THEN                 : 54 58 60
TRUE                 : 
UNDEF                : 
UNLESS               : 
UNTIL                : 
WHEN                 : 
WHILE                : 65 66 67 68
YIELD                : 
error                : 

Nonterminals, with rules where they appear

arith                : 3 4
array                : 74 75 76 77
asig                 : 5
assarray             : 
assign               : 27 0
code                 : 65 66 67 68 72 73 74 75
comparison           : 6 7 8
defarray             : 78 80 82 84 86 88
defslice             : 90
else                 : 55 61
elsif                : 56 62
expr                 : 1 52 53 54 55 56 57 58 63
expresiones          : 72 73
for                  : 
if                   : 61 62 64
index                : 
iterador             : 72 73 74 75
logcompare           : 
logic                : 8 53 54 55 56 57 58 59 60 65 66 67 68
logic_term           : 6 7 7 8
math                 : 4 24
salto                : 66
sexpr                : 2 29
slice                : 
sterm                : 11 28 29 30
term                 : 3 3 4 5 10 25 28 71 71
variable             : 1 2 5 9 26 69 70 70 76 89 90
while                : 

Parsing method: LALR

state 0

    (0) S' -> . assign
    (1) assign -> . variable ASS expr
    (2) assign -> . variable ASS sexpr
    (12) variable -> . LOCAL
    (13) variable -> . GLOBAL
    (14) variable -> . CONSTANTS
    (15) variable -> . INSTANCEVAR
    (16) variable -> . CLASSVAR

    LOCAL           shift and go to state 4
    GLOBAL          shift and go to state 1
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 2
    CLASSVAR        shift and go to state 6

    assign                         shift and go to state 5
    variable                       shift and go to state 3

state 1

    (13) variable -> GLOBAL .

    ASS             reduce using rule 13 (variable -> GLOBAL .)
    ADDASS          reduce using rule 13 (variable -> GLOBAL .)
    SUBASS          reduce using rule 13 (variable -> GLOBAL .)
    MULASS          reduce using rule 13 (variable -> GLOBAL .)
    DIVASS          reduce using rule 13 (variable -> GLOBAL .)
    MODASS          reduce using rule 13 (variable -> GLOBAL .)
    EXPASS          reduce using rule 13 (variable -> GLOBAL .)
    $end            reduce using rule 13 (variable -> GLOBAL .)


state 2

    (15) variable -> INSTANCEVAR .

    ASS             reduce using rule 15 (variable -> INSTANCEVAR .)
    ADDASS          reduce using rule 15 (variable -> INSTANCEVAR .)
    SUBASS          reduce using rule 15 (variable -> INSTANCEVAR .)
    MULASS          reduce using rule 15 (variable -> INSTANCEVAR .)
    DIVASS          reduce using rule 15 (variable -> INSTANCEVAR .)
    MODASS          reduce using rule 15 (variable -> INSTANCEVAR .)
    EXPASS          reduce using rule 15 (variable -> INSTANCEVAR .)
    $end            reduce using rule 15 (variable -> INSTANCEVAR .)


state 3

    (1) assign -> variable . ASS expr
    (2) assign -> variable . ASS sexpr

    ASS             shift and go to state 8


state 4

    (12) variable -> LOCAL .

    ASS             reduce using rule 12 (variable -> LOCAL .)
    ADDASS          reduce using rule 12 (variable -> LOCAL .)
    SUBASS          reduce using rule 12 (variable -> LOCAL .)
    MULASS          reduce using rule 12 (variable -> LOCAL .)
    DIVASS          reduce using rule 12 (variable -> LOCAL .)
    MODASS          reduce using rule 12 (variable -> LOCAL .)
    EXPASS          reduce using rule 12 (variable -> LOCAL .)
    $end            reduce using rule 12 (variable -> LOCAL .)


state 5

    (0) S' -> assign .



state 6

    (16) variable -> CLASSVAR .

    ASS             reduce using rule 16 (variable -> CLASSVAR .)
    ADDASS          reduce using rule 16 (variable -> CLASSVAR .)
    SUBASS          reduce using rule 16 (variable -> CLASSVAR .)
    MULASS          reduce using rule 16 (variable -> CLASSVAR .)
    DIVASS          reduce using rule 16 (variable -> CLASSVAR .)
    MODASS          reduce using rule 16 (variable -> CLASSVAR .)
    EXPASS          reduce using rule 16 (variable -> CLASSVAR .)
    $end            reduce using rule 16 (variable -> CLASSVAR .)


state 7

    (14) variable -> CONSTANTS .

    ASS             reduce using rule 14 (variable -> CONSTANTS .)
    ADDASS          reduce using rule 14 (variable -> CONSTANTS .)
    SUBASS          reduce using rule 14 (variable -> CONSTANTS .)
    MULASS          reduce using rule 14 (variable -> CONSTANTS .)
    DIVASS          reduce using rule 14 (variable -> CONSTANTS .)
    MODASS          reduce using rule 14 (variable -> CONSTANTS .)
    EXPASS          reduce using rule 14 (variable -> CONSTANTS .)
    $end            reduce using rule 14 (variable -> CONSTANTS .)


state 8

    (1) assign -> variable ASS . expr
    (2) assign -> variable ASS . sexpr
    (24) expr -> . math
    (25) expr -> . term
    (26) expr -> . variable
    (27) expr -> . assign
    (28) sexpr -> . sterm MUL term
    (29) sexpr -> . sterm ADD sexpr
    (30) sexpr -> . sterm
    (3) math -> . term arith term
    (4) math -> . term arith math
    (5) math -> . variable asig term
    (31) term -> . NUMBER
    (12) variable -> . LOCAL
    (13) variable -> . GLOBAL
    (14) variable -> . CONSTANTS
    (15) variable -> . INSTANCEVAR
    (16) variable -> . CLASSVAR
    (1) assign -> . variable ASS expr
    (2) assign -> . variable ASS sexpr
    (32) sterm -> . STRING

    NUMBER          shift and go to state 12
    LOCAL           shift and go to state 4
    GLOBAL          shift and go to state 1
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 2
    CLASSVAR        shift and go to state 6
    STRING          shift and go to state 15

    term                           shift and go to state 9
    math                           shift and go to state 13
    expr                           shift and go to state 10
    variable                       shift and go to state 14
    sterm                          shift and go to state 11
    sexpr                          shift and go to state 16
    assign                         shift and go to state 17

state 9

    (25) expr -> term .
    (3) math -> term . arith term
    (4) math -> term . arith math
    (33) arith -> . EXP
    (34) arith -> . MUL
    (35) arith -> . DIV
    (36) arith -> . MOD
    (37) arith -> . ADD
    (38) arith -> . SUB

    $end            reduce using rule 25 (expr -> term .)
    EXP             shift and go to state 20
    MUL             shift and go to state 19
    DIV             shift and go to state 24
    MOD             shift and go to state 23
    ADD             shift and go to state 22
    SUB             shift and go to state 18

    arith                          shift and go to state 21

state 10

    (1) assign -> variable ASS expr .

    $end            reduce using rule 1 (assign -> variable ASS expr .)


state 11

    (28) sexpr -> sterm . MUL term
    (29) sexpr -> sterm . ADD sexpr
    (30) sexpr -> sterm .

    MUL             shift and go to state 25
    ADD             shift and go to state 26
    $end            reduce using rule 30 (sexpr -> sterm .)


state 12

    (31) term -> NUMBER .

    EXP             reduce using rule 31 (term -> NUMBER .)
    MUL             reduce using rule 31 (term -> NUMBER .)
    DIV             reduce using rule 31 (term -> NUMBER .)
    MOD             reduce using rule 31 (term -> NUMBER .)
    ADD             reduce using rule 31 (term -> NUMBER .)
    SUB             reduce using rule 31 (term -> NUMBER .)
    $end            reduce using rule 31 (term -> NUMBER .)


state 13

    (24) expr -> math .

    $end            reduce using rule 24 (expr -> math .)


state 14

    (26) expr -> variable .
    (5) math -> variable . asig term
    (1) assign -> variable . ASS expr
    (2) assign -> variable . ASS sexpr
    (17) asig -> . ASS
    (18) asig -> . ADDASS
    (19) asig -> . SUBASS
    (20) asig -> . MULASS
    (21) asig -> . DIVASS
    (22) asig -> . MODASS
    (23) asig -> . EXPASS

    $end            reduce using rule 26 (expr -> variable .)
    ASS             shift and go to state 28
    ADDASS          shift and go to state 30
    SUBASS          shift and go to state 31
    MULASS          shift and go to state 34
    DIVASS          shift and go to state 32
    MODASS          shift and go to state 33
    EXPASS          shift and go to state 27

    asig                           shift and go to state 29

state 15

    (32) sterm -> STRING .

    MUL             reduce using rule 32 (sterm -> STRING .)
    ADD             reduce using rule 32 (sterm -> STRING .)
    $end            reduce using rule 32 (sterm -> STRING .)


state 16

    (2) assign -> variable ASS sexpr .

    $end            reduce using rule 2 (assign -> variable ASS sexpr .)


state 17

    (27) expr -> assign .

    $end            reduce using rule 27 (expr -> assign .)


state 18

    (38) arith -> SUB .

    NUMBER          reduce using rule 38 (arith -> SUB .)
    LOCAL           reduce using rule 38 (arith -> SUB .)
    GLOBAL          reduce using rule 38 (arith -> SUB .)
    CONSTANTS       reduce using rule 38 (arith -> SUB .)
    INSTANCEVAR     reduce using rule 38 (arith -> SUB .)
    CLASSVAR        reduce using rule 38 (arith -> SUB .)


state 19

    (34) arith -> MUL .

    NUMBER          reduce using rule 34 (arith -> MUL .)
    LOCAL           reduce using rule 34 (arith -> MUL .)
    GLOBAL          reduce using rule 34 (arith -> MUL .)
    CONSTANTS       reduce using rule 34 (arith -> MUL .)
    INSTANCEVAR     reduce using rule 34 (arith -> MUL .)
    CLASSVAR        reduce using rule 34 (arith -> MUL .)


state 20

    (33) arith -> EXP .

    NUMBER          reduce using rule 33 (arith -> EXP .)
    LOCAL           reduce using rule 33 (arith -> EXP .)
    GLOBAL          reduce using rule 33 (arith -> EXP .)
    CONSTANTS       reduce using rule 33 (arith -> EXP .)
    INSTANCEVAR     reduce using rule 33 (arith -> EXP .)
    CLASSVAR        reduce using rule 33 (arith -> EXP .)


state 21

    (3) math -> term arith . term
    (4) math -> term arith . math
    (31) term -> . NUMBER
    (3) math -> . term arith term
    (4) math -> . term arith math
    (5) math -> . variable asig term
    (12) variable -> . LOCAL
    (13) variable -> . GLOBAL
    (14) variable -> . CONSTANTS
    (15) variable -> . INSTANCEVAR
    (16) variable -> . CLASSVAR

    NUMBER          shift and go to state 12
    LOCAL           shift and go to state 4
    GLOBAL          shift and go to state 1
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 2
    CLASSVAR        shift and go to state 6

    term                           shift and go to state 35
    math                           shift and go to state 36
    variable                       shift and go to state 37

state 22

    (37) arith -> ADD .

    NUMBER          reduce using rule 37 (arith -> ADD .)
    LOCAL           reduce using rule 37 (arith -> ADD .)
    GLOBAL          reduce using rule 37 (arith -> ADD .)
    CONSTANTS       reduce using rule 37 (arith -> ADD .)
    INSTANCEVAR     reduce using rule 37 (arith -> ADD .)
    CLASSVAR        reduce using rule 37 (arith -> ADD .)


state 23

    (36) arith -> MOD .

    NUMBER          reduce using rule 36 (arith -> MOD .)
    LOCAL           reduce using rule 36 (arith -> MOD .)
    GLOBAL          reduce using rule 36 (arith -> MOD .)
    CONSTANTS       reduce using rule 36 (arith -> MOD .)
    INSTANCEVAR     reduce using rule 36 (arith -> MOD .)
    CLASSVAR        reduce using rule 36 (arith -> MOD .)


state 24

    (35) arith -> DIV .

    NUMBER          reduce using rule 35 (arith -> DIV .)
    LOCAL           reduce using rule 35 (arith -> DIV .)
    GLOBAL          reduce using rule 35 (arith -> DIV .)
    CONSTANTS       reduce using rule 35 (arith -> DIV .)
    INSTANCEVAR     reduce using rule 35 (arith -> DIV .)
    CLASSVAR        reduce using rule 35 (arith -> DIV .)


state 25

    (28) sexpr -> sterm MUL . term
    (31) term -> . NUMBER

    NUMBER          shift and go to state 12

    term                           shift and go to state 38

state 26

    (29) sexpr -> sterm ADD . sexpr
    (28) sexpr -> . sterm MUL term
    (29) sexpr -> . sterm ADD sexpr
    (30) sexpr -> . sterm
    (32) sterm -> . STRING

    STRING          shift and go to state 15

    sterm                          shift and go to state 11
    sexpr                          shift and go to state 39

state 27

    (23) asig -> EXPASS .

    NUMBER          reduce using rule 23 (asig -> EXPASS .)


state 28

    (1) assign -> variable ASS . expr
    (2) assign -> variable ASS . sexpr
    (17) asig -> ASS .
    (24) expr -> . math
    (25) expr -> . term
    (26) expr -> . variable
    (27) expr -> . assign
    (28) sexpr -> . sterm MUL term
    (29) sexpr -> . sterm ADD sexpr
    (30) sexpr -> . sterm
    (3) math -> . term arith term
    (4) math -> . term arith math
    (5) math -> . variable asig term
    (31) term -> . NUMBER
    (12) variable -> . LOCAL
    (13) variable -> . GLOBAL
    (14) variable -> . CONSTANTS
    (15) variable -> . INSTANCEVAR
    (16) variable -> . CLASSVAR
    (1) assign -> . variable ASS expr
    (2) assign -> . variable ASS sexpr
    (32) sterm -> . STRING

  ! shift/reduce conflict for NUMBER resolved as shift
    NUMBER          shift and go to state 12
    LOCAL           shift and go to state 4
    GLOBAL          shift and go to state 1
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 2
    CLASSVAR        shift and go to state 6
    STRING          shift and go to state 15

  ! NUMBER          [ reduce using rule 17 (asig -> ASS .) ]

    term                           shift and go to state 9
    math                           shift and go to state 13
    expr                           shift and go to state 10
    variable                       shift and go to state 14
    sterm                          shift and go to state 11
    sexpr                          shift and go to state 16
    assign                         shift and go to state 17

state 29

    (5) math -> variable asig . term
    (31) term -> . NUMBER

    NUMBER          shift and go to state 12

    term                           shift and go to state 40

state 30

    (18) asig -> ADDASS .

    NUMBER          reduce using rule 18 (asig -> ADDASS .)


state 31

    (19) asig -> SUBASS .

    NUMBER          reduce using rule 19 (asig -> SUBASS .)


state 32

    (21) asig -> DIVASS .

    NUMBER          reduce using rule 21 (asig -> DIVASS .)


state 33

    (22) asig -> MODASS .

    NUMBER          reduce using rule 22 (asig -> MODASS .)


state 34

    (20) asig -> MULASS .

    NUMBER          reduce using rule 20 (asig -> MULASS .)


state 35

    (3) math -> term arith term .
    (3) math -> term . arith term
    (4) math -> term . arith math
    (33) arith -> . EXP
    (34) arith -> . MUL
    (35) arith -> . DIV
    (36) arith -> . MOD
    (37) arith -> . ADD
    (38) arith -> . SUB

    $end            reduce using rule 3 (math -> term arith term .)
    EXP             shift and go to state 20
    MUL             shift and go to state 19
    DIV             shift and go to state 24
    MOD             shift and go to state 23
    ADD             shift and go to state 22
    SUB             shift and go to state 18

    arith                          shift and go to state 21

state 36

    (4) math -> term arith math .

    $end            reduce using rule 4 (math -> term arith math .)


state 37

    (5) math -> variable . asig term
    (17) asig -> . ASS
    (18) asig -> . ADDASS
    (19) asig -> . SUBASS
    (20) asig -> . MULASS
    (21) asig -> . DIVASS
    (22) asig -> . MODASS
    (23) asig -> . EXPASS

    ASS             shift and go to state 41
    ADDASS          shift and go to state 30
    SUBASS          shift and go to state 31
    MULASS          shift and go to state 34
    DIVASS          shift and go to state 32
    MODASS          shift and go to state 33
    EXPASS          shift and go to state 27

    asig                           shift and go to state 29

state 38

    (28) sexpr -> sterm MUL term .

    $end            reduce using rule 28 (sexpr -> sterm MUL term .)


state 39

    (29) sexpr -> sterm ADD sexpr .

    $end            reduce using rule 29 (sexpr -> sterm ADD sexpr .)


state 40

    (5) math -> variable asig term .

    $end            reduce using rule 5 (math -> variable asig term .)


state 41

    (17) asig -> ASS .

    NUMBER          reduce using rule 17 (asig -> ASS .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for NUMBER in state 28 resolved as shift
