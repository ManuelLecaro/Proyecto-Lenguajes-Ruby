Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    UNDEF
    ERROR
    ALIAS
    TRUE
    FILE
    RETRY
    NIL
    ENSURE
    MODULE
    BREAK
    UNTIL
    SELF
    RETURN
    WHEN
    CLASS
    UNLESS
    RESCUE
    PSEUDO
    CASE
    DEF
    REDO
    LINE
    DEFINED
    FALSE
    SUPER
    YIELD
    NEXT

Grammar

Rule 0     S' -> code
Rule 1     code -> expr
Rule 2     code -> if
Rule 3     code -> while
Rule 4     code -> expresiones
Rule 5     code -> for
Rule 6     code -> assign
Rule 7     code -> code code
Rule 8     while -> WHILE logical code END
Rule 9     while -> WHILE logical DO salto code salto END
Rule 10    while -> WHILE logical DOBLEPOINT salto code salto END
Rule 11    while -> BEGIN code END WHILE logical
Rule 12    logical -> term comparison term
Rule 13    logical -> term comparison logical
Rule 14    logical -> variable comparison term
Rule 15    logical -> variable comparison BOOLEAN
Rule 16    logical -> logical logcompare logical
Rule 17    logical -> BOOLEAN
Rule 18    comparison -> EQUAL
Rule 19    comparison -> NOTEQ
Rule 20    comparison -> GREATHER
Rule 21    comparison -> LOWER
Rule 22    comparison -> GREATHEREQ
Rule 23    comparison -> LOWEREQ
Rule 24    logcompare -> ANDLOG
Rule 25    logcompare -> ORLOG
Rule 26    logcompare -> NOTLOG
Rule 27    logcompare -> AND
Rule 28    logcompare -> OR
Rule 29    logcompare -> NOT
Rule 30    assign -> variable ASS expr
Rule 31    assign -> variable ASS sexpr
Rule 32    assign -> variable ASS array
Rule 33    math -> term arith term
Rule 34    math -> term arith math
Rule 35    math -> variable asig term
Rule 36    variable -> LOCAL
Rule 37    variable -> GLOBAL
Rule 38    variable -> CONSTANTS
Rule 39    variable -> INSTANCEVAR
Rule 40    variable -> CLASSVAR
Rule 41    asig -> ASS
Rule 42    asig -> ADDASS
Rule 43    asig -> SUBASS
Rule 44    asig -> MULASS
Rule 45    asig -> DIVASS
Rule 46    asig -> MODASS
Rule 47    asig -> EXPASS
Rule 48    expr -> math
Rule 49    expr -> term
Rule 50    expr -> sterm
Rule 51    expr -> variable
Rule 52    expr -> slice
Rule 53    expr -> index
Rule 54    sexpr -> sterm MUL term
Rule 55    sexpr -> sterm ADD sexpr
Rule 56    term -> NUMBER
Rule 57    sterm -> STRING
Rule 58    arith -> EXP
Rule 59    arith -> MUL
Rule 60    arith -> DIV
Rule 61    arith -> MOD
Rule 62    arith -> ADD
Rule 63    arith -> SUB
Rule 64    for -> FOR iterador IN expresiones code END
Rule 65    for -> FOR iterador IN expresiones DO code END
Rule 66    for -> FOR iterador IN array code END
Rule 67    for -> FOR iterador IN array DO code END
Rule 68    salto -> NEWLINE
Rule 69    if -> IF logical expr END
Rule 70    if -> IF logical THEN expr END
Rule 71    if -> IF logical
Rule 72    if -> IF logical THEN
Rule 73    if -> if else
Rule 74    if -> if elsif END
Rule 75    else -> ELSE code END
Rule 76    elsif -> ELSIF logical final
Rule 77    final -> code
Rule 78    final -> THEN code
Rule 79    final -> code else
Rule 80    final -> code elsif
Rule 81    iterador -> variable
Rule 82    iterador -> variable COMA variable
Rule 83    expresiones -> term DOUBLESECUENCEPOINT term
Rule 84    array -> LBRACK defarray RBRACK
Rule 85    defarray -> NUMBER
Rule 86    defarray -> NUMBER COMA defarray
Rule 87    defarray -> STRING
Rule 88    defarray -> STRING COMA defarray
Rule 89    defarray -> INT
Rule 90    defarray -> INT COMA defarray
Rule 91    defarray -> FLOAT
Rule 92    defarray -> FLOAT COMA defarray
Rule 93    defarray -> BOOLEAN
Rule 94    defarray -> BOOLEAN COMA defarray
Rule 95    index -> variable LBRACK INT RBRACK
Rule 96    slice -> variable LBRACK defslice RBRACK
Rule 97    defslice -> INT DOBLEPOINT INT
Rule 98    defslice -> INT DOBLEPOINT
Rule 99    defslice -> DOBLEPOINT INT

Terminals, with rules where they appear

ADD                  : 55 62
ADDASS               : 42
ALIAS                : 
AND                  : 27
ANDLOG               : 24
ASS                  : 30 31 32 41
BEGIN                : 11
BOOLEAN              : 15 17 93 94
BREAK                : 
CASE                 : 
CLASS                : 
CLASSVAR             : 40
COMA                 : 82 86 88 90 92 94
CONSTANTS            : 38
DEF                  : 
DEFINED              : 
DIV                  : 60
DIVASS               : 45
DO                   : 9 65 67
DOBLEPOINT           : 10 97 98 99
DOUBLESECUENCEPOINT  : 83
ELSE                 : 75
ELSIF                : 76
END                  : 8 9 10 11 64 65 66 67 69 70 74 75
ENSURE               : 
EQUAL                : 18
ERROR                : 
EXP                  : 58
EXPASS               : 47
FALSE                : 
FILE                 : 
FLOAT                : 91 92
FOR                  : 64 65 66 67
GLOBAL               : 37
GREATHER             : 20
GREATHEREQ           : 22
IF                   : 69 70 71 72
IN                   : 64 65 66 67
INSTANCEVAR          : 39
INT                  : 89 90 95 97 97 98 99
LBRACK               : 84 95 96
LINE                 : 
LOCAL                : 36
LOWER                : 21
LOWEREQ              : 23
MOD                  : 61
MODASS               : 46
MODULE               : 
MUL                  : 54 59
MULASS               : 44
NEWLINE              : 68
NEXT                 : 
NIL                  : 
NOT                  : 29
NOTEQ                : 19
NOTLOG               : 26
NUMBER               : 56 85 86
OR                   : 28
ORLOG                : 25
PSEUDO               : 
RBRACK               : 84 95 96
REDO                 : 
RESCUE               : 
RETRY                : 
RETURN               : 
SELF                 : 
STRING               : 57 87 88
SUB                  : 63
SUBASS               : 43
SUPER                : 
THEN                 : 70 72 78
TRUE                 : 
UNDEF                : 
UNLESS               : 
UNTIL                : 
WHEN                 : 
WHILE                : 8 9 10 11
YIELD                : 
error                : 

Nonterminals, with rules where they appear

arith                : 33 34
array                : 32 66 67
asig                 : 35
assign               : 6
code                 : 7 7 8 9 10 11 64 65 66 67 75 77 78 79 80 0
comparison           : 12 13 14 15
defarray             : 84 86 88 90 92 94
defslice             : 96
else                 : 73 79
elsif                : 74 80
expr                 : 1 30 69 70
expresiones          : 4 64 65
final                : 76
for                  : 5
if                   : 2 73 74
index                : 53
iterador             : 64 65 66 67
logcompare           : 16
logical              : 8 9 10 11 13 16 16 69 70 71 72 76
math                 : 34 48
salto                : 9 9 10 10
sexpr                : 31 55
slice                : 52
sterm                : 50 54 55
term                 : 12 12 13 14 33 33 34 35 49 54 83 83
variable             : 14 15 30 31 32 35 51 81 82 82 95 96
while                : 3

Parsing method: LALR

state 0

    (0) S' -> . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 4
    WHILE           shift and go to state 13
    BEGIN           shift and go to state 10
    FOR             shift and go to state 22
    NUMBER          shift and go to state 21
    STRING          shift and go to state 8
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

    assign                         shift and go to state 1
    for                            shift and go to state 6
    sterm                          shift and go to state 12
    slice                          shift and go to state 2
    index                          shift and go to state 3
    variable                       shift and go to state 15
    code                           shift and go to state 9
    term                           shift and go to state 7
    expr                           shift and go to state 19
    expresiones                    shift and go to state 20
    math                           shift and go to state 23
    while                          shift and go to state 17
    if                             shift and go to state 5

state 1

    (6) code -> assign .

    IF              reduce using rule 6 (code -> assign .)
    WHILE           reduce using rule 6 (code -> assign .)
    BEGIN           reduce using rule 6 (code -> assign .)
    FOR             reduce using rule 6 (code -> assign .)
    NUMBER          reduce using rule 6 (code -> assign .)
    STRING          reduce using rule 6 (code -> assign .)
    LOCAL           reduce using rule 6 (code -> assign .)
    GLOBAL          reduce using rule 6 (code -> assign .)
    CONSTANTS       reduce using rule 6 (code -> assign .)
    INSTANCEVAR     reduce using rule 6 (code -> assign .)
    CLASSVAR        reduce using rule 6 (code -> assign .)
    END             reduce using rule 6 (code -> assign .)
    ELSE            reduce using rule 6 (code -> assign .)
    ELSIF           reduce using rule 6 (code -> assign .)
    $end            reduce using rule 6 (code -> assign .)
    NEWLINE         reduce using rule 6 (code -> assign .)


state 2

    (52) expr -> slice .

    END             reduce using rule 52 (expr -> slice .)
    IF              reduce using rule 52 (expr -> slice .)
    WHILE           reduce using rule 52 (expr -> slice .)
    BEGIN           reduce using rule 52 (expr -> slice .)
    FOR             reduce using rule 52 (expr -> slice .)
    NUMBER          reduce using rule 52 (expr -> slice .)
    STRING          reduce using rule 52 (expr -> slice .)
    LOCAL           reduce using rule 52 (expr -> slice .)
    GLOBAL          reduce using rule 52 (expr -> slice .)
    CONSTANTS       reduce using rule 52 (expr -> slice .)
    INSTANCEVAR     reduce using rule 52 (expr -> slice .)
    CLASSVAR        reduce using rule 52 (expr -> slice .)
    $end            reduce using rule 52 (expr -> slice .)
    ELSE            reduce using rule 52 (expr -> slice .)
    ELSIF           reduce using rule 52 (expr -> slice .)
    NEWLINE         reduce using rule 52 (expr -> slice .)


state 3

    (53) expr -> index .

    END             reduce using rule 53 (expr -> index .)
    IF              reduce using rule 53 (expr -> index .)
    WHILE           reduce using rule 53 (expr -> index .)
    BEGIN           reduce using rule 53 (expr -> index .)
    FOR             reduce using rule 53 (expr -> index .)
    NUMBER          reduce using rule 53 (expr -> index .)
    STRING          reduce using rule 53 (expr -> index .)
    LOCAL           reduce using rule 53 (expr -> index .)
    GLOBAL          reduce using rule 53 (expr -> index .)
    CONSTANTS       reduce using rule 53 (expr -> index .)
    INSTANCEVAR     reduce using rule 53 (expr -> index .)
    CLASSVAR        reduce using rule 53 (expr -> index .)
    $end            reduce using rule 53 (expr -> index .)
    ELSE            reduce using rule 53 (expr -> index .)
    ELSIF           reduce using rule 53 (expr -> index .)
    NEWLINE         reduce using rule 53 (expr -> index .)


state 4

    (69) if -> IF . logical expr END
    (70) if -> IF . logical THEN expr END
    (71) if -> IF . logical
    (72) if -> IF . logical THEN
    (12) logical -> . term comparison term
    (13) logical -> . term comparison logical
    (14) logical -> . variable comparison term
    (15) logical -> . variable comparison BOOLEAN
    (16) logical -> . logical logcompare logical
    (17) logical -> . BOOLEAN
    (56) term -> . NUMBER
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR

    BOOLEAN         shift and go to state 26
    NUMBER          shift and go to state 21
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

    logical                        shift and go to state 27
    term                           shift and go to state 25
    variable                       shift and go to state 28

state 5

    (2) code -> if .
    (73) if -> if . else
    (74) if -> if . elsif END
    (75) else -> . ELSE code END
    (76) elsif -> . ELSIF logical final

  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
    IF              reduce using rule 2 (code -> if .)
    WHILE           reduce using rule 2 (code -> if .)
    BEGIN           reduce using rule 2 (code -> if .)
    FOR             reduce using rule 2 (code -> if .)
    NUMBER          reduce using rule 2 (code -> if .)
    STRING          reduce using rule 2 (code -> if .)
    LOCAL           reduce using rule 2 (code -> if .)
    GLOBAL          reduce using rule 2 (code -> if .)
    CONSTANTS       reduce using rule 2 (code -> if .)
    INSTANCEVAR     reduce using rule 2 (code -> if .)
    CLASSVAR        reduce using rule 2 (code -> if .)
    END             reduce using rule 2 (code -> if .)
    $end            reduce using rule 2 (code -> if .)
    NEWLINE         reduce using rule 2 (code -> if .)
    ELSE            shift and go to state 29
    ELSIF           shift and go to state 32

  ! ELSE            [ reduce using rule 2 (code -> if .) ]
  ! ELSIF           [ reduce using rule 2 (code -> if .) ]

    elsif                          shift and go to state 30
    else                           shift and go to state 31

state 6

    (5) code -> for .

    IF              reduce using rule 5 (code -> for .)
    WHILE           reduce using rule 5 (code -> for .)
    BEGIN           reduce using rule 5 (code -> for .)
    FOR             reduce using rule 5 (code -> for .)
    NUMBER          reduce using rule 5 (code -> for .)
    STRING          reduce using rule 5 (code -> for .)
    LOCAL           reduce using rule 5 (code -> for .)
    GLOBAL          reduce using rule 5 (code -> for .)
    CONSTANTS       reduce using rule 5 (code -> for .)
    INSTANCEVAR     reduce using rule 5 (code -> for .)
    CLASSVAR        reduce using rule 5 (code -> for .)
    END             reduce using rule 5 (code -> for .)
    ELSE            reduce using rule 5 (code -> for .)
    ELSIF           reduce using rule 5 (code -> for .)
    $end            reduce using rule 5 (code -> for .)
    NEWLINE         reduce using rule 5 (code -> for .)


state 7

    (49) expr -> term .
    (83) expresiones -> term . DOUBLESECUENCEPOINT term
    (33) math -> term . arith term
    (34) math -> term . arith math
    (58) arith -> . EXP
    (59) arith -> . MUL
    (60) arith -> . DIV
    (61) arith -> . MOD
    (62) arith -> . ADD
    (63) arith -> . SUB

    END             reduce using rule 49 (expr -> term .)
    IF              reduce using rule 49 (expr -> term .)
    WHILE           reduce using rule 49 (expr -> term .)
    BEGIN           reduce using rule 49 (expr -> term .)
    FOR             reduce using rule 49 (expr -> term .)
    NUMBER          reduce using rule 49 (expr -> term .)
    STRING          reduce using rule 49 (expr -> term .)
    LOCAL           reduce using rule 49 (expr -> term .)
    GLOBAL          reduce using rule 49 (expr -> term .)
    CONSTANTS       reduce using rule 49 (expr -> term .)
    INSTANCEVAR     reduce using rule 49 (expr -> term .)
    CLASSVAR        reduce using rule 49 (expr -> term .)
    NEWLINE         reduce using rule 49 (expr -> term .)
    $end            reduce using rule 49 (expr -> term .)
    ELSE            reduce using rule 49 (expr -> term .)
    ELSIF           reduce using rule 49 (expr -> term .)
    DOUBLESECUENCEPOINT shift and go to state 36
    EXP             shift and go to state 39
    MUL             shift and go to state 33
    DIV             shift and go to state 40
    MOD             shift and go to state 34
    ADD             shift and go to state 38
    SUB             shift and go to state 37

    arith                          shift and go to state 35

state 8

    (57) sterm -> STRING .

    IF              reduce using rule 57 (sterm -> STRING .)
    WHILE           reduce using rule 57 (sterm -> STRING .)
    BEGIN           reduce using rule 57 (sterm -> STRING .)
    FOR             reduce using rule 57 (sterm -> STRING .)
    NUMBER          reduce using rule 57 (sterm -> STRING .)
    STRING          reduce using rule 57 (sterm -> STRING .)
    LOCAL           reduce using rule 57 (sterm -> STRING .)
    GLOBAL          reduce using rule 57 (sterm -> STRING .)
    CONSTANTS       reduce using rule 57 (sterm -> STRING .)
    INSTANCEVAR     reduce using rule 57 (sterm -> STRING .)
    CLASSVAR        reduce using rule 57 (sterm -> STRING .)
    END             reduce using rule 57 (sterm -> STRING .)
    $end            reduce using rule 57 (sterm -> STRING .)
    ELSE            reduce using rule 57 (sterm -> STRING .)
    ELSIF           reduce using rule 57 (sterm -> STRING .)
    NEWLINE         reduce using rule 57 (sterm -> STRING .)
    MUL             reduce using rule 57 (sterm -> STRING .)
    ADD             reduce using rule 57 (sterm -> STRING .)


state 9

    (0) S' -> code .
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 4
    WHILE           shift and go to state 13
    BEGIN           shift and go to state 10
    FOR             shift and go to state 22
    NUMBER          shift and go to state 21
    STRING          shift and go to state 8
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

    assign                         shift and go to state 1
    for                            shift and go to state 6
    sterm                          shift and go to state 12
    slice                          shift and go to state 2
    index                          shift and go to state 3
    variable                       shift and go to state 15
    code                           shift and go to state 41
    term                           shift and go to state 7
    expr                           shift and go to state 19
    expresiones                    shift and go to state 20
    math                           shift and go to state 23
    while                          shift and go to state 17
    if                             shift and go to state 5

state 10

    (11) while -> BEGIN . code END WHILE logical
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 4
    WHILE           shift and go to state 13
    BEGIN           shift and go to state 10
    FOR             shift and go to state 22
    NUMBER          shift and go to state 21
    STRING          shift and go to state 8
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

    assign                         shift and go to state 1
    for                            shift and go to state 6
    sterm                          shift and go to state 12
    slice                          shift and go to state 2
    index                          shift and go to state 3
    expr                           shift and go to state 19
    variable                       shift and go to state 15
    code                           shift and go to state 42
    term                           shift and go to state 7
    expresiones                    shift and go to state 20
    math                           shift and go to state 23
    while                          shift and go to state 17
    if                             shift and go to state 5

state 11

    (39) variable -> INSTANCEVAR .

    ASS             reduce using rule 39 (variable -> INSTANCEVAR .)
    LBRACK          reduce using rule 39 (variable -> INSTANCEVAR .)
    ADDASS          reduce using rule 39 (variable -> INSTANCEVAR .)
    SUBASS          reduce using rule 39 (variable -> INSTANCEVAR .)
    MULASS          reduce using rule 39 (variable -> INSTANCEVAR .)
    DIVASS          reduce using rule 39 (variable -> INSTANCEVAR .)
    MODASS          reduce using rule 39 (variable -> INSTANCEVAR .)
    EXPASS          reduce using rule 39 (variable -> INSTANCEVAR .)
    END             reduce using rule 39 (variable -> INSTANCEVAR .)
    IF              reduce using rule 39 (variable -> INSTANCEVAR .)
    WHILE           reduce using rule 39 (variable -> INSTANCEVAR .)
    BEGIN           reduce using rule 39 (variable -> INSTANCEVAR .)
    FOR             reduce using rule 39 (variable -> INSTANCEVAR .)
    NUMBER          reduce using rule 39 (variable -> INSTANCEVAR .)
    STRING          reduce using rule 39 (variable -> INSTANCEVAR .)
    LOCAL           reduce using rule 39 (variable -> INSTANCEVAR .)
    GLOBAL          reduce using rule 39 (variable -> INSTANCEVAR .)
    CONSTANTS       reduce using rule 39 (variable -> INSTANCEVAR .)
    INSTANCEVAR     reduce using rule 39 (variable -> INSTANCEVAR .)
    CLASSVAR        reduce using rule 39 (variable -> INSTANCEVAR .)
    ELSE            reduce using rule 39 (variable -> INSTANCEVAR .)
    ELSIF           reduce using rule 39 (variable -> INSTANCEVAR .)
    $end            reduce using rule 39 (variable -> INSTANCEVAR .)
    EQUAL           reduce using rule 39 (variable -> INSTANCEVAR .)
    NOTEQ           reduce using rule 39 (variable -> INSTANCEVAR .)
    GREATHER        reduce using rule 39 (variable -> INSTANCEVAR .)
    LOWER           reduce using rule 39 (variable -> INSTANCEVAR .)
    GREATHEREQ      reduce using rule 39 (variable -> INSTANCEVAR .)
    LOWEREQ         reduce using rule 39 (variable -> INSTANCEVAR .)
    IN              reduce using rule 39 (variable -> INSTANCEVAR .)
    NEWLINE         reduce using rule 39 (variable -> INSTANCEVAR .)
    COMA            reduce using rule 39 (variable -> INSTANCEVAR .)


state 12

    (50) expr -> sterm .

    END             reduce using rule 50 (expr -> sterm .)
    IF              reduce using rule 50 (expr -> sterm .)
    WHILE           reduce using rule 50 (expr -> sterm .)
    BEGIN           reduce using rule 50 (expr -> sterm .)
    FOR             reduce using rule 50 (expr -> sterm .)
    NUMBER          reduce using rule 50 (expr -> sterm .)
    STRING          reduce using rule 50 (expr -> sterm .)
    LOCAL           reduce using rule 50 (expr -> sterm .)
    GLOBAL          reduce using rule 50 (expr -> sterm .)
    CONSTANTS       reduce using rule 50 (expr -> sterm .)
    INSTANCEVAR     reduce using rule 50 (expr -> sterm .)
    CLASSVAR        reduce using rule 50 (expr -> sterm .)
    NEWLINE         reduce using rule 50 (expr -> sterm .)
    $end            reduce using rule 50 (expr -> sterm .)
    ELSE            reduce using rule 50 (expr -> sterm .)
    ELSIF           reduce using rule 50 (expr -> sterm .)


state 13

    (8) while -> WHILE . logical code END
    (9) while -> WHILE . logical DO salto code salto END
    (10) while -> WHILE . logical DOBLEPOINT salto code salto END
    (12) logical -> . term comparison term
    (13) logical -> . term comparison logical
    (14) logical -> . variable comparison term
    (15) logical -> . variable comparison BOOLEAN
    (16) logical -> . logical logcompare logical
    (17) logical -> . BOOLEAN
    (56) term -> . NUMBER
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR

    BOOLEAN         shift and go to state 26
    NUMBER          shift and go to state 21
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

    logical                        shift and go to state 43
    term                           shift and go to state 25
    variable                       shift and go to state 28

state 14

    (40) variable -> CLASSVAR .

    ASS             reduce using rule 40 (variable -> CLASSVAR .)
    LBRACK          reduce using rule 40 (variable -> CLASSVAR .)
    ADDASS          reduce using rule 40 (variable -> CLASSVAR .)
    SUBASS          reduce using rule 40 (variable -> CLASSVAR .)
    MULASS          reduce using rule 40 (variable -> CLASSVAR .)
    DIVASS          reduce using rule 40 (variable -> CLASSVAR .)
    MODASS          reduce using rule 40 (variable -> CLASSVAR .)
    EXPASS          reduce using rule 40 (variable -> CLASSVAR .)
    END             reduce using rule 40 (variable -> CLASSVAR .)
    IF              reduce using rule 40 (variable -> CLASSVAR .)
    WHILE           reduce using rule 40 (variable -> CLASSVAR .)
    BEGIN           reduce using rule 40 (variable -> CLASSVAR .)
    FOR             reduce using rule 40 (variable -> CLASSVAR .)
    NUMBER          reduce using rule 40 (variable -> CLASSVAR .)
    STRING          reduce using rule 40 (variable -> CLASSVAR .)
    LOCAL           reduce using rule 40 (variable -> CLASSVAR .)
    GLOBAL          reduce using rule 40 (variable -> CLASSVAR .)
    CONSTANTS       reduce using rule 40 (variable -> CLASSVAR .)
    INSTANCEVAR     reduce using rule 40 (variable -> CLASSVAR .)
    CLASSVAR        reduce using rule 40 (variable -> CLASSVAR .)
    ELSE            reduce using rule 40 (variable -> CLASSVAR .)
    ELSIF           reduce using rule 40 (variable -> CLASSVAR .)
    $end            reduce using rule 40 (variable -> CLASSVAR .)
    EQUAL           reduce using rule 40 (variable -> CLASSVAR .)
    NOTEQ           reduce using rule 40 (variable -> CLASSVAR .)
    GREATHER        reduce using rule 40 (variable -> CLASSVAR .)
    LOWER           reduce using rule 40 (variable -> CLASSVAR .)
    GREATHEREQ      reduce using rule 40 (variable -> CLASSVAR .)
    LOWEREQ         reduce using rule 40 (variable -> CLASSVAR .)
    IN              reduce using rule 40 (variable -> CLASSVAR .)
    NEWLINE         reduce using rule 40 (variable -> CLASSVAR .)
    COMA            reduce using rule 40 (variable -> CLASSVAR .)


state 15

    (51) expr -> variable .
    (30) assign -> variable . ASS expr
    (31) assign -> variable . ASS sexpr
    (32) assign -> variable . ASS array
    (35) math -> variable . asig term
    (96) slice -> variable . LBRACK defslice RBRACK
    (95) index -> variable . LBRACK INT RBRACK
    (41) asig -> . ASS
    (42) asig -> . ADDASS
    (43) asig -> . SUBASS
    (44) asig -> . MULASS
    (45) asig -> . DIVASS
    (46) asig -> . MODASS
    (47) asig -> . EXPASS

    END             reduce using rule 51 (expr -> variable .)
    IF              reduce using rule 51 (expr -> variable .)
    WHILE           reduce using rule 51 (expr -> variable .)
    BEGIN           reduce using rule 51 (expr -> variable .)
    FOR             reduce using rule 51 (expr -> variable .)
    NUMBER          reduce using rule 51 (expr -> variable .)
    STRING          reduce using rule 51 (expr -> variable .)
    LOCAL           reduce using rule 51 (expr -> variable .)
    GLOBAL          reduce using rule 51 (expr -> variable .)
    CONSTANTS       reduce using rule 51 (expr -> variable .)
    INSTANCEVAR     reduce using rule 51 (expr -> variable .)
    CLASSVAR        reduce using rule 51 (expr -> variable .)
    NEWLINE         reduce using rule 51 (expr -> variable .)
    $end            reduce using rule 51 (expr -> variable .)
    ELSE            reduce using rule 51 (expr -> variable .)
    ELSIF           reduce using rule 51 (expr -> variable .)
    ASS             shift and go to state 44
    LBRACK          shift and go to state 52
    ADDASS          shift and go to state 51
    SUBASS          shift and go to state 50
    MULASS          shift and go to state 48
    DIVASS          shift and go to state 46
    MODASS          shift and go to state 49
    EXPASS          shift and go to state 45

    asig                           shift and go to state 47

state 16

    (38) variable -> CONSTANTS .

    ASS             reduce using rule 38 (variable -> CONSTANTS .)
    LBRACK          reduce using rule 38 (variable -> CONSTANTS .)
    ADDASS          reduce using rule 38 (variable -> CONSTANTS .)
    SUBASS          reduce using rule 38 (variable -> CONSTANTS .)
    MULASS          reduce using rule 38 (variable -> CONSTANTS .)
    DIVASS          reduce using rule 38 (variable -> CONSTANTS .)
    MODASS          reduce using rule 38 (variable -> CONSTANTS .)
    EXPASS          reduce using rule 38 (variable -> CONSTANTS .)
    END             reduce using rule 38 (variable -> CONSTANTS .)
    IF              reduce using rule 38 (variable -> CONSTANTS .)
    WHILE           reduce using rule 38 (variable -> CONSTANTS .)
    BEGIN           reduce using rule 38 (variable -> CONSTANTS .)
    FOR             reduce using rule 38 (variable -> CONSTANTS .)
    NUMBER          reduce using rule 38 (variable -> CONSTANTS .)
    STRING          reduce using rule 38 (variable -> CONSTANTS .)
    LOCAL           reduce using rule 38 (variable -> CONSTANTS .)
    GLOBAL          reduce using rule 38 (variable -> CONSTANTS .)
    CONSTANTS       reduce using rule 38 (variable -> CONSTANTS .)
    INSTANCEVAR     reduce using rule 38 (variable -> CONSTANTS .)
    CLASSVAR        reduce using rule 38 (variable -> CONSTANTS .)
    ELSE            reduce using rule 38 (variable -> CONSTANTS .)
    ELSIF           reduce using rule 38 (variable -> CONSTANTS .)
    $end            reduce using rule 38 (variable -> CONSTANTS .)
    EQUAL           reduce using rule 38 (variable -> CONSTANTS .)
    NOTEQ           reduce using rule 38 (variable -> CONSTANTS .)
    GREATHER        reduce using rule 38 (variable -> CONSTANTS .)
    LOWER           reduce using rule 38 (variable -> CONSTANTS .)
    GREATHEREQ      reduce using rule 38 (variable -> CONSTANTS .)
    LOWEREQ         reduce using rule 38 (variable -> CONSTANTS .)
    IN              reduce using rule 38 (variable -> CONSTANTS .)
    NEWLINE         reduce using rule 38 (variable -> CONSTANTS .)
    COMA            reduce using rule 38 (variable -> CONSTANTS .)


state 17

    (3) code -> while .

    IF              reduce using rule 3 (code -> while .)
    WHILE           reduce using rule 3 (code -> while .)
    BEGIN           reduce using rule 3 (code -> while .)
    FOR             reduce using rule 3 (code -> while .)
    NUMBER          reduce using rule 3 (code -> while .)
    STRING          reduce using rule 3 (code -> while .)
    LOCAL           reduce using rule 3 (code -> while .)
    GLOBAL          reduce using rule 3 (code -> while .)
    CONSTANTS       reduce using rule 3 (code -> while .)
    INSTANCEVAR     reduce using rule 3 (code -> while .)
    CLASSVAR        reduce using rule 3 (code -> while .)
    END             reduce using rule 3 (code -> while .)
    ELSE            reduce using rule 3 (code -> while .)
    ELSIF           reduce using rule 3 (code -> while .)
    $end            reduce using rule 3 (code -> while .)
    NEWLINE         reduce using rule 3 (code -> while .)


state 18

    (36) variable -> LOCAL .

    ASS             reduce using rule 36 (variable -> LOCAL .)
    LBRACK          reduce using rule 36 (variable -> LOCAL .)
    ADDASS          reduce using rule 36 (variable -> LOCAL .)
    SUBASS          reduce using rule 36 (variable -> LOCAL .)
    MULASS          reduce using rule 36 (variable -> LOCAL .)
    DIVASS          reduce using rule 36 (variable -> LOCAL .)
    MODASS          reduce using rule 36 (variable -> LOCAL .)
    EXPASS          reduce using rule 36 (variable -> LOCAL .)
    END             reduce using rule 36 (variable -> LOCAL .)
    IF              reduce using rule 36 (variable -> LOCAL .)
    WHILE           reduce using rule 36 (variable -> LOCAL .)
    BEGIN           reduce using rule 36 (variable -> LOCAL .)
    FOR             reduce using rule 36 (variable -> LOCAL .)
    NUMBER          reduce using rule 36 (variable -> LOCAL .)
    STRING          reduce using rule 36 (variable -> LOCAL .)
    LOCAL           reduce using rule 36 (variable -> LOCAL .)
    GLOBAL          reduce using rule 36 (variable -> LOCAL .)
    CONSTANTS       reduce using rule 36 (variable -> LOCAL .)
    INSTANCEVAR     reduce using rule 36 (variable -> LOCAL .)
    CLASSVAR        reduce using rule 36 (variable -> LOCAL .)
    ELSE            reduce using rule 36 (variable -> LOCAL .)
    ELSIF           reduce using rule 36 (variable -> LOCAL .)
    $end            reduce using rule 36 (variable -> LOCAL .)
    EQUAL           reduce using rule 36 (variable -> LOCAL .)
    NOTEQ           reduce using rule 36 (variable -> LOCAL .)
    GREATHER        reduce using rule 36 (variable -> LOCAL .)
    LOWER           reduce using rule 36 (variable -> LOCAL .)
    GREATHEREQ      reduce using rule 36 (variable -> LOCAL .)
    LOWEREQ         reduce using rule 36 (variable -> LOCAL .)
    IN              reduce using rule 36 (variable -> LOCAL .)
    NEWLINE         reduce using rule 36 (variable -> LOCAL .)
    COMA            reduce using rule 36 (variable -> LOCAL .)


state 19

    (1) code -> expr .

    IF              reduce using rule 1 (code -> expr .)
    WHILE           reduce using rule 1 (code -> expr .)
    BEGIN           reduce using rule 1 (code -> expr .)
    FOR             reduce using rule 1 (code -> expr .)
    NUMBER          reduce using rule 1 (code -> expr .)
    STRING          reduce using rule 1 (code -> expr .)
    LOCAL           reduce using rule 1 (code -> expr .)
    GLOBAL          reduce using rule 1 (code -> expr .)
    CONSTANTS       reduce using rule 1 (code -> expr .)
    INSTANCEVAR     reduce using rule 1 (code -> expr .)
    CLASSVAR        reduce using rule 1 (code -> expr .)
    END             reduce using rule 1 (code -> expr .)
    ELSE            reduce using rule 1 (code -> expr .)
    ELSIF           reduce using rule 1 (code -> expr .)
    $end            reduce using rule 1 (code -> expr .)
    NEWLINE         reduce using rule 1 (code -> expr .)


state 20

    (4) code -> expresiones .

    IF              reduce using rule 4 (code -> expresiones .)
    WHILE           reduce using rule 4 (code -> expresiones .)
    BEGIN           reduce using rule 4 (code -> expresiones .)
    FOR             reduce using rule 4 (code -> expresiones .)
    NUMBER          reduce using rule 4 (code -> expresiones .)
    STRING          reduce using rule 4 (code -> expresiones .)
    LOCAL           reduce using rule 4 (code -> expresiones .)
    GLOBAL          reduce using rule 4 (code -> expresiones .)
    CONSTANTS       reduce using rule 4 (code -> expresiones .)
    INSTANCEVAR     reduce using rule 4 (code -> expresiones .)
    CLASSVAR        reduce using rule 4 (code -> expresiones .)
    END             reduce using rule 4 (code -> expresiones .)
    ELSE            reduce using rule 4 (code -> expresiones .)
    ELSIF           reduce using rule 4 (code -> expresiones .)
    $end            reduce using rule 4 (code -> expresiones .)
    NEWLINE         reduce using rule 4 (code -> expresiones .)


state 21

    (56) term -> NUMBER .

    EXP             reduce using rule 56 (term -> NUMBER .)
    MUL             reduce using rule 56 (term -> NUMBER .)
    DIV             reduce using rule 56 (term -> NUMBER .)
    MOD             reduce using rule 56 (term -> NUMBER .)
    ADD             reduce using rule 56 (term -> NUMBER .)
    SUB             reduce using rule 56 (term -> NUMBER .)
    IF              reduce using rule 56 (term -> NUMBER .)
    WHILE           reduce using rule 56 (term -> NUMBER .)
    BEGIN           reduce using rule 56 (term -> NUMBER .)
    FOR             reduce using rule 56 (term -> NUMBER .)
    NUMBER          reduce using rule 56 (term -> NUMBER .)
    STRING          reduce using rule 56 (term -> NUMBER .)
    LOCAL           reduce using rule 56 (term -> NUMBER .)
    GLOBAL          reduce using rule 56 (term -> NUMBER .)
    CONSTANTS       reduce using rule 56 (term -> NUMBER .)
    INSTANCEVAR     reduce using rule 56 (term -> NUMBER .)
    CLASSVAR        reduce using rule 56 (term -> NUMBER .)
    $end            reduce using rule 56 (term -> NUMBER .)
    END             reduce using rule 56 (term -> NUMBER .)
    ELSE            reduce using rule 56 (term -> NUMBER .)
    ELSIF           reduce using rule 56 (term -> NUMBER .)
    NEWLINE         reduce using rule 56 (term -> NUMBER .)
    DOUBLESECUENCEPOINT reduce using rule 56 (term -> NUMBER .)
    EQUAL           reduce using rule 56 (term -> NUMBER .)
    NOTEQ           reduce using rule 56 (term -> NUMBER .)
    GREATHER        reduce using rule 56 (term -> NUMBER .)
    LOWER           reduce using rule 56 (term -> NUMBER .)
    GREATHEREQ      reduce using rule 56 (term -> NUMBER .)
    LOWEREQ         reduce using rule 56 (term -> NUMBER .)
    THEN            reduce using rule 56 (term -> NUMBER .)
    ANDLOG          reduce using rule 56 (term -> NUMBER .)
    ORLOG           reduce using rule 56 (term -> NUMBER .)
    NOTLOG          reduce using rule 56 (term -> NUMBER .)
    AND             reduce using rule 56 (term -> NUMBER .)
    OR              reduce using rule 56 (term -> NUMBER .)
    NOT             reduce using rule 56 (term -> NUMBER .)
    DO              reduce using rule 56 (term -> NUMBER .)
    DOBLEPOINT      reduce using rule 56 (term -> NUMBER .)


state 22

    (64) for -> FOR . iterador IN expresiones code END
    (65) for -> FOR . iterador IN expresiones DO code END
    (66) for -> FOR . iterador IN array code END
    (67) for -> FOR . iterador IN array DO code END
    (81) iterador -> . variable
    (82) iterador -> . variable COMA variable
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR

    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

    iterador                       shift and go to state 54
    variable                       shift and go to state 53

state 23

    (48) expr -> math .

    END             reduce using rule 48 (expr -> math .)
    IF              reduce using rule 48 (expr -> math .)
    WHILE           reduce using rule 48 (expr -> math .)
    BEGIN           reduce using rule 48 (expr -> math .)
    FOR             reduce using rule 48 (expr -> math .)
    NUMBER          reduce using rule 48 (expr -> math .)
    STRING          reduce using rule 48 (expr -> math .)
    LOCAL           reduce using rule 48 (expr -> math .)
    GLOBAL          reduce using rule 48 (expr -> math .)
    CONSTANTS       reduce using rule 48 (expr -> math .)
    INSTANCEVAR     reduce using rule 48 (expr -> math .)
    CLASSVAR        reduce using rule 48 (expr -> math .)
    $end            reduce using rule 48 (expr -> math .)
    ELSE            reduce using rule 48 (expr -> math .)
    ELSIF           reduce using rule 48 (expr -> math .)
    NEWLINE         reduce using rule 48 (expr -> math .)


state 24

    (37) variable -> GLOBAL .

    ASS             reduce using rule 37 (variable -> GLOBAL .)
    LBRACK          reduce using rule 37 (variable -> GLOBAL .)
    ADDASS          reduce using rule 37 (variable -> GLOBAL .)
    SUBASS          reduce using rule 37 (variable -> GLOBAL .)
    MULASS          reduce using rule 37 (variable -> GLOBAL .)
    DIVASS          reduce using rule 37 (variable -> GLOBAL .)
    MODASS          reduce using rule 37 (variable -> GLOBAL .)
    EXPASS          reduce using rule 37 (variable -> GLOBAL .)
    END             reduce using rule 37 (variable -> GLOBAL .)
    IF              reduce using rule 37 (variable -> GLOBAL .)
    WHILE           reduce using rule 37 (variable -> GLOBAL .)
    BEGIN           reduce using rule 37 (variable -> GLOBAL .)
    FOR             reduce using rule 37 (variable -> GLOBAL .)
    NUMBER          reduce using rule 37 (variable -> GLOBAL .)
    STRING          reduce using rule 37 (variable -> GLOBAL .)
    LOCAL           reduce using rule 37 (variable -> GLOBAL .)
    GLOBAL          reduce using rule 37 (variable -> GLOBAL .)
    CONSTANTS       reduce using rule 37 (variable -> GLOBAL .)
    INSTANCEVAR     reduce using rule 37 (variable -> GLOBAL .)
    CLASSVAR        reduce using rule 37 (variable -> GLOBAL .)
    ELSE            reduce using rule 37 (variable -> GLOBAL .)
    ELSIF           reduce using rule 37 (variable -> GLOBAL .)
    $end            reduce using rule 37 (variable -> GLOBAL .)
    EQUAL           reduce using rule 37 (variable -> GLOBAL .)
    NOTEQ           reduce using rule 37 (variable -> GLOBAL .)
    GREATHER        reduce using rule 37 (variable -> GLOBAL .)
    LOWER           reduce using rule 37 (variable -> GLOBAL .)
    GREATHEREQ      reduce using rule 37 (variable -> GLOBAL .)
    LOWEREQ         reduce using rule 37 (variable -> GLOBAL .)
    IN              reduce using rule 37 (variable -> GLOBAL .)
    NEWLINE         reduce using rule 37 (variable -> GLOBAL .)
    COMA            reduce using rule 37 (variable -> GLOBAL .)


state 25

    (12) logical -> term . comparison term
    (13) logical -> term . comparison logical
    (18) comparison -> . EQUAL
    (19) comparison -> . NOTEQ
    (20) comparison -> . GREATHER
    (21) comparison -> . LOWER
    (22) comparison -> . GREATHEREQ
    (23) comparison -> . LOWEREQ

    EQUAL           shift and go to state 56
    NOTEQ           shift and go to state 59
    GREATHER        shift and go to state 57
    LOWER           shift and go to state 58
    GREATHEREQ      shift and go to state 61
    LOWEREQ         shift and go to state 60

    comparison                     shift and go to state 55

state 26

    (17) logical -> BOOLEAN .

    ANDLOG          reduce using rule 17 (logical -> BOOLEAN .)
    ORLOG           reduce using rule 17 (logical -> BOOLEAN .)
    NOTLOG          reduce using rule 17 (logical -> BOOLEAN .)
    AND             reduce using rule 17 (logical -> BOOLEAN .)
    OR              reduce using rule 17 (logical -> BOOLEAN .)
    NOT             reduce using rule 17 (logical -> BOOLEAN .)
    THEN            reduce using rule 17 (logical -> BOOLEAN .)
    NUMBER          reduce using rule 17 (logical -> BOOLEAN .)
    STRING          reduce using rule 17 (logical -> BOOLEAN .)
    LOCAL           reduce using rule 17 (logical -> BOOLEAN .)
    GLOBAL          reduce using rule 17 (logical -> BOOLEAN .)
    CONSTANTS       reduce using rule 17 (logical -> BOOLEAN .)
    INSTANCEVAR     reduce using rule 17 (logical -> BOOLEAN .)
    CLASSVAR        reduce using rule 17 (logical -> BOOLEAN .)
    ELSE            reduce using rule 17 (logical -> BOOLEAN .)
    ELSIF           reduce using rule 17 (logical -> BOOLEAN .)
    IF              reduce using rule 17 (logical -> BOOLEAN .)
    WHILE           reduce using rule 17 (logical -> BOOLEAN .)
    BEGIN           reduce using rule 17 (logical -> BOOLEAN .)
    FOR             reduce using rule 17 (logical -> BOOLEAN .)
    $end            reduce using rule 17 (logical -> BOOLEAN .)
    END             reduce using rule 17 (logical -> BOOLEAN .)
    NEWLINE         reduce using rule 17 (logical -> BOOLEAN .)
    DO              reduce using rule 17 (logical -> BOOLEAN .)
    DOBLEPOINT      reduce using rule 17 (logical -> BOOLEAN .)


state 27

    (69) if -> IF logical . expr END
    (70) if -> IF logical . THEN expr END
    (71) if -> IF logical .
    (72) if -> IF logical . THEN
    (16) logical -> logical . logcompare logical
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (24) logcompare -> . ANDLOG
    (25) logcompare -> . ORLOG
    (26) logcompare -> . NOTLOG
    (27) logcompare -> . AND
    (28) logcompare -> . OR
    (29) logcompare -> . NOT
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for LOCAL resolved as shift
  ! shift/reduce conflict for GLOBAL resolved as shift
  ! shift/reduce conflict for CONSTANTS resolved as shift
  ! shift/reduce conflict for INSTANCEVAR resolved as shift
  ! shift/reduce conflict for CLASSVAR resolved as shift
    THEN            shift and go to state 63
    ELSE            reduce using rule 71 (if -> IF logical .)
    ELSIF           reduce using rule 71 (if -> IF logical .)
    END             reduce using rule 71 (if -> IF logical .)
    IF              reduce using rule 71 (if -> IF logical .)
    WHILE           reduce using rule 71 (if -> IF logical .)
    BEGIN           reduce using rule 71 (if -> IF logical .)
    FOR             reduce using rule 71 (if -> IF logical .)
    $end            reduce using rule 71 (if -> IF logical .)
    NEWLINE         reduce using rule 71 (if -> IF logical .)
    ANDLOG          shift and go to state 67
    ORLOG           shift and go to state 62
    NOTLOG          shift and go to state 72
    AND             shift and go to state 70
    OR              shift and go to state 65
    NOT             shift and go to state 68
    NUMBER          shift and go to state 21
    STRING          shift and go to state 8
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

  ! NUMBER          [ reduce using rule 71 (if -> IF logical .) ]
  ! STRING          [ reduce using rule 71 (if -> IF logical .) ]
  ! LOCAL           [ reduce using rule 71 (if -> IF logical .) ]
  ! GLOBAL          [ reduce using rule 71 (if -> IF logical .) ]
  ! CONSTANTS       [ reduce using rule 71 (if -> IF logical .) ]
  ! INSTANCEVAR     [ reduce using rule 71 (if -> IF logical .) ]
  ! CLASSVAR        [ reduce using rule 71 (if -> IF logical .) ]

    term                           shift and go to state 69
    expr                           shift and go to state 66
    sterm                          shift and go to state 12
    index                          shift and go to state 3
    slice                          shift and go to state 2
    math                           shift and go to state 23
    variable                       shift and go to state 64
    logcompare                     shift and go to state 71

state 28

    (14) logical -> variable . comparison term
    (15) logical -> variable . comparison BOOLEAN
    (18) comparison -> . EQUAL
    (19) comparison -> . NOTEQ
    (20) comparison -> . GREATHER
    (21) comparison -> . LOWER
    (22) comparison -> . GREATHEREQ
    (23) comparison -> . LOWEREQ

    EQUAL           shift and go to state 56
    NOTEQ           shift and go to state 59
    GREATHER        shift and go to state 57
    LOWER           shift and go to state 58
    GREATHEREQ      shift and go to state 61
    LOWEREQ         shift and go to state 60

    comparison                     shift and go to state 73

state 29

    (75) else -> ELSE . code END
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 4
    WHILE           shift and go to state 13
    BEGIN           shift and go to state 10
    FOR             shift and go to state 22
    NUMBER          shift and go to state 21
    STRING          shift and go to state 8
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

    assign                         shift and go to state 1
    for                            shift and go to state 6
    sterm                          shift and go to state 12
    slice                          shift and go to state 2
    index                          shift and go to state 3
    variable                       shift and go to state 15
    code                           shift and go to state 74
    term                           shift and go to state 7
    expr                           shift and go to state 19
    expresiones                    shift and go to state 20
    math                           shift and go to state 23
    while                          shift and go to state 17
    if                             shift and go to state 5

state 30

    (74) if -> if elsif . END

    END             shift and go to state 75


state 31

    (73) if -> if else .

    ELSE            reduce using rule 73 (if -> if else .)
    ELSIF           reduce using rule 73 (if -> if else .)
    END             reduce using rule 73 (if -> if else .)
    IF              reduce using rule 73 (if -> if else .)
    WHILE           reduce using rule 73 (if -> if else .)
    BEGIN           reduce using rule 73 (if -> if else .)
    FOR             reduce using rule 73 (if -> if else .)
    NUMBER          reduce using rule 73 (if -> if else .)
    STRING          reduce using rule 73 (if -> if else .)
    LOCAL           reduce using rule 73 (if -> if else .)
    GLOBAL          reduce using rule 73 (if -> if else .)
    CONSTANTS       reduce using rule 73 (if -> if else .)
    INSTANCEVAR     reduce using rule 73 (if -> if else .)
    CLASSVAR        reduce using rule 73 (if -> if else .)
    $end            reduce using rule 73 (if -> if else .)
    NEWLINE         reduce using rule 73 (if -> if else .)


state 32

    (76) elsif -> ELSIF . logical final
    (12) logical -> . term comparison term
    (13) logical -> . term comparison logical
    (14) logical -> . variable comparison term
    (15) logical -> . variable comparison BOOLEAN
    (16) logical -> . logical logcompare logical
    (17) logical -> . BOOLEAN
    (56) term -> . NUMBER
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR

    BOOLEAN         shift and go to state 26
    NUMBER          shift and go to state 21
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

    logical                        shift and go to state 76
    term                           shift and go to state 25
    variable                       shift and go to state 28

state 33

    (59) arith -> MUL .

    NUMBER          reduce using rule 59 (arith -> MUL .)
    LOCAL           reduce using rule 59 (arith -> MUL .)
    GLOBAL          reduce using rule 59 (arith -> MUL .)
    CONSTANTS       reduce using rule 59 (arith -> MUL .)
    INSTANCEVAR     reduce using rule 59 (arith -> MUL .)
    CLASSVAR        reduce using rule 59 (arith -> MUL .)


state 34

    (61) arith -> MOD .

    NUMBER          reduce using rule 61 (arith -> MOD .)
    LOCAL           reduce using rule 61 (arith -> MOD .)
    GLOBAL          reduce using rule 61 (arith -> MOD .)
    CONSTANTS       reduce using rule 61 (arith -> MOD .)
    INSTANCEVAR     reduce using rule 61 (arith -> MOD .)
    CLASSVAR        reduce using rule 61 (arith -> MOD .)


state 35

    (33) math -> term arith . term
    (34) math -> term arith . math
    (56) term -> . NUMBER
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR

    NUMBER          shift and go to state 21
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

    term                           shift and go to state 77
    math                           shift and go to state 78
    variable                       shift and go to state 79

state 36

    (83) expresiones -> term DOUBLESECUENCEPOINT . term
    (56) term -> . NUMBER

    NUMBER          shift and go to state 21

    term                           shift and go to state 80

state 37

    (63) arith -> SUB .

    NUMBER          reduce using rule 63 (arith -> SUB .)
    LOCAL           reduce using rule 63 (arith -> SUB .)
    GLOBAL          reduce using rule 63 (arith -> SUB .)
    CONSTANTS       reduce using rule 63 (arith -> SUB .)
    INSTANCEVAR     reduce using rule 63 (arith -> SUB .)
    CLASSVAR        reduce using rule 63 (arith -> SUB .)


state 38

    (62) arith -> ADD .

    NUMBER          reduce using rule 62 (arith -> ADD .)
    LOCAL           reduce using rule 62 (arith -> ADD .)
    GLOBAL          reduce using rule 62 (arith -> ADD .)
    CONSTANTS       reduce using rule 62 (arith -> ADD .)
    INSTANCEVAR     reduce using rule 62 (arith -> ADD .)
    CLASSVAR        reduce using rule 62 (arith -> ADD .)


state 39

    (58) arith -> EXP .

    NUMBER          reduce using rule 58 (arith -> EXP .)
    LOCAL           reduce using rule 58 (arith -> EXP .)
    GLOBAL          reduce using rule 58 (arith -> EXP .)
    CONSTANTS       reduce using rule 58 (arith -> EXP .)
    INSTANCEVAR     reduce using rule 58 (arith -> EXP .)
    CLASSVAR        reduce using rule 58 (arith -> EXP .)


state 40

    (60) arith -> DIV .

    NUMBER          reduce using rule 60 (arith -> DIV .)
    LOCAL           reduce using rule 60 (arith -> DIV .)
    GLOBAL          reduce using rule 60 (arith -> DIV .)
    CONSTANTS       reduce using rule 60 (arith -> DIV .)
    INSTANCEVAR     reduce using rule 60 (arith -> DIV .)
    CLASSVAR        reduce using rule 60 (arith -> DIV .)


state 41

    (7) code -> code code .
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for LOCAL resolved as shift
  ! shift/reduce conflict for GLOBAL resolved as shift
  ! shift/reduce conflict for CONSTANTS resolved as shift
  ! shift/reduce conflict for INSTANCEVAR resolved as shift
  ! shift/reduce conflict for CLASSVAR resolved as shift
    END             reduce using rule 7 (code -> code code .)
    ELSE            reduce using rule 7 (code -> code code .)
    ELSIF           reduce using rule 7 (code -> code code .)
    $end            reduce using rule 7 (code -> code code .)
    NEWLINE         reduce using rule 7 (code -> code code .)
    IF              shift and go to state 4
    WHILE           shift and go to state 13
    BEGIN           shift and go to state 10
    FOR             shift and go to state 22
    NUMBER          shift and go to state 21
    STRING          shift and go to state 8
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

  ! IF              [ reduce using rule 7 (code -> code code .) ]
  ! WHILE           [ reduce using rule 7 (code -> code code .) ]
  ! BEGIN           [ reduce using rule 7 (code -> code code .) ]
  ! FOR             [ reduce using rule 7 (code -> code code .) ]
  ! NUMBER          [ reduce using rule 7 (code -> code code .) ]
  ! STRING          [ reduce using rule 7 (code -> code code .) ]
  ! LOCAL           [ reduce using rule 7 (code -> code code .) ]
  ! GLOBAL          [ reduce using rule 7 (code -> code code .) ]
  ! CONSTANTS       [ reduce using rule 7 (code -> code code .) ]
  ! INSTANCEVAR     [ reduce using rule 7 (code -> code code .) ]
  ! CLASSVAR        [ reduce using rule 7 (code -> code code .) ]

    assign                         shift and go to state 1
    for                            shift and go to state 6
    sterm                          shift and go to state 12
    slice                          shift and go to state 2
    index                          shift and go to state 3
    variable                       shift and go to state 15
    code                           shift and go to state 41
    term                           shift and go to state 7
    expr                           shift and go to state 19
    expresiones                    shift and go to state 20
    math                           shift and go to state 23
    while                          shift and go to state 17
    if                             shift and go to state 5

state 42

    (11) while -> BEGIN code . END WHILE logical
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    END             shift and go to state 81
    IF              shift and go to state 4
    WHILE           shift and go to state 13
    BEGIN           shift and go to state 10
    FOR             shift and go to state 22
    NUMBER          shift and go to state 21
    STRING          shift and go to state 8
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

    assign                         shift and go to state 1
    for                            shift and go to state 6
    sterm                          shift and go to state 12
    slice                          shift and go to state 2
    index                          shift and go to state 3
    expr                           shift and go to state 19
    variable                       shift and go to state 15
    code                           shift and go to state 41
    term                           shift and go to state 7
    expresiones                    shift and go to state 20
    math                           shift and go to state 23
    while                          shift and go to state 17
    if                             shift and go to state 5

state 43

    (8) while -> WHILE logical . code END
    (9) while -> WHILE logical . DO salto code salto END
    (10) while -> WHILE logical . DOBLEPOINT salto code salto END
    (16) logical -> logical . logcompare logical
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (24) logcompare -> . ANDLOG
    (25) logcompare -> . ORLOG
    (26) logcompare -> . NOTLOG
    (27) logcompare -> . AND
    (28) logcompare -> . OR
    (29) logcompare -> . NOT
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    DO              shift and go to state 84
    DOBLEPOINT      shift and go to state 82
    ANDLOG          shift and go to state 67
    ORLOG           shift and go to state 62
    NOTLOG          shift and go to state 72
    AND             shift and go to state 70
    OR              shift and go to state 65
    NOT             shift and go to state 68
    IF              shift and go to state 4
    WHILE           shift and go to state 13
    BEGIN           shift and go to state 10
    FOR             shift and go to state 22
    NUMBER          shift and go to state 21
    STRING          shift and go to state 8
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

    assign                         shift and go to state 1
    for                            shift and go to state 6
    sterm                          shift and go to state 12
    slice                          shift and go to state 2
    index                          shift and go to state 3
    expr                           shift and go to state 19
    variable                       shift and go to state 15
    code                           shift and go to state 83
    term                           shift and go to state 7
    expresiones                    shift and go to state 20
    math                           shift and go to state 23
    logcompare                     shift and go to state 71
    while                          shift and go to state 17
    if                             shift and go to state 5

state 44

    (30) assign -> variable ASS . expr
    (31) assign -> variable ASS . sexpr
    (32) assign -> variable ASS . array
    (41) asig -> ASS .
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (54) sexpr -> . sterm MUL term
    (55) sexpr -> . sterm ADD sexpr
    (84) array -> . LBRACK defarray RBRACK
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

  ! shift/reduce conflict for NUMBER resolved as shift
    LBRACK          shift and go to state 89
    NUMBER          shift and go to state 21
    STRING          shift and go to state 8
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

  ! NUMBER          [ reduce using rule 41 (asig -> ASS .) ]

    term                           shift and go to state 69
    array                          shift and go to state 88
    sterm                          shift and go to state 85
    slice                          shift and go to state 2
    index                          shift and go to state 3
    expr                           shift and go to state 86
    math                           shift and go to state 23
    variable                       shift and go to state 64
    sexpr                          shift and go to state 87

state 45

    (47) asig -> EXPASS .

    NUMBER          reduce using rule 47 (asig -> EXPASS .)


state 46

    (45) asig -> DIVASS .

    NUMBER          reduce using rule 45 (asig -> DIVASS .)


state 47

    (35) math -> variable asig . term
    (56) term -> . NUMBER

    NUMBER          shift and go to state 21

    term                           shift and go to state 90

state 48

    (44) asig -> MULASS .

    NUMBER          reduce using rule 44 (asig -> MULASS .)


state 49

    (46) asig -> MODASS .

    NUMBER          reduce using rule 46 (asig -> MODASS .)


state 50

    (43) asig -> SUBASS .

    NUMBER          reduce using rule 43 (asig -> SUBASS .)


state 51

    (42) asig -> ADDASS .

    NUMBER          reduce using rule 42 (asig -> ADDASS .)


state 52

    (96) slice -> variable LBRACK . defslice RBRACK
    (95) index -> variable LBRACK . INT RBRACK
    (97) defslice -> . INT DOBLEPOINT INT
    (98) defslice -> . INT DOBLEPOINT
    (99) defslice -> . DOBLEPOINT INT

    INT             shift and go to state 92
    DOBLEPOINT      shift and go to state 93

    defslice                       shift and go to state 91

state 53

    (81) iterador -> variable .
    (82) iterador -> variable . COMA variable

    IN              reduce using rule 81 (iterador -> variable .)
    COMA            shift and go to state 94


state 54

    (64) for -> FOR iterador . IN expresiones code END
    (65) for -> FOR iterador . IN expresiones DO code END
    (66) for -> FOR iterador . IN array code END
    (67) for -> FOR iterador . IN array DO code END

    IN              shift and go to state 95


state 55

    (12) logical -> term comparison . term
    (13) logical -> term comparison . logical
    (56) term -> . NUMBER
    (12) logical -> . term comparison term
    (13) logical -> . term comparison logical
    (14) logical -> . variable comparison term
    (15) logical -> . variable comparison BOOLEAN
    (16) logical -> . logical logcompare logical
    (17) logical -> . BOOLEAN
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR

    NUMBER          shift and go to state 21
    BOOLEAN         shift and go to state 26
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

    term                           shift and go to state 96
    variable                       shift and go to state 28
    logical                        shift and go to state 97

state 56

    (18) comparison -> EQUAL .

    BOOLEAN         reduce using rule 18 (comparison -> EQUAL .)
    NUMBER          reduce using rule 18 (comparison -> EQUAL .)
    LOCAL           reduce using rule 18 (comparison -> EQUAL .)
    GLOBAL          reduce using rule 18 (comparison -> EQUAL .)
    CONSTANTS       reduce using rule 18 (comparison -> EQUAL .)
    INSTANCEVAR     reduce using rule 18 (comparison -> EQUAL .)
    CLASSVAR        reduce using rule 18 (comparison -> EQUAL .)


state 57

    (20) comparison -> GREATHER .

    BOOLEAN         reduce using rule 20 (comparison -> GREATHER .)
    NUMBER          reduce using rule 20 (comparison -> GREATHER .)
    LOCAL           reduce using rule 20 (comparison -> GREATHER .)
    GLOBAL          reduce using rule 20 (comparison -> GREATHER .)
    CONSTANTS       reduce using rule 20 (comparison -> GREATHER .)
    INSTANCEVAR     reduce using rule 20 (comparison -> GREATHER .)
    CLASSVAR        reduce using rule 20 (comparison -> GREATHER .)


state 58

    (21) comparison -> LOWER .

    BOOLEAN         reduce using rule 21 (comparison -> LOWER .)
    NUMBER          reduce using rule 21 (comparison -> LOWER .)
    LOCAL           reduce using rule 21 (comparison -> LOWER .)
    GLOBAL          reduce using rule 21 (comparison -> LOWER .)
    CONSTANTS       reduce using rule 21 (comparison -> LOWER .)
    INSTANCEVAR     reduce using rule 21 (comparison -> LOWER .)
    CLASSVAR        reduce using rule 21 (comparison -> LOWER .)


state 59

    (19) comparison -> NOTEQ .

    BOOLEAN         reduce using rule 19 (comparison -> NOTEQ .)
    NUMBER          reduce using rule 19 (comparison -> NOTEQ .)
    LOCAL           reduce using rule 19 (comparison -> NOTEQ .)
    GLOBAL          reduce using rule 19 (comparison -> NOTEQ .)
    CONSTANTS       reduce using rule 19 (comparison -> NOTEQ .)
    INSTANCEVAR     reduce using rule 19 (comparison -> NOTEQ .)
    CLASSVAR        reduce using rule 19 (comparison -> NOTEQ .)


state 60

    (23) comparison -> LOWEREQ .

    BOOLEAN         reduce using rule 23 (comparison -> LOWEREQ .)
    NUMBER          reduce using rule 23 (comparison -> LOWEREQ .)
    LOCAL           reduce using rule 23 (comparison -> LOWEREQ .)
    GLOBAL          reduce using rule 23 (comparison -> LOWEREQ .)
    CONSTANTS       reduce using rule 23 (comparison -> LOWEREQ .)
    INSTANCEVAR     reduce using rule 23 (comparison -> LOWEREQ .)
    CLASSVAR        reduce using rule 23 (comparison -> LOWEREQ .)


state 61

    (22) comparison -> GREATHEREQ .

    BOOLEAN         reduce using rule 22 (comparison -> GREATHEREQ .)
    NUMBER          reduce using rule 22 (comparison -> GREATHEREQ .)
    LOCAL           reduce using rule 22 (comparison -> GREATHEREQ .)
    GLOBAL          reduce using rule 22 (comparison -> GREATHEREQ .)
    CONSTANTS       reduce using rule 22 (comparison -> GREATHEREQ .)
    INSTANCEVAR     reduce using rule 22 (comparison -> GREATHEREQ .)
    CLASSVAR        reduce using rule 22 (comparison -> GREATHEREQ .)


state 62

    (25) logcompare -> ORLOG .

    BOOLEAN         reduce using rule 25 (logcompare -> ORLOG .)
    NUMBER          reduce using rule 25 (logcompare -> ORLOG .)
    LOCAL           reduce using rule 25 (logcompare -> ORLOG .)
    GLOBAL          reduce using rule 25 (logcompare -> ORLOG .)
    CONSTANTS       reduce using rule 25 (logcompare -> ORLOG .)
    INSTANCEVAR     reduce using rule 25 (logcompare -> ORLOG .)
    CLASSVAR        reduce using rule 25 (logcompare -> ORLOG .)


state 63

    (70) if -> IF logical THEN . expr END
    (72) if -> IF logical THEN .
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for LOCAL resolved as shift
  ! shift/reduce conflict for GLOBAL resolved as shift
  ! shift/reduce conflict for CONSTANTS resolved as shift
  ! shift/reduce conflict for INSTANCEVAR resolved as shift
  ! shift/reduce conflict for CLASSVAR resolved as shift
    ELSE            reduce using rule 72 (if -> IF logical THEN .)
    ELSIF           reduce using rule 72 (if -> IF logical THEN .)
    END             reduce using rule 72 (if -> IF logical THEN .)
    IF              reduce using rule 72 (if -> IF logical THEN .)
    WHILE           reduce using rule 72 (if -> IF logical THEN .)
    BEGIN           reduce using rule 72 (if -> IF logical THEN .)
    FOR             reduce using rule 72 (if -> IF logical THEN .)
    $end            reduce using rule 72 (if -> IF logical THEN .)
    NEWLINE         reduce using rule 72 (if -> IF logical THEN .)
    NUMBER          shift and go to state 21
    STRING          shift and go to state 8
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

  ! NUMBER          [ reduce using rule 72 (if -> IF logical THEN .) ]
  ! STRING          [ reduce using rule 72 (if -> IF logical THEN .) ]
  ! LOCAL           [ reduce using rule 72 (if -> IF logical THEN .) ]
  ! GLOBAL          [ reduce using rule 72 (if -> IF logical THEN .) ]
  ! CONSTANTS       [ reduce using rule 72 (if -> IF logical THEN .) ]
  ! INSTANCEVAR     [ reduce using rule 72 (if -> IF logical THEN .) ]
  ! CLASSVAR        [ reduce using rule 72 (if -> IF logical THEN .) ]

    math                           shift and go to state 23
    index                          shift and go to state 3
    term                           shift and go to state 69
    sterm                          shift and go to state 12
    expr                           shift and go to state 98
    slice                          shift and go to state 2
    variable                       shift and go to state 64

state 64

    (51) expr -> variable .
    (35) math -> variable . asig term
    (96) slice -> variable . LBRACK defslice RBRACK
    (95) index -> variable . LBRACK INT RBRACK
    (41) asig -> . ASS
    (42) asig -> . ADDASS
    (43) asig -> . SUBASS
    (44) asig -> . MULASS
    (45) asig -> . DIVASS
    (46) asig -> . MODASS
    (47) asig -> . EXPASS

    IF              reduce using rule 51 (expr -> variable .)
    WHILE           reduce using rule 51 (expr -> variable .)
    BEGIN           reduce using rule 51 (expr -> variable .)
    FOR             reduce using rule 51 (expr -> variable .)
    NUMBER          reduce using rule 51 (expr -> variable .)
    STRING          reduce using rule 51 (expr -> variable .)
    LOCAL           reduce using rule 51 (expr -> variable .)
    GLOBAL          reduce using rule 51 (expr -> variable .)
    CONSTANTS       reduce using rule 51 (expr -> variable .)
    INSTANCEVAR     reduce using rule 51 (expr -> variable .)
    CLASSVAR        reduce using rule 51 (expr -> variable .)
    $end            reduce using rule 51 (expr -> variable .)
    END             reduce using rule 51 (expr -> variable .)
    ELSE            reduce using rule 51 (expr -> variable .)
    ELSIF           reduce using rule 51 (expr -> variable .)
    NEWLINE         reduce using rule 51 (expr -> variable .)
    LBRACK          shift and go to state 52
    ASS             shift and go to state 99
    ADDASS          shift and go to state 51
    SUBASS          shift and go to state 50
    MULASS          shift and go to state 48
    DIVASS          shift and go to state 46
    MODASS          shift and go to state 49
    EXPASS          shift and go to state 45

    asig                           shift and go to state 47

state 65

    (28) logcompare -> OR .

    BOOLEAN         reduce using rule 28 (logcompare -> OR .)
    NUMBER          reduce using rule 28 (logcompare -> OR .)
    LOCAL           reduce using rule 28 (logcompare -> OR .)
    GLOBAL          reduce using rule 28 (logcompare -> OR .)
    CONSTANTS       reduce using rule 28 (logcompare -> OR .)
    INSTANCEVAR     reduce using rule 28 (logcompare -> OR .)
    CLASSVAR        reduce using rule 28 (logcompare -> OR .)


state 66

    (69) if -> IF logical expr . END

    END             shift and go to state 100


state 67

    (24) logcompare -> ANDLOG .

    BOOLEAN         reduce using rule 24 (logcompare -> ANDLOG .)
    NUMBER          reduce using rule 24 (logcompare -> ANDLOG .)
    LOCAL           reduce using rule 24 (logcompare -> ANDLOG .)
    GLOBAL          reduce using rule 24 (logcompare -> ANDLOG .)
    CONSTANTS       reduce using rule 24 (logcompare -> ANDLOG .)
    INSTANCEVAR     reduce using rule 24 (logcompare -> ANDLOG .)
    CLASSVAR        reduce using rule 24 (logcompare -> ANDLOG .)


state 68

    (29) logcompare -> NOT .

    BOOLEAN         reduce using rule 29 (logcompare -> NOT .)
    NUMBER          reduce using rule 29 (logcompare -> NOT .)
    LOCAL           reduce using rule 29 (logcompare -> NOT .)
    GLOBAL          reduce using rule 29 (logcompare -> NOT .)
    CONSTANTS       reduce using rule 29 (logcompare -> NOT .)
    INSTANCEVAR     reduce using rule 29 (logcompare -> NOT .)
    CLASSVAR        reduce using rule 29 (logcompare -> NOT .)


state 69

    (49) expr -> term .
    (33) math -> term . arith term
    (34) math -> term . arith math
    (58) arith -> . EXP
    (59) arith -> . MUL
    (60) arith -> . DIV
    (61) arith -> . MOD
    (62) arith -> . ADD
    (63) arith -> . SUB

    IF              reduce using rule 49 (expr -> term .)
    WHILE           reduce using rule 49 (expr -> term .)
    BEGIN           reduce using rule 49 (expr -> term .)
    FOR             reduce using rule 49 (expr -> term .)
    NUMBER          reduce using rule 49 (expr -> term .)
    STRING          reduce using rule 49 (expr -> term .)
    LOCAL           reduce using rule 49 (expr -> term .)
    GLOBAL          reduce using rule 49 (expr -> term .)
    CONSTANTS       reduce using rule 49 (expr -> term .)
    INSTANCEVAR     reduce using rule 49 (expr -> term .)
    CLASSVAR        reduce using rule 49 (expr -> term .)
    $end            reduce using rule 49 (expr -> term .)
    END             reduce using rule 49 (expr -> term .)
    ELSE            reduce using rule 49 (expr -> term .)
    ELSIF           reduce using rule 49 (expr -> term .)
    NEWLINE         reduce using rule 49 (expr -> term .)
    EXP             shift and go to state 39
    MUL             shift and go to state 33
    DIV             shift and go to state 40
    MOD             shift and go to state 34
    ADD             shift and go to state 38
    SUB             shift and go to state 37

    arith                          shift and go to state 35

state 70

    (27) logcompare -> AND .

    BOOLEAN         reduce using rule 27 (logcompare -> AND .)
    NUMBER          reduce using rule 27 (logcompare -> AND .)
    LOCAL           reduce using rule 27 (logcompare -> AND .)
    GLOBAL          reduce using rule 27 (logcompare -> AND .)
    CONSTANTS       reduce using rule 27 (logcompare -> AND .)
    INSTANCEVAR     reduce using rule 27 (logcompare -> AND .)
    CLASSVAR        reduce using rule 27 (logcompare -> AND .)


state 71

    (16) logical -> logical logcompare . logical
    (12) logical -> . term comparison term
    (13) logical -> . term comparison logical
    (14) logical -> . variable comparison term
    (15) logical -> . variable comparison BOOLEAN
    (16) logical -> . logical logcompare logical
    (17) logical -> . BOOLEAN
    (56) term -> . NUMBER
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR

    BOOLEAN         shift and go to state 26
    NUMBER          shift and go to state 21
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

    logical                        shift and go to state 101
    term                           shift and go to state 25
    variable                       shift and go to state 28

state 72

    (26) logcompare -> NOTLOG .

    BOOLEAN         reduce using rule 26 (logcompare -> NOTLOG .)
    NUMBER          reduce using rule 26 (logcompare -> NOTLOG .)
    LOCAL           reduce using rule 26 (logcompare -> NOTLOG .)
    GLOBAL          reduce using rule 26 (logcompare -> NOTLOG .)
    CONSTANTS       reduce using rule 26 (logcompare -> NOTLOG .)
    INSTANCEVAR     reduce using rule 26 (logcompare -> NOTLOG .)
    CLASSVAR        reduce using rule 26 (logcompare -> NOTLOG .)


state 73

    (14) logical -> variable comparison . term
    (15) logical -> variable comparison . BOOLEAN
    (56) term -> . NUMBER

    BOOLEAN         shift and go to state 103
    NUMBER          shift and go to state 21

    term                           shift and go to state 102

state 74

    (75) else -> ELSE code . END
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    END             shift and go to state 104
    IF              shift and go to state 4
    WHILE           shift and go to state 13
    BEGIN           shift and go to state 10
    FOR             shift and go to state 22
    NUMBER          shift and go to state 21
    STRING          shift and go to state 8
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

    assign                         shift and go to state 1
    for                            shift and go to state 6
    sterm                          shift and go to state 12
    slice                          shift and go to state 2
    index                          shift and go to state 3
    variable                       shift and go to state 15
    code                           shift and go to state 41
    term                           shift and go to state 7
    expr                           shift and go to state 19
    expresiones                    shift and go to state 20
    math                           shift and go to state 23
    while                          shift and go to state 17
    if                             shift and go to state 5

state 75

    (74) if -> if elsif END .

    ELSE            reduce using rule 74 (if -> if elsif END .)
    ELSIF           reduce using rule 74 (if -> if elsif END .)
    END             reduce using rule 74 (if -> if elsif END .)
    IF              reduce using rule 74 (if -> if elsif END .)
    WHILE           reduce using rule 74 (if -> if elsif END .)
    BEGIN           reduce using rule 74 (if -> if elsif END .)
    FOR             reduce using rule 74 (if -> if elsif END .)
    NUMBER          reduce using rule 74 (if -> if elsif END .)
    STRING          reduce using rule 74 (if -> if elsif END .)
    LOCAL           reduce using rule 74 (if -> if elsif END .)
    GLOBAL          reduce using rule 74 (if -> if elsif END .)
    CONSTANTS       reduce using rule 74 (if -> if elsif END .)
    INSTANCEVAR     reduce using rule 74 (if -> if elsif END .)
    CLASSVAR        reduce using rule 74 (if -> if elsif END .)
    $end            reduce using rule 74 (if -> if elsif END .)
    NEWLINE         reduce using rule 74 (if -> if elsif END .)


state 76

    (76) elsif -> ELSIF logical . final
    (16) logical -> logical . logcompare logical
    (77) final -> . code
    (78) final -> . THEN code
    (79) final -> . code else
    (80) final -> . code elsif
    (24) logcompare -> . ANDLOG
    (25) logcompare -> . ORLOG
    (26) logcompare -> . NOTLOG
    (27) logcompare -> . AND
    (28) logcompare -> . OR
    (29) logcompare -> . NOT
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    THEN            shift and go to state 105
    ANDLOG          shift and go to state 67
    ORLOG           shift and go to state 62
    NOTLOG          shift and go to state 72
    AND             shift and go to state 70
    OR              shift and go to state 65
    NOT             shift and go to state 68
    IF              shift and go to state 4
    WHILE           shift and go to state 13
    BEGIN           shift and go to state 10
    FOR             shift and go to state 22
    NUMBER          shift and go to state 21
    STRING          shift and go to state 8
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

    assign                         shift and go to state 1
    sterm                          shift and go to state 12
    slice                          shift and go to state 2
    variable                       shift and go to state 15
    expr                           shift and go to state 19
    index                          shift and go to state 3
    code                           shift and go to state 106
    term                           shift and go to state 7
    final                          shift and go to state 107
    expresiones                    shift and go to state 20
    math                           shift and go to state 23
    logcompare                     shift and go to state 71
    for                            shift and go to state 6
    while                          shift and go to state 17
    if                             shift and go to state 5

state 77

    (33) math -> term arith term .
    (33) math -> term . arith term
    (34) math -> term . arith math
    (58) arith -> . EXP
    (59) arith -> . MUL
    (60) arith -> . DIV
    (61) arith -> . MOD
    (62) arith -> . ADD
    (63) arith -> . SUB

    END             reduce using rule 33 (math -> term arith term .)
    IF              reduce using rule 33 (math -> term arith term .)
    WHILE           reduce using rule 33 (math -> term arith term .)
    BEGIN           reduce using rule 33 (math -> term arith term .)
    FOR             reduce using rule 33 (math -> term arith term .)
    NUMBER          reduce using rule 33 (math -> term arith term .)
    STRING          reduce using rule 33 (math -> term arith term .)
    LOCAL           reduce using rule 33 (math -> term arith term .)
    GLOBAL          reduce using rule 33 (math -> term arith term .)
    CONSTANTS       reduce using rule 33 (math -> term arith term .)
    INSTANCEVAR     reduce using rule 33 (math -> term arith term .)
    CLASSVAR        reduce using rule 33 (math -> term arith term .)
    ELSE            reduce using rule 33 (math -> term arith term .)
    ELSIF           reduce using rule 33 (math -> term arith term .)
    $end            reduce using rule 33 (math -> term arith term .)
    NEWLINE         reduce using rule 33 (math -> term arith term .)
    EXP             shift and go to state 39
    MUL             shift and go to state 33
    DIV             shift and go to state 40
    MOD             shift and go to state 34
    ADD             shift and go to state 38
    SUB             shift and go to state 37

    arith                          shift and go to state 35

state 78

    (34) math -> term arith math .

    END             reduce using rule 34 (math -> term arith math .)
    IF              reduce using rule 34 (math -> term arith math .)
    WHILE           reduce using rule 34 (math -> term arith math .)
    BEGIN           reduce using rule 34 (math -> term arith math .)
    FOR             reduce using rule 34 (math -> term arith math .)
    NUMBER          reduce using rule 34 (math -> term arith math .)
    STRING          reduce using rule 34 (math -> term arith math .)
    LOCAL           reduce using rule 34 (math -> term arith math .)
    GLOBAL          reduce using rule 34 (math -> term arith math .)
    CONSTANTS       reduce using rule 34 (math -> term arith math .)
    INSTANCEVAR     reduce using rule 34 (math -> term arith math .)
    CLASSVAR        reduce using rule 34 (math -> term arith math .)
    ELSE            reduce using rule 34 (math -> term arith math .)
    ELSIF           reduce using rule 34 (math -> term arith math .)
    $end            reduce using rule 34 (math -> term arith math .)
    NEWLINE         reduce using rule 34 (math -> term arith math .)


state 79

    (35) math -> variable . asig term
    (41) asig -> . ASS
    (42) asig -> . ADDASS
    (43) asig -> . SUBASS
    (44) asig -> . MULASS
    (45) asig -> . DIVASS
    (46) asig -> . MODASS
    (47) asig -> . EXPASS

    ASS             shift and go to state 99
    ADDASS          shift and go to state 51
    SUBASS          shift and go to state 50
    MULASS          shift and go to state 48
    DIVASS          shift and go to state 46
    MODASS          shift and go to state 49
    EXPASS          shift and go to state 45

    asig                           shift and go to state 47

state 80

    (83) expresiones -> term DOUBLESECUENCEPOINT term .

    IF              reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    WHILE           reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    BEGIN           reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    FOR             reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    NUMBER          reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    STRING          reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    LOCAL           reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    GLOBAL          reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    CONSTANTS       reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    INSTANCEVAR     reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    CLASSVAR        reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    NEWLINE         reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    END             reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    $end            reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    DO              reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    ELSE            reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    ELSIF           reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)


state 81

    (11) while -> BEGIN code END . WHILE logical

    WHILE           shift and go to state 108


state 82

    (10) while -> WHILE logical DOBLEPOINT . salto code salto END
    (68) salto -> . NEWLINE

    NEWLINE         shift and go to state 109

    salto                          shift and go to state 110

state 83

    (8) while -> WHILE logical code . END
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    END             shift and go to state 111
    IF              shift and go to state 4
    WHILE           shift and go to state 13
    BEGIN           shift and go to state 10
    FOR             shift and go to state 22
    NUMBER          shift and go to state 21
    STRING          shift and go to state 8
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

    assign                         shift and go to state 1
    for                            shift and go to state 6
    sterm                          shift and go to state 12
    slice                          shift and go to state 2
    index                          shift and go to state 3
    expr                           shift and go to state 19
    variable                       shift and go to state 15
    code                           shift and go to state 41
    term                           shift and go to state 7
    expresiones                    shift and go to state 20
    math                           shift and go to state 23
    while                          shift and go to state 17
    if                             shift and go to state 5

state 84

    (9) while -> WHILE logical DO . salto code salto END
    (68) salto -> . NEWLINE

    NEWLINE         shift and go to state 109

    salto                          shift and go to state 112

state 85

    (50) expr -> sterm .
    (54) sexpr -> sterm . MUL term
    (55) sexpr -> sterm . ADD sexpr

    IF              reduce using rule 50 (expr -> sterm .)
    WHILE           reduce using rule 50 (expr -> sterm .)
    BEGIN           reduce using rule 50 (expr -> sterm .)
    FOR             reduce using rule 50 (expr -> sterm .)
    NUMBER          reduce using rule 50 (expr -> sterm .)
    STRING          reduce using rule 50 (expr -> sterm .)
    LOCAL           reduce using rule 50 (expr -> sterm .)
    GLOBAL          reduce using rule 50 (expr -> sterm .)
    CONSTANTS       reduce using rule 50 (expr -> sterm .)
    INSTANCEVAR     reduce using rule 50 (expr -> sterm .)
    CLASSVAR        reduce using rule 50 (expr -> sterm .)
    $end            reduce using rule 50 (expr -> sterm .)
    END             reduce using rule 50 (expr -> sterm .)
    ELSE            reduce using rule 50 (expr -> sterm .)
    ELSIF           reduce using rule 50 (expr -> sterm .)
    NEWLINE         reduce using rule 50 (expr -> sterm .)
    MUL             shift and go to state 114
    ADD             shift and go to state 113


state 86

    (30) assign -> variable ASS expr .

    IF              reduce using rule 30 (assign -> variable ASS expr .)
    WHILE           reduce using rule 30 (assign -> variable ASS expr .)
    BEGIN           reduce using rule 30 (assign -> variable ASS expr .)
    FOR             reduce using rule 30 (assign -> variable ASS expr .)
    NUMBER          reduce using rule 30 (assign -> variable ASS expr .)
    STRING          reduce using rule 30 (assign -> variable ASS expr .)
    LOCAL           reduce using rule 30 (assign -> variable ASS expr .)
    GLOBAL          reduce using rule 30 (assign -> variable ASS expr .)
    CONSTANTS       reduce using rule 30 (assign -> variable ASS expr .)
    INSTANCEVAR     reduce using rule 30 (assign -> variable ASS expr .)
    CLASSVAR        reduce using rule 30 (assign -> variable ASS expr .)
    END             reduce using rule 30 (assign -> variable ASS expr .)
    ELSE            reduce using rule 30 (assign -> variable ASS expr .)
    ELSIF           reduce using rule 30 (assign -> variable ASS expr .)
    $end            reduce using rule 30 (assign -> variable ASS expr .)
    NEWLINE         reduce using rule 30 (assign -> variable ASS expr .)


state 87

    (31) assign -> variable ASS sexpr .

    IF              reduce using rule 31 (assign -> variable ASS sexpr .)
    WHILE           reduce using rule 31 (assign -> variable ASS sexpr .)
    BEGIN           reduce using rule 31 (assign -> variable ASS sexpr .)
    FOR             reduce using rule 31 (assign -> variable ASS sexpr .)
    NUMBER          reduce using rule 31 (assign -> variable ASS sexpr .)
    STRING          reduce using rule 31 (assign -> variable ASS sexpr .)
    LOCAL           reduce using rule 31 (assign -> variable ASS sexpr .)
    GLOBAL          reduce using rule 31 (assign -> variable ASS sexpr .)
    CONSTANTS       reduce using rule 31 (assign -> variable ASS sexpr .)
    INSTANCEVAR     reduce using rule 31 (assign -> variable ASS sexpr .)
    CLASSVAR        reduce using rule 31 (assign -> variable ASS sexpr .)
    END             reduce using rule 31 (assign -> variable ASS sexpr .)
    ELSE            reduce using rule 31 (assign -> variable ASS sexpr .)
    ELSIF           reduce using rule 31 (assign -> variable ASS sexpr .)
    $end            reduce using rule 31 (assign -> variable ASS sexpr .)
    NEWLINE         reduce using rule 31 (assign -> variable ASS sexpr .)


state 88

    (32) assign -> variable ASS array .

    IF              reduce using rule 32 (assign -> variable ASS array .)
    WHILE           reduce using rule 32 (assign -> variable ASS array .)
    BEGIN           reduce using rule 32 (assign -> variable ASS array .)
    FOR             reduce using rule 32 (assign -> variable ASS array .)
    NUMBER          reduce using rule 32 (assign -> variable ASS array .)
    STRING          reduce using rule 32 (assign -> variable ASS array .)
    LOCAL           reduce using rule 32 (assign -> variable ASS array .)
    GLOBAL          reduce using rule 32 (assign -> variable ASS array .)
    CONSTANTS       reduce using rule 32 (assign -> variable ASS array .)
    INSTANCEVAR     reduce using rule 32 (assign -> variable ASS array .)
    CLASSVAR        reduce using rule 32 (assign -> variable ASS array .)
    END             reduce using rule 32 (assign -> variable ASS array .)
    ELSE            reduce using rule 32 (assign -> variable ASS array .)
    ELSIF           reduce using rule 32 (assign -> variable ASS array .)
    $end            reduce using rule 32 (assign -> variable ASS array .)
    NEWLINE         reduce using rule 32 (assign -> variable ASS array .)


state 89

    (84) array -> LBRACK . defarray RBRACK
    (85) defarray -> . NUMBER
    (86) defarray -> . NUMBER COMA defarray
    (87) defarray -> . STRING
    (88) defarray -> . STRING COMA defarray
    (89) defarray -> . INT
    (90) defarray -> . INT COMA defarray
    (91) defarray -> . FLOAT
    (92) defarray -> . FLOAT COMA defarray
    (93) defarray -> . BOOLEAN
    (94) defarray -> . BOOLEAN COMA defarray

    NUMBER          shift and go to state 120
    STRING          shift and go to state 118
    INT             shift and go to state 116
    FLOAT           shift and go to state 119
    BOOLEAN         shift and go to state 115

    defarray                       shift and go to state 117

state 90

    (35) math -> variable asig term .

    END             reduce using rule 35 (math -> variable asig term .)
    IF              reduce using rule 35 (math -> variable asig term .)
    WHILE           reduce using rule 35 (math -> variable asig term .)
    BEGIN           reduce using rule 35 (math -> variable asig term .)
    FOR             reduce using rule 35 (math -> variable asig term .)
    NUMBER          reduce using rule 35 (math -> variable asig term .)
    STRING          reduce using rule 35 (math -> variable asig term .)
    LOCAL           reduce using rule 35 (math -> variable asig term .)
    GLOBAL          reduce using rule 35 (math -> variable asig term .)
    CONSTANTS       reduce using rule 35 (math -> variable asig term .)
    INSTANCEVAR     reduce using rule 35 (math -> variable asig term .)
    CLASSVAR        reduce using rule 35 (math -> variable asig term .)
    ELSE            reduce using rule 35 (math -> variable asig term .)
    ELSIF           reduce using rule 35 (math -> variable asig term .)
    $end            reduce using rule 35 (math -> variable asig term .)
    NEWLINE         reduce using rule 35 (math -> variable asig term .)


state 91

    (96) slice -> variable LBRACK defslice . RBRACK

    RBRACK          shift and go to state 121


state 92

    (95) index -> variable LBRACK INT . RBRACK
    (97) defslice -> INT . DOBLEPOINT INT
    (98) defslice -> INT . DOBLEPOINT

    RBRACK          shift and go to state 123
    DOBLEPOINT      shift and go to state 122


state 93

    (99) defslice -> DOBLEPOINT . INT

    INT             shift and go to state 124


state 94

    (82) iterador -> variable COMA . variable
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR

    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

    variable                       shift and go to state 125

state 95

    (64) for -> FOR iterador IN . expresiones code END
    (65) for -> FOR iterador IN . expresiones DO code END
    (66) for -> FOR iterador IN . array code END
    (67) for -> FOR iterador IN . array DO code END
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (84) array -> . LBRACK defarray RBRACK
    (56) term -> . NUMBER

    LBRACK          shift and go to state 89
    NUMBER          shift and go to state 21

    term                           shift and go to state 126
    expresiones                    shift and go to state 127
    array                          shift and go to state 128

state 96

    (12) logical -> term comparison term .
    (12) logical -> term . comparison term
    (13) logical -> term . comparison logical
    (18) comparison -> . EQUAL
    (19) comparison -> . NOTEQ
    (20) comparison -> . GREATHER
    (21) comparison -> . LOWER
    (22) comparison -> . GREATHEREQ
    (23) comparison -> . LOWEREQ

    ANDLOG          reduce using rule 12 (logical -> term comparison term .)
    ORLOG           reduce using rule 12 (logical -> term comparison term .)
    NOTLOG          reduce using rule 12 (logical -> term comparison term .)
    AND             reduce using rule 12 (logical -> term comparison term .)
    OR              reduce using rule 12 (logical -> term comparison term .)
    NOT             reduce using rule 12 (logical -> term comparison term .)
    THEN            reduce using rule 12 (logical -> term comparison term .)
    NUMBER          reduce using rule 12 (logical -> term comparison term .)
    STRING          reduce using rule 12 (logical -> term comparison term .)
    LOCAL           reduce using rule 12 (logical -> term comparison term .)
    GLOBAL          reduce using rule 12 (logical -> term comparison term .)
    CONSTANTS       reduce using rule 12 (logical -> term comparison term .)
    INSTANCEVAR     reduce using rule 12 (logical -> term comparison term .)
    CLASSVAR        reduce using rule 12 (logical -> term comparison term .)
    ELSE            reduce using rule 12 (logical -> term comparison term .)
    ELSIF           reduce using rule 12 (logical -> term comparison term .)
    IF              reduce using rule 12 (logical -> term comparison term .)
    WHILE           reduce using rule 12 (logical -> term comparison term .)
    BEGIN           reduce using rule 12 (logical -> term comparison term .)
    FOR             reduce using rule 12 (logical -> term comparison term .)
    $end            reduce using rule 12 (logical -> term comparison term .)
    END             reduce using rule 12 (logical -> term comparison term .)
    NEWLINE         reduce using rule 12 (logical -> term comparison term .)
    DO              reduce using rule 12 (logical -> term comparison term .)
    DOBLEPOINT      reduce using rule 12 (logical -> term comparison term .)
    EQUAL           shift and go to state 56
    NOTEQ           shift and go to state 59
    GREATHER        shift and go to state 57
    LOWER           shift and go to state 58
    GREATHEREQ      shift and go to state 61
    LOWEREQ         shift and go to state 60

    comparison                     shift and go to state 55

state 97

    (13) logical -> term comparison logical .
    (16) logical -> logical . logcompare logical
    (24) logcompare -> . ANDLOG
    (25) logcompare -> . ORLOG
    (26) logcompare -> . NOTLOG
    (27) logcompare -> . AND
    (28) logcompare -> . OR
    (29) logcompare -> . NOT

  ! shift/reduce conflict for ANDLOG resolved as shift
  ! shift/reduce conflict for ORLOG resolved as shift
  ! shift/reduce conflict for NOTLOG resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    THEN            reduce using rule 13 (logical -> term comparison logical .)
    NUMBER          reduce using rule 13 (logical -> term comparison logical .)
    STRING          reduce using rule 13 (logical -> term comparison logical .)
    LOCAL           reduce using rule 13 (logical -> term comparison logical .)
    GLOBAL          reduce using rule 13 (logical -> term comparison logical .)
    CONSTANTS       reduce using rule 13 (logical -> term comparison logical .)
    INSTANCEVAR     reduce using rule 13 (logical -> term comparison logical .)
    CLASSVAR        reduce using rule 13 (logical -> term comparison logical .)
    ELSE            reduce using rule 13 (logical -> term comparison logical .)
    ELSIF           reduce using rule 13 (logical -> term comparison logical .)
    IF              reduce using rule 13 (logical -> term comparison logical .)
    WHILE           reduce using rule 13 (logical -> term comparison logical .)
    BEGIN           reduce using rule 13 (logical -> term comparison logical .)
    FOR             reduce using rule 13 (logical -> term comparison logical .)
    $end            reduce using rule 13 (logical -> term comparison logical .)
    END             reduce using rule 13 (logical -> term comparison logical .)
    NEWLINE         reduce using rule 13 (logical -> term comparison logical .)
    DO              reduce using rule 13 (logical -> term comparison logical .)
    DOBLEPOINT      reduce using rule 13 (logical -> term comparison logical .)
    ANDLOG          shift and go to state 67
    ORLOG           shift and go to state 62
    NOTLOG          shift and go to state 72
    AND             shift and go to state 70
    OR              shift and go to state 65
    NOT             shift and go to state 68

  ! ANDLOG          [ reduce using rule 13 (logical -> term comparison logical .) ]
  ! ORLOG           [ reduce using rule 13 (logical -> term comparison logical .) ]
  ! NOTLOG          [ reduce using rule 13 (logical -> term comparison logical .) ]
  ! AND             [ reduce using rule 13 (logical -> term comparison logical .) ]
  ! OR              [ reduce using rule 13 (logical -> term comparison logical .) ]
  ! NOT             [ reduce using rule 13 (logical -> term comparison logical .) ]

    logcompare                     shift and go to state 71

state 98

    (70) if -> IF logical THEN expr . END

    END             shift and go to state 129


state 99

    (41) asig -> ASS .

    NUMBER          reduce using rule 41 (asig -> ASS .)


state 100

    (69) if -> IF logical expr END .

    ELSE            reduce using rule 69 (if -> IF logical expr END .)
    ELSIF           reduce using rule 69 (if -> IF logical expr END .)
    END             reduce using rule 69 (if -> IF logical expr END .)
    IF              reduce using rule 69 (if -> IF logical expr END .)
    WHILE           reduce using rule 69 (if -> IF logical expr END .)
    BEGIN           reduce using rule 69 (if -> IF logical expr END .)
    FOR             reduce using rule 69 (if -> IF logical expr END .)
    NUMBER          reduce using rule 69 (if -> IF logical expr END .)
    STRING          reduce using rule 69 (if -> IF logical expr END .)
    LOCAL           reduce using rule 69 (if -> IF logical expr END .)
    GLOBAL          reduce using rule 69 (if -> IF logical expr END .)
    CONSTANTS       reduce using rule 69 (if -> IF logical expr END .)
    INSTANCEVAR     reduce using rule 69 (if -> IF logical expr END .)
    CLASSVAR        reduce using rule 69 (if -> IF logical expr END .)
    $end            reduce using rule 69 (if -> IF logical expr END .)
    NEWLINE         reduce using rule 69 (if -> IF logical expr END .)


state 101

    (16) logical -> logical logcompare logical .
    (16) logical -> logical . logcompare logical
    (24) logcompare -> . ANDLOG
    (25) logcompare -> . ORLOG
    (26) logcompare -> . NOTLOG
    (27) logcompare -> . AND
    (28) logcompare -> . OR
    (29) logcompare -> . NOT

  ! shift/reduce conflict for ANDLOG resolved as shift
  ! shift/reduce conflict for ORLOG resolved as shift
  ! shift/reduce conflict for NOTLOG resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    THEN            reduce using rule 16 (logical -> logical logcompare logical .)
    NUMBER          reduce using rule 16 (logical -> logical logcompare logical .)
    STRING          reduce using rule 16 (logical -> logical logcompare logical .)
    LOCAL           reduce using rule 16 (logical -> logical logcompare logical .)
    GLOBAL          reduce using rule 16 (logical -> logical logcompare logical .)
    CONSTANTS       reduce using rule 16 (logical -> logical logcompare logical .)
    INSTANCEVAR     reduce using rule 16 (logical -> logical logcompare logical .)
    CLASSVAR        reduce using rule 16 (logical -> logical logcompare logical .)
    ELSE            reduce using rule 16 (logical -> logical logcompare logical .)
    ELSIF           reduce using rule 16 (logical -> logical logcompare logical .)
    IF              reduce using rule 16 (logical -> logical logcompare logical .)
    WHILE           reduce using rule 16 (logical -> logical logcompare logical .)
    BEGIN           reduce using rule 16 (logical -> logical logcompare logical .)
    FOR             reduce using rule 16 (logical -> logical logcompare logical .)
    $end            reduce using rule 16 (logical -> logical logcompare logical .)
    END             reduce using rule 16 (logical -> logical logcompare logical .)
    NEWLINE         reduce using rule 16 (logical -> logical logcompare logical .)
    DO              reduce using rule 16 (logical -> logical logcompare logical .)
    DOBLEPOINT      reduce using rule 16 (logical -> logical logcompare logical .)
    ANDLOG          shift and go to state 67
    ORLOG           shift and go to state 62
    NOTLOG          shift and go to state 72
    AND             shift and go to state 70
    OR              shift and go to state 65
    NOT             shift and go to state 68

  ! ANDLOG          [ reduce using rule 16 (logical -> logical logcompare logical .) ]
  ! ORLOG           [ reduce using rule 16 (logical -> logical logcompare logical .) ]
  ! NOTLOG          [ reduce using rule 16 (logical -> logical logcompare logical .) ]
  ! AND             [ reduce using rule 16 (logical -> logical logcompare logical .) ]
  ! OR              [ reduce using rule 16 (logical -> logical logcompare logical .) ]
  ! NOT             [ reduce using rule 16 (logical -> logical logcompare logical .) ]

    logcompare                     shift and go to state 71

state 102

    (14) logical -> variable comparison term .

    ANDLOG          reduce using rule 14 (logical -> variable comparison term .)
    ORLOG           reduce using rule 14 (logical -> variable comparison term .)
    NOTLOG          reduce using rule 14 (logical -> variable comparison term .)
    AND             reduce using rule 14 (logical -> variable comparison term .)
    OR              reduce using rule 14 (logical -> variable comparison term .)
    NOT             reduce using rule 14 (logical -> variable comparison term .)
    THEN            reduce using rule 14 (logical -> variable comparison term .)
    NUMBER          reduce using rule 14 (logical -> variable comparison term .)
    STRING          reduce using rule 14 (logical -> variable comparison term .)
    LOCAL           reduce using rule 14 (logical -> variable comparison term .)
    GLOBAL          reduce using rule 14 (logical -> variable comparison term .)
    CONSTANTS       reduce using rule 14 (logical -> variable comparison term .)
    INSTANCEVAR     reduce using rule 14 (logical -> variable comparison term .)
    CLASSVAR        reduce using rule 14 (logical -> variable comparison term .)
    ELSE            reduce using rule 14 (logical -> variable comparison term .)
    ELSIF           reduce using rule 14 (logical -> variable comparison term .)
    IF              reduce using rule 14 (logical -> variable comparison term .)
    WHILE           reduce using rule 14 (logical -> variable comparison term .)
    BEGIN           reduce using rule 14 (logical -> variable comparison term .)
    FOR             reduce using rule 14 (logical -> variable comparison term .)
    $end            reduce using rule 14 (logical -> variable comparison term .)
    END             reduce using rule 14 (logical -> variable comparison term .)
    NEWLINE         reduce using rule 14 (logical -> variable comparison term .)
    DO              reduce using rule 14 (logical -> variable comparison term .)
    DOBLEPOINT      reduce using rule 14 (logical -> variable comparison term .)


state 103

    (15) logical -> variable comparison BOOLEAN .

    ANDLOG          reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    ORLOG           reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    NOTLOG          reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    AND             reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    OR              reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    NOT             reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    THEN            reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    NUMBER          reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    STRING          reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    LOCAL           reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    GLOBAL          reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    CONSTANTS       reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    INSTANCEVAR     reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    CLASSVAR        reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    ELSE            reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    ELSIF           reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    IF              reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    WHILE           reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    BEGIN           reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    FOR             reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    $end            reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    END             reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    NEWLINE         reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    DO              reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    DOBLEPOINT      reduce using rule 15 (logical -> variable comparison BOOLEAN .)


state 104

    (75) else -> ELSE code END .

    ELSE            reduce using rule 75 (else -> ELSE code END .)
    ELSIF           reduce using rule 75 (else -> ELSE code END .)
    IF              reduce using rule 75 (else -> ELSE code END .)
    WHILE           reduce using rule 75 (else -> ELSE code END .)
    BEGIN           reduce using rule 75 (else -> ELSE code END .)
    FOR             reduce using rule 75 (else -> ELSE code END .)
    NUMBER          reduce using rule 75 (else -> ELSE code END .)
    STRING          reduce using rule 75 (else -> ELSE code END .)
    LOCAL           reduce using rule 75 (else -> ELSE code END .)
    GLOBAL          reduce using rule 75 (else -> ELSE code END .)
    CONSTANTS       reduce using rule 75 (else -> ELSE code END .)
    INSTANCEVAR     reduce using rule 75 (else -> ELSE code END .)
    CLASSVAR        reduce using rule 75 (else -> ELSE code END .)
    $end            reduce using rule 75 (else -> ELSE code END .)
    END             reduce using rule 75 (else -> ELSE code END .)
    NEWLINE         reduce using rule 75 (else -> ELSE code END .)


state 105

    (78) final -> THEN . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 4
    WHILE           shift and go to state 13
    BEGIN           shift and go to state 10
    FOR             shift and go to state 22
    NUMBER          shift and go to state 21
    STRING          shift and go to state 8
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

    assign                         shift and go to state 1
    for                            shift and go to state 6
    sterm                          shift and go to state 12
    slice                          shift and go to state 2
    index                          shift and go to state 3
    variable                       shift and go to state 15
    code                           shift and go to state 130
    term                           shift and go to state 7
    expr                           shift and go to state 19
    expresiones                    shift and go to state 20
    math                           shift and go to state 23
    while                          shift and go to state 17
    if                             shift and go to state 5

state 106

    (77) final -> code .
    (79) final -> code . else
    (80) final -> code . elsif
    (7) code -> code . code
    (75) else -> . ELSE code END
    (76) elsif -> . ELSIF logical final
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    END             reduce using rule 77 (final -> code .)
    ELSE            shift and go to state 29
    ELSIF           shift and go to state 32
    IF              shift and go to state 4
    WHILE           shift and go to state 13
    BEGIN           shift and go to state 10
    FOR             shift and go to state 22
    NUMBER          shift and go to state 21
    STRING          shift and go to state 8
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

    index                          shift and go to state 3
    assign                         shift and go to state 1
    sterm                          shift and go to state 12
    slice                          shift and go to state 2
    variable                       shift and go to state 15
    expr                           shift and go to state 19
    if                             shift and go to state 5
    elsif                          shift and go to state 131
    code                           shift and go to state 41
    term                           shift and go to state 7
    expresiones                    shift and go to state 20
    math                           shift and go to state 23
    else                           shift and go to state 132
    for                            shift and go to state 6
    while                          shift and go to state 17

state 107

    (76) elsif -> ELSIF logical final .

    END             reduce using rule 76 (elsif -> ELSIF logical final .)


state 108

    (11) while -> BEGIN code END WHILE . logical
    (12) logical -> . term comparison term
    (13) logical -> . term comparison logical
    (14) logical -> . variable comparison term
    (15) logical -> . variable comparison BOOLEAN
    (16) logical -> . logical logcompare logical
    (17) logical -> . BOOLEAN
    (56) term -> . NUMBER
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR

    BOOLEAN         shift and go to state 26
    NUMBER          shift and go to state 21
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

    logical                        shift and go to state 133
    term                           shift and go to state 25
    variable                       shift and go to state 28

state 109

    (68) salto -> NEWLINE .

    END             reduce using rule 68 (salto -> NEWLINE .)
    IF              reduce using rule 68 (salto -> NEWLINE .)
    WHILE           reduce using rule 68 (salto -> NEWLINE .)
    BEGIN           reduce using rule 68 (salto -> NEWLINE .)
    FOR             reduce using rule 68 (salto -> NEWLINE .)
    NUMBER          reduce using rule 68 (salto -> NEWLINE .)
    STRING          reduce using rule 68 (salto -> NEWLINE .)
    LOCAL           reduce using rule 68 (salto -> NEWLINE .)
    GLOBAL          reduce using rule 68 (salto -> NEWLINE .)
    CONSTANTS       reduce using rule 68 (salto -> NEWLINE .)
    INSTANCEVAR     reduce using rule 68 (salto -> NEWLINE .)
    CLASSVAR        reduce using rule 68 (salto -> NEWLINE .)


state 110

    (10) while -> WHILE logical DOBLEPOINT salto . code salto END
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 4
    WHILE           shift and go to state 13
    BEGIN           shift and go to state 10
    FOR             shift and go to state 22
    NUMBER          shift and go to state 21
    STRING          shift and go to state 8
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

    assign                         shift and go to state 1
    for                            shift and go to state 6
    sterm                          shift and go to state 12
    slice                          shift and go to state 2
    index                          shift and go to state 3
    expr                           shift and go to state 19
    variable                       shift and go to state 15
    code                           shift and go to state 134
    term                           shift and go to state 7
    expresiones                    shift and go to state 20
    math                           shift and go to state 23
    while                          shift and go to state 17
    if                             shift and go to state 5

state 111

    (8) while -> WHILE logical code END .

    IF              reduce using rule 8 (while -> WHILE logical code END .)
    WHILE           reduce using rule 8 (while -> WHILE logical code END .)
    BEGIN           reduce using rule 8 (while -> WHILE logical code END .)
    FOR             reduce using rule 8 (while -> WHILE logical code END .)
    NUMBER          reduce using rule 8 (while -> WHILE logical code END .)
    STRING          reduce using rule 8 (while -> WHILE logical code END .)
    LOCAL           reduce using rule 8 (while -> WHILE logical code END .)
    GLOBAL          reduce using rule 8 (while -> WHILE logical code END .)
    CONSTANTS       reduce using rule 8 (while -> WHILE logical code END .)
    INSTANCEVAR     reduce using rule 8 (while -> WHILE logical code END .)
    CLASSVAR        reduce using rule 8 (while -> WHILE logical code END .)
    NEWLINE         reduce using rule 8 (while -> WHILE logical code END .)
    $end            reduce using rule 8 (while -> WHILE logical code END .)
    END             reduce using rule 8 (while -> WHILE logical code END .)
    ELSE            reduce using rule 8 (while -> WHILE logical code END .)
    ELSIF           reduce using rule 8 (while -> WHILE logical code END .)


state 112

    (9) while -> WHILE logical DO salto . code salto END
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 4
    WHILE           shift and go to state 13
    BEGIN           shift and go to state 10
    FOR             shift and go to state 22
    NUMBER          shift and go to state 21
    STRING          shift and go to state 8
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

    assign                         shift and go to state 1
    for                            shift and go to state 6
    sterm                          shift and go to state 12
    slice                          shift and go to state 2
    index                          shift and go to state 3
    expr                           shift and go to state 19
    variable                       shift and go to state 15
    code                           shift and go to state 135
    term                           shift and go to state 7
    expresiones                    shift and go to state 20
    math                           shift and go to state 23
    while                          shift and go to state 17
    if                             shift and go to state 5

state 113

    (55) sexpr -> sterm ADD . sexpr
    (54) sexpr -> . sterm MUL term
    (55) sexpr -> . sterm ADD sexpr
    (57) sterm -> . STRING

    STRING          shift and go to state 8

    sexpr                          shift and go to state 136
    sterm                          shift and go to state 137

state 114

    (54) sexpr -> sterm MUL . term
    (56) term -> . NUMBER

    NUMBER          shift and go to state 21

    term                           shift and go to state 138

state 115

    (93) defarray -> BOOLEAN .
    (94) defarray -> BOOLEAN . COMA defarray

    RBRACK          reduce using rule 93 (defarray -> BOOLEAN .)
    COMA            shift and go to state 139


state 116

    (89) defarray -> INT .
    (90) defarray -> INT . COMA defarray

    RBRACK          reduce using rule 89 (defarray -> INT .)
    COMA            shift and go to state 140


state 117

    (84) array -> LBRACK defarray . RBRACK

    RBRACK          shift and go to state 141


state 118

    (87) defarray -> STRING .
    (88) defarray -> STRING . COMA defarray

    RBRACK          reduce using rule 87 (defarray -> STRING .)
    COMA            shift and go to state 142


state 119

    (91) defarray -> FLOAT .
    (92) defarray -> FLOAT . COMA defarray

    RBRACK          reduce using rule 91 (defarray -> FLOAT .)
    COMA            shift and go to state 143


state 120

    (85) defarray -> NUMBER .
    (86) defarray -> NUMBER . COMA defarray

    RBRACK          reduce using rule 85 (defarray -> NUMBER .)
    COMA            shift and go to state 144


state 121

    (96) slice -> variable LBRACK defslice RBRACK .

    IF              reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    WHILE           reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    BEGIN           reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    FOR             reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    NUMBER          reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    STRING          reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    LOCAL           reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    GLOBAL          reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    CONSTANTS       reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    INSTANCEVAR     reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    CLASSVAR        reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    END             reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    ELSE            reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    ELSIF           reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    $end            reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    NEWLINE         reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)


state 122

    (97) defslice -> INT DOBLEPOINT . INT
    (98) defslice -> INT DOBLEPOINT .

    INT             shift and go to state 145
    RBRACK          reduce using rule 98 (defslice -> INT DOBLEPOINT .)


state 123

    (95) index -> variable LBRACK INT RBRACK .

    IF              reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    WHILE           reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    BEGIN           reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    FOR             reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    NUMBER          reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    STRING          reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    LOCAL           reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    GLOBAL          reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    CONSTANTS       reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    INSTANCEVAR     reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    CLASSVAR        reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    END             reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    ELSE            reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    ELSIF           reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    NEWLINE         reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    $end            reduce using rule 95 (index -> variable LBRACK INT RBRACK .)


state 124

    (99) defslice -> DOBLEPOINT INT .

    RBRACK          reduce using rule 99 (defslice -> DOBLEPOINT INT .)


state 125

    (82) iterador -> variable COMA variable .

    IN              reduce using rule 82 (iterador -> variable COMA variable .)


state 126

    (83) expresiones -> term . DOUBLESECUENCEPOINT term

    DOUBLESECUENCEPOINT shift and go to state 36


state 127

    (64) for -> FOR iterador IN expresiones . code END
    (65) for -> FOR iterador IN expresiones . DO code END
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    DO              shift and go to state 147
    IF              shift and go to state 4
    WHILE           shift and go to state 13
    BEGIN           shift and go to state 10
    FOR             shift and go to state 22
    NUMBER          shift and go to state 21
    STRING          shift and go to state 8
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

    assign                         shift and go to state 1
    for                            shift and go to state 6
    sterm                          shift and go to state 12
    slice                          shift and go to state 2
    index                          shift and go to state 3
    variable                       shift and go to state 15
    code                           shift and go to state 146
    term                           shift and go to state 7
    expr                           shift and go to state 19
    expresiones                    shift and go to state 20
    math                           shift and go to state 23
    while                          shift and go to state 17
    if                             shift and go to state 5

state 128

    (66) for -> FOR iterador IN array . code END
    (67) for -> FOR iterador IN array . DO code END
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    DO              shift and go to state 149
    IF              shift and go to state 4
    WHILE           shift and go to state 13
    BEGIN           shift and go to state 10
    FOR             shift and go to state 22
    NUMBER          shift and go to state 21
    STRING          shift and go to state 8
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

    assign                         shift and go to state 1
    for                            shift and go to state 6
    sterm                          shift and go to state 12
    slice                          shift and go to state 2
    index                          shift and go to state 3
    variable                       shift and go to state 15
    code                           shift and go to state 148
    term                           shift and go to state 7
    expr                           shift and go to state 19
    expresiones                    shift and go to state 20
    math                           shift and go to state 23
    while                          shift and go to state 17
    if                             shift and go to state 5

state 129

    (70) if -> IF logical THEN expr END .

    ELSE            reduce using rule 70 (if -> IF logical THEN expr END .)
    ELSIF           reduce using rule 70 (if -> IF logical THEN expr END .)
    END             reduce using rule 70 (if -> IF logical THEN expr END .)
    IF              reduce using rule 70 (if -> IF logical THEN expr END .)
    WHILE           reduce using rule 70 (if -> IF logical THEN expr END .)
    BEGIN           reduce using rule 70 (if -> IF logical THEN expr END .)
    FOR             reduce using rule 70 (if -> IF logical THEN expr END .)
    NUMBER          reduce using rule 70 (if -> IF logical THEN expr END .)
    STRING          reduce using rule 70 (if -> IF logical THEN expr END .)
    LOCAL           reduce using rule 70 (if -> IF logical THEN expr END .)
    GLOBAL          reduce using rule 70 (if -> IF logical THEN expr END .)
    CONSTANTS       reduce using rule 70 (if -> IF logical THEN expr END .)
    INSTANCEVAR     reduce using rule 70 (if -> IF logical THEN expr END .)
    CLASSVAR        reduce using rule 70 (if -> IF logical THEN expr END .)
    $end            reduce using rule 70 (if -> IF logical THEN expr END .)
    NEWLINE         reduce using rule 70 (if -> IF logical THEN expr END .)


state 130

    (78) final -> THEN code .
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    END             reduce using rule 78 (final -> THEN code .)
    IF              shift and go to state 4
    WHILE           shift and go to state 13
    BEGIN           shift and go to state 10
    FOR             shift and go to state 22
    NUMBER          shift and go to state 21
    STRING          shift and go to state 8
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

    assign                         shift and go to state 1
    for                            shift and go to state 6
    sterm                          shift and go to state 12
    slice                          shift and go to state 2
    index                          shift and go to state 3
    variable                       shift and go to state 15
    code                           shift and go to state 41
    term                           shift and go to state 7
    expr                           shift and go to state 19
    expresiones                    shift and go to state 20
    math                           shift and go to state 23
    while                          shift and go to state 17
    if                             shift and go to state 5

state 131

    (80) final -> code elsif .

    END             reduce using rule 80 (final -> code elsif .)


state 132

    (79) final -> code else .

    END             reduce using rule 79 (final -> code else .)


state 133

    (11) while -> BEGIN code END WHILE logical .
    (16) logical -> logical . logcompare logical
    (24) logcompare -> . ANDLOG
    (25) logcompare -> . ORLOG
    (26) logcompare -> . NOTLOG
    (27) logcompare -> . AND
    (28) logcompare -> . OR
    (29) logcompare -> . NOT

    IF              reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    WHILE           reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    BEGIN           reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    FOR             reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    NUMBER          reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    STRING          reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    LOCAL           reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    GLOBAL          reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    CONSTANTS       reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    INSTANCEVAR     reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    CLASSVAR        reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    NEWLINE         reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    $end            reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    END             reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    ELSE            reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    ELSIF           reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    ANDLOG          shift and go to state 67
    ORLOG           shift and go to state 62
    NOTLOG          shift and go to state 72
    AND             shift and go to state 70
    OR              shift and go to state 65
    NOT             shift and go to state 68

    logcompare                     shift and go to state 71

state 134

    (10) while -> WHILE logical DOBLEPOINT salto code . salto END
    (7) code -> code . code
    (68) salto -> . NEWLINE
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    NEWLINE         shift and go to state 109
    IF              shift and go to state 4
    WHILE           shift and go to state 13
    BEGIN           shift and go to state 10
    FOR             shift and go to state 22
    NUMBER          shift and go to state 21
    STRING          shift and go to state 8
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

    assign                         shift and go to state 1
    for                            shift and go to state 6
    sterm                          shift and go to state 12
    slice                          shift and go to state 2
    index                          shift and go to state 3
    expr                           shift and go to state 19
    variable                       shift and go to state 15
    salto                          shift and go to state 150
    code                           shift and go to state 41
    term                           shift and go to state 7
    expresiones                    shift and go to state 20
    math                           shift and go to state 23
    while                          shift and go to state 17
    if                             shift and go to state 5

state 135

    (9) while -> WHILE logical DO salto code . salto END
    (7) code -> code . code
    (68) salto -> . NEWLINE
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    NEWLINE         shift and go to state 109
    IF              shift and go to state 4
    WHILE           shift and go to state 13
    BEGIN           shift and go to state 10
    FOR             shift and go to state 22
    NUMBER          shift and go to state 21
    STRING          shift and go to state 8
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

    assign                         shift and go to state 1
    for                            shift and go to state 6
    sterm                          shift and go to state 12
    slice                          shift and go to state 2
    index                          shift and go to state 3
    expr                           shift and go to state 19
    variable                       shift and go to state 15
    salto                          shift and go to state 151
    code                           shift and go to state 41
    term                           shift and go to state 7
    expresiones                    shift and go to state 20
    math                           shift and go to state 23
    while                          shift and go to state 17
    if                             shift and go to state 5

state 136

    (55) sexpr -> sterm ADD sexpr .

    IF              reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    WHILE           reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    BEGIN           reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    FOR             reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    NUMBER          reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    STRING          reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    LOCAL           reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    GLOBAL          reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    CONSTANTS       reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    INSTANCEVAR     reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    CLASSVAR        reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    $end            reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    END             reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    ELSE            reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    ELSIF           reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    NEWLINE         reduce using rule 55 (sexpr -> sterm ADD sexpr .)


state 137

    (54) sexpr -> sterm . MUL term
    (55) sexpr -> sterm . ADD sexpr

    MUL             shift and go to state 114
    ADD             shift and go to state 113


state 138

    (54) sexpr -> sterm MUL term .

    IF              reduce using rule 54 (sexpr -> sterm MUL term .)
    WHILE           reduce using rule 54 (sexpr -> sterm MUL term .)
    BEGIN           reduce using rule 54 (sexpr -> sterm MUL term .)
    FOR             reduce using rule 54 (sexpr -> sterm MUL term .)
    NUMBER          reduce using rule 54 (sexpr -> sterm MUL term .)
    STRING          reduce using rule 54 (sexpr -> sterm MUL term .)
    LOCAL           reduce using rule 54 (sexpr -> sterm MUL term .)
    GLOBAL          reduce using rule 54 (sexpr -> sterm MUL term .)
    CONSTANTS       reduce using rule 54 (sexpr -> sterm MUL term .)
    INSTANCEVAR     reduce using rule 54 (sexpr -> sterm MUL term .)
    CLASSVAR        reduce using rule 54 (sexpr -> sterm MUL term .)
    $end            reduce using rule 54 (sexpr -> sterm MUL term .)
    END             reduce using rule 54 (sexpr -> sterm MUL term .)
    ELSE            reduce using rule 54 (sexpr -> sterm MUL term .)
    ELSIF           reduce using rule 54 (sexpr -> sterm MUL term .)
    NEWLINE         reduce using rule 54 (sexpr -> sterm MUL term .)


state 139

    (94) defarray -> BOOLEAN COMA . defarray
    (85) defarray -> . NUMBER
    (86) defarray -> . NUMBER COMA defarray
    (87) defarray -> . STRING
    (88) defarray -> . STRING COMA defarray
    (89) defarray -> . INT
    (90) defarray -> . INT COMA defarray
    (91) defarray -> . FLOAT
    (92) defarray -> . FLOAT COMA defarray
    (93) defarray -> . BOOLEAN
    (94) defarray -> . BOOLEAN COMA defarray

    NUMBER          shift and go to state 120
    STRING          shift and go to state 118
    INT             shift and go to state 116
    FLOAT           shift and go to state 119
    BOOLEAN         shift and go to state 115

    defarray                       shift and go to state 152

state 140

    (90) defarray -> INT COMA . defarray
    (85) defarray -> . NUMBER
    (86) defarray -> . NUMBER COMA defarray
    (87) defarray -> . STRING
    (88) defarray -> . STRING COMA defarray
    (89) defarray -> . INT
    (90) defarray -> . INT COMA defarray
    (91) defarray -> . FLOAT
    (92) defarray -> . FLOAT COMA defarray
    (93) defarray -> . BOOLEAN
    (94) defarray -> . BOOLEAN COMA defarray

    NUMBER          shift and go to state 120
    STRING          shift and go to state 118
    INT             shift and go to state 116
    FLOAT           shift and go to state 119
    BOOLEAN         shift and go to state 115

    defarray                       shift and go to state 153

state 141

    (84) array -> LBRACK defarray RBRACK .

    DO              reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    IF              reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    WHILE           reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    BEGIN           reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    FOR             reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    NUMBER          reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    STRING          reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    LOCAL           reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    GLOBAL          reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    CONSTANTS       reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    INSTANCEVAR     reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    CLASSVAR        reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    $end            reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    END             reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    ELSE            reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    ELSIF           reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    NEWLINE         reduce using rule 84 (array -> LBRACK defarray RBRACK .)


state 142

    (88) defarray -> STRING COMA . defarray
    (85) defarray -> . NUMBER
    (86) defarray -> . NUMBER COMA defarray
    (87) defarray -> . STRING
    (88) defarray -> . STRING COMA defarray
    (89) defarray -> . INT
    (90) defarray -> . INT COMA defarray
    (91) defarray -> . FLOAT
    (92) defarray -> . FLOAT COMA defarray
    (93) defarray -> . BOOLEAN
    (94) defarray -> . BOOLEAN COMA defarray

    NUMBER          shift and go to state 120
    STRING          shift and go to state 118
    INT             shift and go to state 116
    FLOAT           shift and go to state 119
    BOOLEAN         shift and go to state 115

    defarray                       shift and go to state 154

state 143

    (92) defarray -> FLOAT COMA . defarray
    (85) defarray -> . NUMBER
    (86) defarray -> . NUMBER COMA defarray
    (87) defarray -> . STRING
    (88) defarray -> . STRING COMA defarray
    (89) defarray -> . INT
    (90) defarray -> . INT COMA defarray
    (91) defarray -> . FLOAT
    (92) defarray -> . FLOAT COMA defarray
    (93) defarray -> . BOOLEAN
    (94) defarray -> . BOOLEAN COMA defarray

    NUMBER          shift and go to state 120
    STRING          shift and go to state 118
    INT             shift and go to state 116
    FLOAT           shift and go to state 119
    BOOLEAN         shift and go to state 115

    defarray                       shift and go to state 155

state 144

    (86) defarray -> NUMBER COMA . defarray
    (85) defarray -> . NUMBER
    (86) defarray -> . NUMBER COMA defarray
    (87) defarray -> . STRING
    (88) defarray -> . STRING COMA defarray
    (89) defarray -> . INT
    (90) defarray -> . INT COMA defarray
    (91) defarray -> . FLOAT
    (92) defarray -> . FLOAT COMA defarray
    (93) defarray -> . BOOLEAN
    (94) defarray -> . BOOLEAN COMA defarray

    NUMBER          shift and go to state 120
    STRING          shift and go to state 118
    INT             shift and go to state 116
    FLOAT           shift and go to state 119
    BOOLEAN         shift and go to state 115

    defarray                       shift and go to state 156

state 145

    (97) defslice -> INT DOBLEPOINT INT .

    RBRACK          reduce using rule 97 (defslice -> INT DOBLEPOINT INT .)


state 146

    (64) for -> FOR iterador IN expresiones code . END
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    END             shift and go to state 157
    IF              shift and go to state 4
    WHILE           shift and go to state 13
    BEGIN           shift and go to state 10
    FOR             shift and go to state 22
    NUMBER          shift and go to state 21
    STRING          shift and go to state 8
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

    assign                         shift and go to state 1
    for                            shift and go to state 6
    sterm                          shift and go to state 12
    slice                          shift and go to state 2
    index                          shift and go to state 3
    variable                       shift and go to state 15
    code                           shift and go to state 41
    term                           shift and go to state 7
    expr                           shift and go to state 19
    expresiones                    shift and go to state 20
    math                           shift and go to state 23
    while                          shift and go to state 17
    if                             shift and go to state 5

state 147

    (65) for -> FOR iterador IN expresiones DO . code END
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 4
    WHILE           shift and go to state 13
    BEGIN           shift and go to state 10
    FOR             shift and go to state 22
    NUMBER          shift and go to state 21
    STRING          shift and go to state 8
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

    assign                         shift and go to state 1
    for                            shift and go to state 6
    sterm                          shift and go to state 12
    slice                          shift and go to state 2
    index                          shift and go to state 3
    variable                       shift and go to state 15
    code                           shift and go to state 158
    term                           shift and go to state 7
    expr                           shift and go to state 19
    expresiones                    shift and go to state 20
    math                           shift and go to state 23
    while                          shift and go to state 17
    if                             shift and go to state 5

state 148

    (66) for -> FOR iterador IN array code . END
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    END             shift and go to state 159
    IF              shift and go to state 4
    WHILE           shift and go to state 13
    BEGIN           shift and go to state 10
    FOR             shift and go to state 22
    NUMBER          shift and go to state 21
    STRING          shift and go to state 8
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

    assign                         shift and go to state 1
    for                            shift and go to state 6
    sterm                          shift and go to state 12
    slice                          shift and go to state 2
    index                          shift and go to state 3
    variable                       shift and go to state 15
    code                           shift and go to state 41
    term                           shift and go to state 7
    expr                           shift and go to state 19
    expresiones                    shift and go to state 20
    math                           shift and go to state 23
    while                          shift and go to state 17
    if                             shift and go to state 5

state 149

    (67) for -> FOR iterador IN array DO . code END
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 4
    WHILE           shift and go to state 13
    BEGIN           shift and go to state 10
    FOR             shift and go to state 22
    NUMBER          shift and go to state 21
    STRING          shift and go to state 8
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

    assign                         shift and go to state 1
    for                            shift and go to state 6
    sterm                          shift and go to state 12
    slice                          shift and go to state 2
    index                          shift and go to state 3
    variable                       shift and go to state 15
    code                           shift and go to state 160
    term                           shift and go to state 7
    expr                           shift and go to state 19
    expresiones                    shift and go to state 20
    math                           shift and go to state 23
    while                          shift and go to state 17
    if                             shift and go to state 5

state 150

    (10) while -> WHILE logical DOBLEPOINT salto code salto . END

    END             shift and go to state 161


state 151

    (9) while -> WHILE logical DO salto code salto . END

    END             shift and go to state 162


state 152

    (94) defarray -> BOOLEAN COMA defarray .

    RBRACK          reduce using rule 94 (defarray -> BOOLEAN COMA defarray .)


state 153

    (90) defarray -> INT COMA defarray .

    RBRACK          reduce using rule 90 (defarray -> INT COMA defarray .)


state 154

    (88) defarray -> STRING COMA defarray .

    RBRACK          reduce using rule 88 (defarray -> STRING COMA defarray .)


state 155

    (92) defarray -> FLOAT COMA defarray .

    RBRACK          reduce using rule 92 (defarray -> FLOAT COMA defarray .)


state 156

    (86) defarray -> NUMBER COMA defarray .

    RBRACK          reduce using rule 86 (defarray -> NUMBER COMA defarray .)


state 157

    (64) for -> FOR iterador IN expresiones code END .

    IF              reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    WHILE           reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    BEGIN           reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    FOR             reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    NUMBER          reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    STRING          reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    LOCAL           reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    GLOBAL          reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    CONSTANTS       reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    INSTANCEVAR     reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    CLASSVAR        reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    END             reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    ELSE            reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    ELSIF           reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    NEWLINE         reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    $end            reduce using rule 64 (for -> FOR iterador IN expresiones code END .)


state 158

    (65) for -> FOR iterador IN expresiones DO code . END
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    END             shift and go to state 163
    IF              shift and go to state 4
    WHILE           shift and go to state 13
    BEGIN           shift and go to state 10
    FOR             shift and go to state 22
    NUMBER          shift and go to state 21
    STRING          shift and go to state 8
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

    assign                         shift and go to state 1
    for                            shift and go to state 6
    sterm                          shift and go to state 12
    slice                          shift and go to state 2
    index                          shift and go to state 3
    variable                       shift and go to state 15
    code                           shift and go to state 41
    term                           shift and go to state 7
    expr                           shift and go to state 19
    expresiones                    shift and go to state 20
    math                           shift and go to state 23
    while                          shift and go to state 17
    if                             shift and go to state 5

state 159

    (66) for -> FOR iterador IN array code END .

    IF              reduce using rule 66 (for -> FOR iterador IN array code END .)
    WHILE           reduce using rule 66 (for -> FOR iterador IN array code END .)
    BEGIN           reduce using rule 66 (for -> FOR iterador IN array code END .)
    FOR             reduce using rule 66 (for -> FOR iterador IN array code END .)
    NUMBER          reduce using rule 66 (for -> FOR iterador IN array code END .)
    STRING          reduce using rule 66 (for -> FOR iterador IN array code END .)
    LOCAL           reduce using rule 66 (for -> FOR iterador IN array code END .)
    GLOBAL          reduce using rule 66 (for -> FOR iterador IN array code END .)
    CONSTANTS       reduce using rule 66 (for -> FOR iterador IN array code END .)
    INSTANCEVAR     reduce using rule 66 (for -> FOR iterador IN array code END .)
    CLASSVAR        reduce using rule 66 (for -> FOR iterador IN array code END .)
    END             reduce using rule 66 (for -> FOR iterador IN array code END .)
    ELSE            reduce using rule 66 (for -> FOR iterador IN array code END .)
    ELSIF           reduce using rule 66 (for -> FOR iterador IN array code END .)
    NEWLINE         reduce using rule 66 (for -> FOR iterador IN array code END .)
    $end            reduce using rule 66 (for -> FOR iterador IN array code END .)


state 160

    (67) for -> FOR iterador IN array DO code . END
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    END             shift and go to state 164
    IF              shift and go to state 4
    WHILE           shift and go to state 13
    BEGIN           shift and go to state 10
    FOR             shift and go to state 22
    NUMBER          shift and go to state 21
    STRING          shift and go to state 8
    LOCAL           shift and go to state 18
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 16
    INSTANCEVAR     shift and go to state 11
    CLASSVAR        shift and go to state 14

    assign                         shift and go to state 1
    for                            shift and go to state 6
    sterm                          shift and go to state 12
    slice                          shift and go to state 2
    index                          shift and go to state 3
    variable                       shift and go to state 15
    code                           shift and go to state 41
    term                           shift and go to state 7
    expr                           shift and go to state 19
    expresiones                    shift and go to state 20
    math                           shift and go to state 23
    while                          shift and go to state 17
    if                             shift and go to state 5

state 161

    (10) while -> WHILE logical DOBLEPOINT salto code salto END .

    IF              reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    WHILE           reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    BEGIN           reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    FOR             reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    NUMBER          reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    STRING          reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    LOCAL           reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    GLOBAL          reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    CONSTANTS       reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    INSTANCEVAR     reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    CLASSVAR        reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    NEWLINE         reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    $end            reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    END             reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    ELSE            reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    ELSIF           reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)


state 162

    (9) while -> WHILE logical DO salto code salto END .

    IF              reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    WHILE           reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    BEGIN           reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    FOR             reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    NUMBER          reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    STRING          reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    LOCAL           reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    GLOBAL          reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    CONSTANTS       reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    INSTANCEVAR     reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    CLASSVAR        reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    NEWLINE         reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    $end            reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    END             reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    ELSE            reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    ELSIF           reduce using rule 9 (while -> WHILE logical DO salto code salto END .)


state 163

    (65) for -> FOR iterador IN expresiones DO code END .

    IF              reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    WHILE           reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    BEGIN           reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    FOR             reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    NUMBER          reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    STRING          reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    LOCAL           reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    GLOBAL          reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    CONSTANTS       reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    INSTANCEVAR     reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    CLASSVAR        reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    END             reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    ELSE            reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    ELSIF           reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    NEWLINE         reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    $end            reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)


state 164

    (67) for -> FOR iterador IN array DO code END .

    IF              reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    WHILE           reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    BEGIN           reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    FOR             reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    NUMBER          reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    STRING          reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    LOCAL           reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    GLOBAL          reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    CONSTANTS       reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    INSTANCEVAR     reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    CLASSVAR        reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    END             reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    ELSE            reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    ELSIF           reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    NEWLINE         reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    $end            reduce using rule 67 (for -> FOR iterador IN array DO code END .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 5 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 5 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 27 resolved as shift
WARNING: shift/reduce conflict for STRING in state 27 resolved as shift
WARNING: shift/reduce conflict for LOCAL in state 27 resolved as shift
WARNING: shift/reduce conflict for GLOBAL in state 27 resolved as shift
WARNING: shift/reduce conflict for CONSTANTS in state 27 resolved as shift
WARNING: shift/reduce conflict for INSTANCEVAR in state 27 resolved as shift
WARNING: shift/reduce conflict for CLASSVAR in state 27 resolved as shift
WARNING: shift/reduce conflict for IF in state 41 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 41 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 41 resolved as shift
WARNING: shift/reduce conflict for FOR in state 41 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 41 resolved as shift
WARNING: shift/reduce conflict for STRING in state 41 resolved as shift
WARNING: shift/reduce conflict for LOCAL in state 41 resolved as shift
WARNING: shift/reduce conflict for GLOBAL in state 41 resolved as shift
WARNING: shift/reduce conflict for CONSTANTS in state 41 resolved as shift
WARNING: shift/reduce conflict for INSTANCEVAR in state 41 resolved as shift
WARNING: shift/reduce conflict for CLASSVAR in state 41 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 44 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 63 resolved as shift
WARNING: shift/reduce conflict for STRING in state 63 resolved as shift
WARNING: shift/reduce conflict for LOCAL in state 63 resolved as shift
WARNING: shift/reduce conflict for GLOBAL in state 63 resolved as shift
WARNING: shift/reduce conflict for CONSTANTS in state 63 resolved as shift
WARNING: shift/reduce conflict for INSTANCEVAR in state 63 resolved as shift
WARNING: shift/reduce conflict for CLASSVAR in state 63 resolved as shift
WARNING: shift/reduce conflict for ANDLOG in state 97 resolved as shift
WARNING: shift/reduce conflict for ORLOG in state 97 resolved as shift
WARNING: shift/reduce conflict for NOTLOG in state 97 resolved as shift
WARNING: shift/reduce conflict for AND in state 97 resolved as shift
WARNING: shift/reduce conflict for OR in state 97 resolved as shift
WARNING: shift/reduce conflict for NOT in state 97 resolved as shift
WARNING: shift/reduce conflict for ANDLOG in state 101 resolved as shift
WARNING: shift/reduce conflict for ORLOG in state 101 resolved as shift
WARNING: shift/reduce conflict for NOTLOG in state 101 resolved as shift
WARNING: shift/reduce conflict for AND in state 101 resolved as shift
WARNING: shift/reduce conflict for OR in state 101 resolved as shift
WARNING: shift/reduce conflict for NOT in state 101 resolved as shift
