Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ALIAS
    BREAK
    CASE
    CLASS
    DEF
    DEFINED
    ENSURE
    ERROR
    FALSE
    FILE
    LINE
    MODULE
    NEXT
    NIL
    PSEUDO
    REDO
    RESCUE
    RETRY
    RETURN
    SELF
    SUPER
    TRUE
    UNDEF
    UNLESS
    UNTIL
    WHEN
    YIELD

Grammar

Rule 0     S' -> while
Rule 1     while -> WHILE logical code END
Rule 2     while -> WHILE logical DO salto code salto END
Rule 3     while -> WHILE logical DOBLEPOINT salto code salto END
Rule 4     while -> BEGIN code END WHILE logical
Rule 5     assign -> variable ASS expr
Rule 6     assign -> variable ASS sexpr
Rule 7     assign -> variable ASS array
Rule 8     math -> term arith term
Rule 9     math -> term arith math
Rule 10    math -> variable asig term
Rule 11    logical -> term comparison term
Rule 12    logical -> term comparison logical
Rule 13    logical -> variable comparison term
Rule 14    logical -> variable comparison BOOLEAN
Rule 15    logical -> logical logcompare logical
Rule 16    logical -> BOOLEAN
Rule 17    variable -> LOCAL
Rule 18    variable -> GLOBAL
Rule 19    variable -> CONSTANTS
Rule 20    variable -> INSTANCEVAR
Rule 21    variable -> CLASSVAR
Rule 22    asig -> ASS
Rule 23    asig -> ADDASS
Rule 24    asig -> SUBASS
Rule 25    asig -> MULASS
Rule 26    asig -> DIVASS
Rule 27    asig -> MODASS
Rule 28    asig -> EXPASS
Rule 29    expr -> math
Rule 30    expr -> term
Rule 31    expr -> variable
Rule 32    expr -> assign
Rule 33    expr -> array
Rule 34    expr -> slice
Rule 35    expr -> index
Rule 36    sexpr -> sterm MUL term
Rule 37    sexpr -> sterm ADD sexpr
Rule 38    sexpr -> sterm
Rule 39    term -> NUMBER
Rule 40    sterm -> STRING
Rule 41    arith -> EXP
Rule 42    arith -> MUL
Rule 43    arith -> DIV
Rule 44    arith -> MOD
Rule 45    arith -> ADD
Rule 46    arith -> SUB
Rule 47    comparison -> EQUAL
Rule 48    comparison -> NOTEQ
Rule 49    comparison -> GREATHER
Rule 50    comparison -> LOWER
Rule 51    comparison -> GREATHEREQ
Rule 52    comparison -> LOWEREQ
Rule 53    logcompare -> ANDLOG
Rule 54    logcompare -> ORLOG
Rule 55    logcompare -> NOTLOG
Rule 56    logcompare -> AND
Rule 57    logcompare -> OR
Rule 58    logcompare -> NOT
Rule 59    salto -> NEWLINE
Rule 60    if -> IF logical expr END
Rule 61    if -> IF logical THEN expr END
Rule 62    if -> IF logical
Rule 63    if -> IF logical THEN
Rule 64    if -> if else
Rule 65    if -> if elsif END
Rule 66    else -> ELSE expr END
Rule 67    elsif -> ELSIF logical final
Rule 68    final -> expr
Rule 69    final -> THEN expr
Rule 70    final -> expr else
Rule 71    final -> expr elsif
Rule 72    code -> expr
Rule 73    code -> if
Rule 74    code -> while
Rule 75    code -> expresiones
Rule 76    code -> for
Rule 77    code -> assign
Rule 78    code -> math
Rule 79    code -> code code
Rule 80    iterador -> variable
Rule 81    iterador -> variable , variable
Rule 82    expresiones -> term DOUBLESECUENCEPOINT term
Rule 83    for -> FOR iterador IN expresiones code END
Rule 84    for -> FOR iterador IN expresiones DO code END
Rule 85    for -> FOR iterador IN array code END
Rule 86    for -> FOR iterador IN array DO code END
Rule 87    array -> LBRACK defarray RBRACK
Rule 88    defarray -> NUMBER
Rule 89    defarray -> NUMBER COMA defarray
Rule 90    defarray -> STRING
Rule 91    defarray -> STRING COMA defarray
Rule 92    defarray -> INT
Rule 93    defarray -> INT COMA defarray
Rule 94    defarray -> FLOAT
Rule 95    defarray -> FLOAT COMA defarray
Rule 96    defarray -> BOOLEAN
Rule 97    defarray -> BOOLEAN COMA defarray
Rule 98    index -> variable LBRACK INT RBRACK
Rule 99    slice -> variable LBRACK defslice RBRACK
Rule 100   defslice -> INT DOBLEPOINT INT
Rule 101   defslice -> INT DOBLEPOINT
Rule 102   defslice -> DOBLEPOINT INT

Terminals, with rules where they appear

,                    : 81
ADD                  : 37 45
ADDASS               : 23
ALIAS                : 
AND                  : 56
ANDLOG               : 53
ASS                  : 5 6 7 22
BEGIN                : 4
BOOLEAN              : 14 16 96 97
BREAK                : 
CASE                 : 
CLASS                : 
CLASSVAR             : 21
COMA                 : 89 91 93 95 97
CONSTANTS            : 19
DEF                  : 
DEFINED              : 
DIV                  : 43
DIVASS               : 26
DO                   : 2 84 86
DOBLEPOINT           : 3 100 101 102
DOUBLESECUENCEPOINT  : 82
ELSE                 : 66
ELSIF                : 67
END                  : 1 2 3 4 60 61 65 66 83 84 85 86
ENSURE               : 
EQUAL                : 47
ERROR                : 
EXP                  : 41
EXPASS               : 28
FALSE                : 
FILE                 : 
FLOAT                : 94 95
FOR                  : 83 84 85 86
GLOBAL               : 18
GREATHER             : 49
GREATHEREQ           : 51
IF                   : 60 61 62 63
IN                   : 83 84 85 86
INSTANCEVAR          : 20
INT                  : 92 93 98 100 100 101 102
LBRACK               : 87 98 99
LINE                 : 
LOCAL                : 17
LOWER                : 50
LOWEREQ              : 52
MOD                  : 44
MODASS               : 27
MODULE               : 
MUL                  : 36 42
MULASS               : 25
NEWLINE              : 59
NEXT                 : 
NIL                  : 
NOT                  : 58
NOTEQ                : 48
NOTLOG               : 55
NUMBER               : 39 88 89
OR                   : 57
ORLOG                : 54
PSEUDO               : 
RBRACK               : 87 98 99
REDO                 : 
RESCUE               : 
RETRY                : 
RETURN               : 
SELF                 : 
STRING               : 40 90 91
SUB                  : 46
SUBASS               : 24
SUPER                : 
THEN                 : 61 63 69
TRUE                 : 
UNDEF                : 
UNLESS               : 
UNTIL                : 
WHEN                 : 
WHILE                : 1 2 3 4
YIELD                : 
error                : 

Nonterminals, with rules where they appear

arith                : 8 9
array                : 7 33 85 86
asig                 : 10
assign               : 32 77
code                 : 1 2 3 4 79 79 83 84 85 86
comparison           : 11 12 13 14
defarray             : 87 89 91 93 95 97
defslice             : 99
else                 : 64 70
elsif                : 65 71
expr                 : 5 60 61 66 68 69 70 71 72
expresiones          : 75 83 84
final                : 67
for                  : 76
if                   : 64 65 73
index                : 35
iterador             : 83 84 85 86
logcompare           : 15
logical              : 1 2 3 4 12 15 15 60 61 62 63 67
math                 : 9 29 78
salto                : 2 2 3 3
sexpr                : 6 37
slice                : 34
sterm                : 36 37 38
term                 : 8 8 9 10 11 11 12 13 30 36 82 82
variable             : 5 6 7 10 13 14 31 80 81 81 98 99
while                : 74 0

Parsing method: LALR

state 0

    (0) S' -> . while
    (1) while -> . WHILE logical code END
    (2) while -> . WHILE logical DO salto code salto END
    (3) while -> . WHILE logical DOBLEPOINT salto code salto END
    (4) while -> . BEGIN code END WHILE logical

    WHILE           shift and go to state 2
    BEGIN           shift and go to state 3

    while                          shift and go to state 1

state 1

    (0) S' -> while .



state 2

    (1) while -> WHILE . logical code END
    (2) while -> WHILE . logical DO salto code salto END
    (3) while -> WHILE . logical DOBLEPOINT salto code salto END
    (11) logical -> . term comparison term
    (12) logical -> . term comparison logical
    (13) logical -> . variable comparison term
    (14) logical -> . variable comparison BOOLEAN
    (15) logical -> . logical logcompare logical
    (16) logical -> . BOOLEAN
    (39) term -> . NUMBER
    (17) variable -> . LOCAL
    (18) variable -> . GLOBAL
    (19) variable -> . CONSTANTS
    (20) variable -> . INSTANCEVAR
    (21) variable -> . CLASSVAR

    BOOLEAN         shift and go to state 7
    NUMBER          shift and go to state 8
    LOCAL           shift and go to state 9
    GLOBAL          shift and go to state 10
    CONSTANTS       shift and go to state 11
    INSTANCEVAR     shift and go to state 12
    CLASSVAR        shift and go to state 13

    logical                        shift and go to state 4
    term                           shift and go to state 5
    variable                       shift and go to state 6

state 3

    (4) while -> BEGIN . code END WHILE logical
    (72) code -> . expr
    (73) code -> . if
    (74) code -> . while
    (75) code -> . expresiones
    (76) code -> . for
    (77) code -> . assign
    (78) code -> . math
    (79) code -> . code code
    (29) expr -> . math
    (30) expr -> . term
    (31) expr -> . variable
    (32) expr -> . assign
    (33) expr -> . array
    (34) expr -> . slice
    (35) expr -> . index
    (60) if -> . IF logical expr END
    (61) if -> . IF logical THEN expr END
    (62) if -> . IF logical
    (63) if -> . IF logical THEN
    (64) if -> . if else
    (65) if -> . if elsif END
    (1) while -> . WHILE logical code END
    (2) while -> . WHILE logical DO salto code salto END
    (3) while -> . WHILE logical DOBLEPOINT salto code salto END
    (4) while -> . BEGIN code END WHILE logical
    (82) expresiones -> . term DOUBLESECUENCEPOINT term
    (83) for -> . FOR iterador IN expresiones code END
    (84) for -> . FOR iterador IN expresiones DO code END
    (85) for -> . FOR iterador IN array code END
    (86) for -> . FOR iterador IN array DO code END
    (5) assign -> . variable ASS expr
    (6) assign -> . variable ASS sexpr
    (7) assign -> . variable ASS array
    (8) math -> . term arith term
    (9) math -> . term arith math
    (10) math -> . variable asig term
    (39) term -> . NUMBER
    (17) variable -> . LOCAL
    (18) variable -> . GLOBAL
    (19) variable -> . CONSTANTS
    (20) variable -> . INSTANCEVAR
    (21) variable -> . CLASSVAR
    (87) array -> . LBRACK defarray RBRACK
    (99) slice -> . variable LBRACK defslice RBRACK
    (98) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 27
    WHILE           shift and go to state 2
    BEGIN           shift and go to state 3
    FOR             shift and go to state 28
    NUMBER          shift and go to state 8
    LOCAL           shift and go to state 9
    GLOBAL          shift and go to state 10
    CONSTANTS       shift and go to state 11
    INSTANCEVAR     shift and go to state 12
    CLASSVAR        shift and go to state 13
    LBRACK          shift and go to state 29

    code                           shift and go to state 14
    expr                           shift and go to state 15
    if                             shift and go to state 16
    while                          shift and go to state 17
    expresiones                    shift and go to state 18
    for                            shift and go to state 19
    assign                         shift and go to state 20
    math                           shift and go to state 21
    term                           shift and go to state 22
    variable                       shift and go to state 23
    array                          shift and go to state 24
    slice                          shift and go to state 25
    index                          shift and go to state 26

state 4

    (1) while -> WHILE logical . code END
    (2) while -> WHILE logical . DO salto code salto END
    (3) while -> WHILE logical . DOBLEPOINT salto code salto END
    (15) logical -> logical . logcompare logical
    (72) code -> . expr
    (73) code -> . if
    (74) code -> . while
    (75) code -> . expresiones
    (76) code -> . for
    (77) code -> . assign
    (78) code -> . math
    (79) code -> . code code
    (53) logcompare -> . ANDLOG
    (54) logcompare -> . ORLOG
    (55) logcompare -> . NOTLOG
    (56) logcompare -> . AND
    (57) logcompare -> . OR
    (58) logcompare -> . NOT
    (29) expr -> . math
    (30) expr -> . term
    (31) expr -> . variable
    (32) expr -> . assign
    (33) expr -> . array
    (34) expr -> . slice
    (35) expr -> . index
    (60) if -> . IF logical expr END
    (61) if -> . IF logical THEN expr END
    (62) if -> . IF logical
    (63) if -> . IF logical THEN
    (64) if -> . if else
    (65) if -> . if elsif END
    (1) while -> . WHILE logical code END
    (2) while -> . WHILE logical DO salto code salto END
    (3) while -> . WHILE logical DOBLEPOINT salto code salto END
    (4) while -> . BEGIN code END WHILE logical
    (82) expresiones -> . term DOUBLESECUENCEPOINT term
    (83) for -> . FOR iterador IN expresiones code END
    (84) for -> . FOR iterador IN expresiones DO code END
    (85) for -> . FOR iterador IN array code END
    (86) for -> . FOR iterador IN array DO code END
    (5) assign -> . variable ASS expr
    (6) assign -> . variable ASS sexpr
    (7) assign -> . variable ASS array
    (8) math -> . term arith term
    (9) math -> . term arith math
    (10) math -> . variable asig term
    (39) term -> . NUMBER
    (17) variable -> . LOCAL
    (18) variable -> . GLOBAL
    (19) variable -> . CONSTANTS
    (20) variable -> . INSTANCEVAR
    (21) variable -> . CLASSVAR
    (87) array -> . LBRACK defarray RBRACK
    (99) slice -> . variable LBRACK defslice RBRACK
    (98) index -> . variable LBRACK INT RBRACK

    DO              shift and go to state 31
    DOBLEPOINT      shift and go to state 32
    ANDLOG          shift and go to state 34
    ORLOG           shift and go to state 35
    NOTLOG          shift and go to state 36
    AND             shift and go to state 37
    OR              shift and go to state 38
    NOT             shift and go to state 39
    IF              shift and go to state 27
    WHILE           shift and go to state 2
    BEGIN           shift and go to state 3
    FOR             shift and go to state 28
    NUMBER          shift and go to state 8
    LOCAL           shift and go to state 9
    GLOBAL          shift and go to state 10
    CONSTANTS       shift and go to state 11
    INSTANCEVAR     shift and go to state 12
    CLASSVAR        shift and go to state 13
    LBRACK          shift and go to state 29

    code                           shift and go to state 30
    logcompare                     shift and go to state 33
    expr                           shift and go to state 15
    if                             shift and go to state 16
    while                          shift and go to state 17
    expresiones                    shift and go to state 18
    for                            shift and go to state 19
    assign                         shift and go to state 20
    math                           shift and go to state 21
    term                           shift and go to state 22
    variable                       shift and go to state 23
    array                          shift and go to state 24
    slice                          shift and go to state 25
    index                          shift and go to state 26

state 5

    (11) logical -> term . comparison term
    (12) logical -> term . comparison logical
    (47) comparison -> . EQUAL
    (48) comparison -> . NOTEQ
    (49) comparison -> . GREATHER
    (50) comparison -> . LOWER
    (51) comparison -> . GREATHEREQ
    (52) comparison -> . LOWEREQ

    EQUAL           shift and go to state 41
    NOTEQ           shift and go to state 42
    GREATHER        shift and go to state 43
    LOWER           shift and go to state 44
    GREATHEREQ      shift and go to state 45
    LOWEREQ         shift and go to state 46

    comparison                     shift and go to state 40

state 6

    (13) logical -> variable . comparison term
    (14) logical -> variable . comparison BOOLEAN
    (47) comparison -> . EQUAL
    (48) comparison -> . NOTEQ
    (49) comparison -> . GREATHER
    (50) comparison -> . LOWER
    (51) comparison -> . GREATHEREQ
    (52) comparison -> . LOWEREQ

    EQUAL           shift and go to state 41
    NOTEQ           shift and go to state 42
    GREATHER        shift and go to state 43
    LOWER           shift and go to state 44
    GREATHEREQ      shift and go to state 45
    LOWEREQ         shift and go to state 46

    comparison                     shift and go to state 47

state 7

    (16) logical -> BOOLEAN .

    DO              reduce using rule 16 (logical -> BOOLEAN .)
    DOBLEPOINT      reduce using rule 16 (logical -> BOOLEAN .)
    ANDLOG          reduce using rule 16 (logical -> BOOLEAN .)
    ORLOG           reduce using rule 16 (logical -> BOOLEAN .)
    NOTLOG          reduce using rule 16 (logical -> BOOLEAN .)
    AND             reduce using rule 16 (logical -> BOOLEAN .)
    OR              reduce using rule 16 (logical -> BOOLEAN .)
    NOT             reduce using rule 16 (logical -> BOOLEAN .)
    IF              reduce using rule 16 (logical -> BOOLEAN .)
    WHILE           reduce using rule 16 (logical -> BOOLEAN .)
    BEGIN           reduce using rule 16 (logical -> BOOLEAN .)
    FOR             reduce using rule 16 (logical -> BOOLEAN .)
    NUMBER          reduce using rule 16 (logical -> BOOLEAN .)
    LOCAL           reduce using rule 16 (logical -> BOOLEAN .)
    GLOBAL          reduce using rule 16 (logical -> BOOLEAN .)
    CONSTANTS       reduce using rule 16 (logical -> BOOLEAN .)
    INSTANCEVAR     reduce using rule 16 (logical -> BOOLEAN .)
    CLASSVAR        reduce using rule 16 (logical -> BOOLEAN .)
    LBRACK          reduce using rule 16 (logical -> BOOLEAN .)
    THEN            reduce using rule 16 (logical -> BOOLEAN .)
    ELSE            reduce using rule 16 (logical -> BOOLEAN .)
    ELSIF           reduce using rule 16 (logical -> BOOLEAN .)
    END             reduce using rule 16 (logical -> BOOLEAN .)
    NEWLINE         reduce using rule 16 (logical -> BOOLEAN .)
    $end            reduce using rule 16 (logical -> BOOLEAN .)


state 8

    (39) term -> NUMBER .

    EQUAL           reduce using rule 39 (term -> NUMBER .)
    NOTEQ           reduce using rule 39 (term -> NUMBER .)
    GREATHER        reduce using rule 39 (term -> NUMBER .)
    LOWER           reduce using rule 39 (term -> NUMBER .)
    GREATHEREQ      reduce using rule 39 (term -> NUMBER .)
    LOWEREQ         reduce using rule 39 (term -> NUMBER .)
    DOUBLESECUENCEPOINT reduce using rule 39 (term -> NUMBER .)
    EXP             reduce using rule 39 (term -> NUMBER .)
    MUL             reduce using rule 39 (term -> NUMBER .)
    DIV             reduce using rule 39 (term -> NUMBER .)
    MOD             reduce using rule 39 (term -> NUMBER .)
    ADD             reduce using rule 39 (term -> NUMBER .)
    SUB             reduce using rule 39 (term -> NUMBER .)
    END             reduce using rule 39 (term -> NUMBER .)
    IF              reduce using rule 39 (term -> NUMBER .)
    WHILE           reduce using rule 39 (term -> NUMBER .)
    BEGIN           reduce using rule 39 (term -> NUMBER .)
    FOR             reduce using rule 39 (term -> NUMBER .)
    NUMBER          reduce using rule 39 (term -> NUMBER .)
    LOCAL           reduce using rule 39 (term -> NUMBER .)
    GLOBAL          reduce using rule 39 (term -> NUMBER .)
    CONSTANTS       reduce using rule 39 (term -> NUMBER .)
    INSTANCEVAR     reduce using rule 39 (term -> NUMBER .)
    CLASSVAR        reduce using rule 39 (term -> NUMBER .)
    LBRACK          reduce using rule 39 (term -> NUMBER .)
    DO              reduce using rule 39 (term -> NUMBER .)
    DOBLEPOINT      reduce using rule 39 (term -> NUMBER .)
    ANDLOG          reduce using rule 39 (term -> NUMBER .)
    ORLOG           reduce using rule 39 (term -> NUMBER .)
    NOTLOG          reduce using rule 39 (term -> NUMBER .)
    AND             reduce using rule 39 (term -> NUMBER .)
    OR              reduce using rule 39 (term -> NUMBER .)
    NOT             reduce using rule 39 (term -> NUMBER .)
    THEN            reduce using rule 39 (term -> NUMBER .)
    ELSE            reduce using rule 39 (term -> NUMBER .)
    ELSIF           reduce using rule 39 (term -> NUMBER .)
    NEWLINE         reduce using rule 39 (term -> NUMBER .)
    $end            reduce using rule 39 (term -> NUMBER .)


state 9

    (17) variable -> LOCAL .

    EQUAL           reduce using rule 17 (variable -> LOCAL .)
    NOTEQ           reduce using rule 17 (variable -> LOCAL .)
    GREATHER        reduce using rule 17 (variable -> LOCAL .)
    LOWER           reduce using rule 17 (variable -> LOCAL .)
    GREATHEREQ      reduce using rule 17 (variable -> LOCAL .)
    LOWEREQ         reduce using rule 17 (variable -> LOCAL .)
    ASS             reduce using rule 17 (variable -> LOCAL .)
    LBRACK          reduce using rule 17 (variable -> LOCAL .)
    ADDASS          reduce using rule 17 (variable -> LOCAL .)
    SUBASS          reduce using rule 17 (variable -> LOCAL .)
    MULASS          reduce using rule 17 (variable -> LOCAL .)
    DIVASS          reduce using rule 17 (variable -> LOCAL .)
    MODASS          reduce using rule 17 (variable -> LOCAL .)
    EXPASS          reduce using rule 17 (variable -> LOCAL .)
    END             reduce using rule 17 (variable -> LOCAL .)
    IF              reduce using rule 17 (variable -> LOCAL .)
    WHILE           reduce using rule 17 (variable -> LOCAL .)
    BEGIN           reduce using rule 17 (variable -> LOCAL .)
    FOR             reduce using rule 17 (variable -> LOCAL .)
    NUMBER          reduce using rule 17 (variable -> LOCAL .)
    LOCAL           reduce using rule 17 (variable -> LOCAL .)
    GLOBAL          reduce using rule 17 (variable -> LOCAL .)
    CONSTANTS       reduce using rule 17 (variable -> LOCAL .)
    INSTANCEVAR     reduce using rule 17 (variable -> LOCAL .)
    CLASSVAR        reduce using rule 17 (variable -> LOCAL .)
    ,               reduce using rule 17 (variable -> LOCAL .)
    IN              reduce using rule 17 (variable -> LOCAL .)
    NEWLINE         reduce using rule 17 (variable -> LOCAL .)
    ELSE            reduce using rule 17 (variable -> LOCAL .)
    ELSIF           reduce using rule 17 (variable -> LOCAL .)


state 10

    (18) variable -> GLOBAL .

    EQUAL           reduce using rule 18 (variable -> GLOBAL .)
    NOTEQ           reduce using rule 18 (variable -> GLOBAL .)
    GREATHER        reduce using rule 18 (variable -> GLOBAL .)
    LOWER           reduce using rule 18 (variable -> GLOBAL .)
    GREATHEREQ      reduce using rule 18 (variable -> GLOBAL .)
    LOWEREQ         reduce using rule 18 (variable -> GLOBAL .)
    ASS             reduce using rule 18 (variable -> GLOBAL .)
    LBRACK          reduce using rule 18 (variable -> GLOBAL .)
    ADDASS          reduce using rule 18 (variable -> GLOBAL .)
    SUBASS          reduce using rule 18 (variable -> GLOBAL .)
    MULASS          reduce using rule 18 (variable -> GLOBAL .)
    DIVASS          reduce using rule 18 (variable -> GLOBAL .)
    MODASS          reduce using rule 18 (variable -> GLOBAL .)
    EXPASS          reduce using rule 18 (variable -> GLOBAL .)
    END             reduce using rule 18 (variable -> GLOBAL .)
    IF              reduce using rule 18 (variable -> GLOBAL .)
    WHILE           reduce using rule 18 (variable -> GLOBAL .)
    BEGIN           reduce using rule 18 (variable -> GLOBAL .)
    FOR             reduce using rule 18 (variable -> GLOBAL .)
    NUMBER          reduce using rule 18 (variable -> GLOBAL .)
    LOCAL           reduce using rule 18 (variable -> GLOBAL .)
    GLOBAL          reduce using rule 18 (variable -> GLOBAL .)
    CONSTANTS       reduce using rule 18 (variable -> GLOBAL .)
    INSTANCEVAR     reduce using rule 18 (variable -> GLOBAL .)
    CLASSVAR        reduce using rule 18 (variable -> GLOBAL .)
    ,               reduce using rule 18 (variable -> GLOBAL .)
    IN              reduce using rule 18 (variable -> GLOBAL .)
    NEWLINE         reduce using rule 18 (variable -> GLOBAL .)
    ELSE            reduce using rule 18 (variable -> GLOBAL .)
    ELSIF           reduce using rule 18 (variable -> GLOBAL .)


state 11

    (19) variable -> CONSTANTS .

    EQUAL           reduce using rule 19 (variable -> CONSTANTS .)
    NOTEQ           reduce using rule 19 (variable -> CONSTANTS .)
    GREATHER        reduce using rule 19 (variable -> CONSTANTS .)
    LOWER           reduce using rule 19 (variable -> CONSTANTS .)
    GREATHEREQ      reduce using rule 19 (variable -> CONSTANTS .)
    LOWEREQ         reduce using rule 19 (variable -> CONSTANTS .)
    ASS             reduce using rule 19 (variable -> CONSTANTS .)
    LBRACK          reduce using rule 19 (variable -> CONSTANTS .)
    ADDASS          reduce using rule 19 (variable -> CONSTANTS .)
    SUBASS          reduce using rule 19 (variable -> CONSTANTS .)
    MULASS          reduce using rule 19 (variable -> CONSTANTS .)
    DIVASS          reduce using rule 19 (variable -> CONSTANTS .)
    MODASS          reduce using rule 19 (variable -> CONSTANTS .)
    EXPASS          reduce using rule 19 (variable -> CONSTANTS .)
    END             reduce using rule 19 (variable -> CONSTANTS .)
    IF              reduce using rule 19 (variable -> CONSTANTS .)
    WHILE           reduce using rule 19 (variable -> CONSTANTS .)
    BEGIN           reduce using rule 19 (variable -> CONSTANTS .)
    FOR             reduce using rule 19 (variable -> CONSTANTS .)
    NUMBER          reduce using rule 19 (variable -> CONSTANTS .)
    LOCAL           reduce using rule 19 (variable -> CONSTANTS .)
    GLOBAL          reduce using rule 19 (variable -> CONSTANTS .)
    CONSTANTS       reduce using rule 19 (variable -> CONSTANTS .)
    INSTANCEVAR     reduce using rule 19 (variable -> CONSTANTS .)
    CLASSVAR        reduce using rule 19 (variable -> CONSTANTS .)
    ,               reduce using rule 19 (variable -> CONSTANTS .)
    IN              reduce using rule 19 (variable -> CONSTANTS .)
    NEWLINE         reduce using rule 19 (variable -> CONSTANTS .)
    ELSE            reduce using rule 19 (variable -> CONSTANTS .)
    ELSIF           reduce using rule 19 (variable -> CONSTANTS .)


state 12

    (20) variable -> INSTANCEVAR .

    EQUAL           reduce using rule 20 (variable -> INSTANCEVAR .)
    NOTEQ           reduce using rule 20 (variable -> INSTANCEVAR .)
    GREATHER        reduce using rule 20 (variable -> INSTANCEVAR .)
    LOWER           reduce using rule 20 (variable -> INSTANCEVAR .)
    GREATHEREQ      reduce using rule 20 (variable -> INSTANCEVAR .)
    LOWEREQ         reduce using rule 20 (variable -> INSTANCEVAR .)
    ASS             reduce using rule 20 (variable -> INSTANCEVAR .)
    LBRACK          reduce using rule 20 (variable -> INSTANCEVAR .)
    ADDASS          reduce using rule 20 (variable -> INSTANCEVAR .)
    SUBASS          reduce using rule 20 (variable -> INSTANCEVAR .)
    MULASS          reduce using rule 20 (variable -> INSTANCEVAR .)
    DIVASS          reduce using rule 20 (variable -> INSTANCEVAR .)
    MODASS          reduce using rule 20 (variable -> INSTANCEVAR .)
    EXPASS          reduce using rule 20 (variable -> INSTANCEVAR .)
    END             reduce using rule 20 (variable -> INSTANCEVAR .)
    IF              reduce using rule 20 (variable -> INSTANCEVAR .)
    WHILE           reduce using rule 20 (variable -> INSTANCEVAR .)
    BEGIN           reduce using rule 20 (variable -> INSTANCEVAR .)
    FOR             reduce using rule 20 (variable -> INSTANCEVAR .)
    NUMBER          reduce using rule 20 (variable -> INSTANCEVAR .)
    LOCAL           reduce using rule 20 (variable -> INSTANCEVAR .)
    GLOBAL          reduce using rule 20 (variable -> INSTANCEVAR .)
    CONSTANTS       reduce using rule 20 (variable -> INSTANCEVAR .)
    INSTANCEVAR     reduce using rule 20 (variable -> INSTANCEVAR .)
    CLASSVAR        reduce using rule 20 (variable -> INSTANCEVAR .)
    ,               reduce using rule 20 (variable -> INSTANCEVAR .)
    IN              reduce using rule 20 (variable -> INSTANCEVAR .)
    NEWLINE         reduce using rule 20 (variable -> INSTANCEVAR .)
    ELSE            reduce using rule 20 (variable -> INSTANCEVAR .)
    ELSIF           reduce using rule 20 (variable -> INSTANCEVAR .)


state 13

    (21) variable -> CLASSVAR .

    EQUAL           reduce using rule 21 (variable -> CLASSVAR .)
    NOTEQ           reduce using rule 21 (variable -> CLASSVAR .)
    GREATHER        reduce using rule 21 (variable -> CLASSVAR .)
    LOWER           reduce using rule 21 (variable -> CLASSVAR .)
    GREATHEREQ      reduce using rule 21 (variable -> CLASSVAR .)
    LOWEREQ         reduce using rule 21 (variable -> CLASSVAR .)
    ASS             reduce using rule 21 (variable -> CLASSVAR .)
    LBRACK          reduce using rule 21 (variable -> CLASSVAR .)
    ADDASS          reduce using rule 21 (variable -> CLASSVAR .)
    SUBASS          reduce using rule 21 (variable -> CLASSVAR .)
    MULASS          reduce using rule 21 (variable -> CLASSVAR .)
    DIVASS          reduce using rule 21 (variable -> CLASSVAR .)
    MODASS          reduce using rule 21 (variable -> CLASSVAR .)
    EXPASS          reduce using rule 21 (variable -> CLASSVAR .)
    END             reduce using rule 21 (variable -> CLASSVAR .)
    IF              reduce using rule 21 (variable -> CLASSVAR .)
    WHILE           reduce using rule 21 (variable -> CLASSVAR .)
    BEGIN           reduce using rule 21 (variable -> CLASSVAR .)
    FOR             reduce using rule 21 (variable -> CLASSVAR .)
    NUMBER          reduce using rule 21 (variable -> CLASSVAR .)
    LOCAL           reduce using rule 21 (variable -> CLASSVAR .)
    GLOBAL          reduce using rule 21 (variable -> CLASSVAR .)
    CONSTANTS       reduce using rule 21 (variable -> CLASSVAR .)
    INSTANCEVAR     reduce using rule 21 (variable -> CLASSVAR .)
    CLASSVAR        reduce using rule 21 (variable -> CLASSVAR .)
    ,               reduce using rule 21 (variable -> CLASSVAR .)
    IN              reduce using rule 21 (variable -> CLASSVAR .)
    NEWLINE         reduce using rule 21 (variable -> CLASSVAR .)
    ELSE            reduce using rule 21 (variable -> CLASSVAR .)
    ELSIF           reduce using rule 21 (variable -> CLASSVAR .)


state 14

    (4) while -> BEGIN code . END WHILE logical
    (79) code -> code . code
    (72) code -> . expr
    (73) code -> . if
    (74) code -> . while
    (75) code -> . expresiones
    (76) code -> . for
    (77) code -> . assign
    (78) code -> . math
    (79) code -> . code code
    (29) expr -> . math
    (30) expr -> . term
    (31) expr -> . variable
    (32) expr -> . assign
    (33) expr -> . array
    (34) expr -> . slice
    (35) expr -> . index
    (60) if -> . IF logical expr END
    (61) if -> . IF logical THEN expr END
    (62) if -> . IF logical
    (63) if -> . IF logical THEN
    (64) if -> . if else
    (65) if -> . if elsif END
    (1) while -> . WHILE logical code END
    (2) while -> . WHILE logical DO salto code salto END
    (3) while -> . WHILE logical DOBLEPOINT salto code salto END
    (4) while -> . BEGIN code END WHILE logical
    (82) expresiones -> . term DOUBLESECUENCEPOINT term
    (83) for -> . FOR iterador IN expresiones code END
    (84) for -> . FOR iterador IN expresiones DO code END
    (85) for -> . FOR iterador IN array code END
    (86) for -> . FOR iterador IN array DO code END
    (5) assign -> . variable ASS expr
    (6) assign -> . variable ASS sexpr
    (7) assign -> . variable ASS array
    (8) math -> . term arith term
    (9) math -> . term arith math
    (10) math -> . variable asig term
    (39) term -> . NUMBER
    (17) variable -> . LOCAL
    (18) variable -> . GLOBAL
    (19) variable -> . CONSTANTS
    (20) variable -> . INSTANCEVAR
    (21) variable -> . CLASSVAR
    (87) array -> . LBRACK defarray RBRACK
    (99) slice -> . variable LBRACK defslice RBRACK
    (98) index -> . variable LBRACK INT RBRACK

    END             shift and go to state 49
    IF              shift and go to state 27
    WHILE           shift and go to state 2
    BEGIN           shift and go to state 3
    FOR             shift and go to state 28
    NUMBER          shift and go to state 8
    LOCAL           shift and go to state 9
    GLOBAL          shift and go to state 10
    CONSTANTS       shift and go to state 11
    INSTANCEVAR     shift and go to state 12
    CLASSVAR        shift and go to state 13
    LBRACK          shift and go to state 29

    code                           shift and go to state 48
    expr                           shift and go to state 15
    if                             shift and go to state 16
    while                          shift and go to state 17
    expresiones                    shift and go to state 18
    for                            shift and go to state 19
    assign                         shift and go to state 20
    math                           shift and go to state 21
    term                           shift and go to state 22
    variable                       shift and go to state 23
    array                          shift and go to state 24
    slice                          shift and go to state 25
    index                          shift and go to state 26

state 15

    (72) code -> expr .

    END             reduce using rule 72 (code -> expr .)
    IF              reduce using rule 72 (code -> expr .)
    WHILE           reduce using rule 72 (code -> expr .)
    BEGIN           reduce using rule 72 (code -> expr .)
    FOR             reduce using rule 72 (code -> expr .)
    NUMBER          reduce using rule 72 (code -> expr .)
    LOCAL           reduce using rule 72 (code -> expr .)
    GLOBAL          reduce using rule 72 (code -> expr .)
    CONSTANTS       reduce using rule 72 (code -> expr .)
    INSTANCEVAR     reduce using rule 72 (code -> expr .)
    CLASSVAR        reduce using rule 72 (code -> expr .)
    LBRACK          reduce using rule 72 (code -> expr .)
    NEWLINE         reduce using rule 72 (code -> expr .)


state 16

    (73) code -> if .
    (64) if -> if . else
    (65) if -> if . elsif END
    (66) else -> . ELSE expr END
    (67) elsif -> . ELSIF logical final

    END             reduce using rule 73 (code -> if .)
    IF              reduce using rule 73 (code -> if .)
    WHILE           reduce using rule 73 (code -> if .)
    BEGIN           reduce using rule 73 (code -> if .)
    FOR             reduce using rule 73 (code -> if .)
    NUMBER          reduce using rule 73 (code -> if .)
    LOCAL           reduce using rule 73 (code -> if .)
    GLOBAL          reduce using rule 73 (code -> if .)
    CONSTANTS       reduce using rule 73 (code -> if .)
    INSTANCEVAR     reduce using rule 73 (code -> if .)
    CLASSVAR        reduce using rule 73 (code -> if .)
    LBRACK          reduce using rule 73 (code -> if .)
    NEWLINE         reduce using rule 73 (code -> if .)
    ELSE            shift and go to state 52
    ELSIF           shift and go to state 53

    else                           shift and go to state 50
    elsif                          shift and go to state 51

state 17

    (74) code -> while .

    END             reduce using rule 74 (code -> while .)
    IF              reduce using rule 74 (code -> while .)
    WHILE           reduce using rule 74 (code -> while .)
    BEGIN           reduce using rule 74 (code -> while .)
    FOR             reduce using rule 74 (code -> while .)
    NUMBER          reduce using rule 74 (code -> while .)
    LOCAL           reduce using rule 74 (code -> while .)
    GLOBAL          reduce using rule 74 (code -> while .)
    CONSTANTS       reduce using rule 74 (code -> while .)
    INSTANCEVAR     reduce using rule 74 (code -> while .)
    CLASSVAR        reduce using rule 74 (code -> while .)
    LBRACK          reduce using rule 74 (code -> while .)
    NEWLINE         reduce using rule 74 (code -> while .)


state 18

    (75) code -> expresiones .

    END             reduce using rule 75 (code -> expresiones .)
    IF              reduce using rule 75 (code -> expresiones .)
    WHILE           reduce using rule 75 (code -> expresiones .)
    BEGIN           reduce using rule 75 (code -> expresiones .)
    FOR             reduce using rule 75 (code -> expresiones .)
    NUMBER          reduce using rule 75 (code -> expresiones .)
    LOCAL           reduce using rule 75 (code -> expresiones .)
    GLOBAL          reduce using rule 75 (code -> expresiones .)
    CONSTANTS       reduce using rule 75 (code -> expresiones .)
    INSTANCEVAR     reduce using rule 75 (code -> expresiones .)
    CLASSVAR        reduce using rule 75 (code -> expresiones .)
    LBRACK          reduce using rule 75 (code -> expresiones .)
    NEWLINE         reduce using rule 75 (code -> expresiones .)


state 19

    (76) code -> for .

    END             reduce using rule 76 (code -> for .)
    IF              reduce using rule 76 (code -> for .)
    WHILE           reduce using rule 76 (code -> for .)
    BEGIN           reduce using rule 76 (code -> for .)
    FOR             reduce using rule 76 (code -> for .)
    NUMBER          reduce using rule 76 (code -> for .)
    LOCAL           reduce using rule 76 (code -> for .)
    GLOBAL          reduce using rule 76 (code -> for .)
    CONSTANTS       reduce using rule 76 (code -> for .)
    INSTANCEVAR     reduce using rule 76 (code -> for .)
    CLASSVAR        reduce using rule 76 (code -> for .)
    LBRACK          reduce using rule 76 (code -> for .)
    NEWLINE         reduce using rule 76 (code -> for .)


state 20

    (77) code -> assign .
    (32) expr -> assign .

  ! reduce/reduce conflict for END resolved using rule 32 (expr -> assign .)
  ! reduce/reduce conflict for IF resolved using rule 32 (expr -> assign .)
  ! reduce/reduce conflict for WHILE resolved using rule 32 (expr -> assign .)
  ! reduce/reduce conflict for BEGIN resolved using rule 32 (expr -> assign .)
  ! reduce/reduce conflict for FOR resolved using rule 32 (expr -> assign .)
  ! reduce/reduce conflict for NUMBER resolved using rule 32 (expr -> assign .)
  ! reduce/reduce conflict for LOCAL resolved using rule 32 (expr -> assign .)
  ! reduce/reduce conflict for GLOBAL resolved using rule 32 (expr -> assign .)
  ! reduce/reduce conflict for CONSTANTS resolved using rule 32 (expr -> assign .)
  ! reduce/reduce conflict for INSTANCEVAR resolved using rule 32 (expr -> assign .)
  ! reduce/reduce conflict for CLASSVAR resolved using rule 32 (expr -> assign .)
  ! reduce/reduce conflict for LBRACK resolved using rule 32 (expr -> assign .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 32 (expr -> assign .)
    END             reduce using rule 32 (expr -> assign .)
    IF              reduce using rule 32 (expr -> assign .)
    WHILE           reduce using rule 32 (expr -> assign .)
    BEGIN           reduce using rule 32 (expr -> assign .)
    FOR             reduce using rule 32 (expr -> assign .)
    NUMBER          reduce using rule 32 (expr -> assign .)
    LOCAL           reduce using rule 32 (expr -> assign .)
    GLOBAL          reduce using rule 32 (expr -> assign .)
    CONSTANTS       reduce using rule 32 (expr -> assign .)
    INSTANCEVAR     reduce using rule 32 (expr -> assign .)
    CLASSVAR        reduce using rule 32 (expr -> assign .)
    LBRACK          reduce using rule 32 (expr -> assign .)
    NEWLINE         reduce using rule 32 (expr -> assign .)

  ! END             [ reduce using rule 77 (code -> assign .) ]
  ! IF              [ reduce using rule 77 (code -> assign .) ]
  ! WHILE           [ reduce using rule 77 (code -> assign .) ]
  ! BEGIN           [ reduce using rule 77 (code -> assign .) ]
  ! FOR             [ reduce using rule 77 (code -> assign .) ]
  ! NUMBER          [ reduce using rule 77 (code -> assign .) ]
  ! LOCAL           [ reduce using rule 77 (code -> assign .) ]
  ! GLOBAL          [ reduce using rule 77 (code -> assign .) ]
  ! CONSTANTS       [ reduce using rule 77 (code -> assign .) ]
  ! INSTANCEVAR     [ reduce using rule 77 (code -> assign .) ]
  ! CLASSVAR        [ reduce using rule 77 (code -> assign .) ]
  ! LBRACK          [ reduce using rule 77 (code -> assign .) ]
  ! NEWLINE         [ reduce using rule 77 (code -> assign .) ]


state 21

    (78) code -> math .
    (29) expr -> math .

  ! reduce/reduce conflict for END resolved using rule 29 (expr -> math .)
  ! reduce/reduce conflict for IF resolved using rule 29 (expr -> math .)
  ! reduce/reduce conflict for WHILE resolved using rule 29 (expr -> math .)
  ! reduce/reduce conflict for BEGIN resolved using rule 29 (expr -> math .)
  ! reduce/reduce conflict for FOR resolved using rule 29 (expr -> math .)
  ! reduce/reduce conflict for NUMBER resolved using rule 29 (expr -> math .)
  ! reduce/reduce conflict for LOCAL resolved using rule 29 (expr -> math .)
  ! reduce/reduce conflict for GLOBAL resolved using rule 29 (expr -> math .)
  ! reduce/reduce conflict for CONSTANTS resolved using rule 29 (expr -> math .)
  ! reduce/reduce conflict for INSTANCEVAR resolved using rule 29 (expr -> math .)
  ! reduce/reduce conflict for CLASSVAR resolved using rule 29 (expr -> math .)
  ! reduce/reduce conflict for LBRACK resolved using rule 29 (expr -> math .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 29 (expr -> math .)
    END             reduce using rule 29 (expr -> math .)
    IF              reduce using rule 29 (expr -> math .)
    WHILE           reduce using rule 29 (expr -> math .)
    BEGIN           reduce using rule 29 (expr -> math .)
    FOR             reduce using rule 29 (expr -> math .)
    NUMBER          reduce using rule 29 (expr -> math .)
    LOCAL           reduce using rule 29 (expr -> math .)
    GLOBAL          reduce using rule 29 (expr -> math .)
    CONSTANTS       reduce using rule 29 (expr -> math .)
    INSTANCEVAR     reduce using rule 29 (expr -> math .)
    CLASSVAR        reduce using rule 29 (expr -> math .)
    LBRACK          reduce using rule 29 (expr -> math .)
    NEWLINE         reduce using rule 29 (expr -> math .)

  ! END             [ reduce using rule 78 (code -> math .) ]
  ! IF              [ reduce using rule 78 (code -> math .) ]
  ! WHILE           [ reduce using rule 78 (code -> math .) ]
  ! BEGIN           [ reduce using rule 78 (code -> math .) ]
  ! FOR             [ reduce using rule 78 (code -> math .) ]
  ! NUMBER          [ reduce using rule 78 (code -> math .) ]
  ! LOCAL           [ reduce using rule 78 (code -> math .) ]
  ! GLOBAL          [ reduce using rule 78 (code -> math .) ]
  ! CONSTANTS       [ reduce using rule 78 (code -> math .) ]
  ! INSTANCEVAR     [ reduce using rule 78 (code -> math .) ]
  ! CLASSVAR        [ reduce using rule 78 (code -> math .) ]
  ! LBRACK          [ reduce using rule 78 (code -> math .) ]
  ! NEWLINE         [ reduce using rule 78 (code -> math .) ]


state 22

    (30) expr -> term .
    (82) expresiones -> term . DOUBLESECUENCEPOINT term
    (8) math -> term . arith term
    (9) math -> term . arith math
    (41) arith -> . EXP
    (42) arith -> . MUL
    (43) arith -> . DIV
    (44) arith -> . MOD
    (45) arith -> . ADD
    (46) arith -> . SUB

    END             reduce using rule 30 (expr -> term .)
    IF              reduce using rule 30 (expr -> term .)
    WHILE           reduce using rule 30 (expr -> term .)
    BEGIN           reduce using rule 30 (expr -> term .)
    FOR             reduce using rule 30 (expr -> term .)
    NUMBER          reduce using rule 30 (expr -> term .)
    LOCAL           reduce using rule 30 (expr -> term .)
    GLOBAL          reduce using rule 30 (expr -> term .)
    CONSTANTS       reduce using rule 30 (expr -> term .)
    INSTANCEVAR     reduce using rule 30 (expr -> term .)
    CLASSVAR        reduce using rule 30 (expr -> term .)
    LBRACK          reduce using rule 30 (expr -> term .)
    NEWLINE         reduce using rule 30 (expr -> term .)
    DOUBLESECUENCEPOINT shift and go to state 54
    EXP             shift and go to state 56
    MUL             shift and go to state 57
    DIV             shift and go to state 58
    MOD             shift and go to state 59
    ADD             shift and go to state 60
    SUB             shift and go to state 61

    arith                          shift and go to state 55

state 23

    (31) expr -> variable .
    (5) assign -> variable . ASS expr
    (6) assign -> variable . ASS sexpr
    (7) assign -> variable . ASS array
    (10) math -> variable . asig term
    (99) slice -> variable . LBRACK defslice RBRACK
    (98) index -> variable . LBRACK INT RBRACK
    (22) asig -> . ASS
    (23) asig -> . ADDASS
    (24) asig -> . SUBASS
    (25) asig -> . MULASS
    (26) asig -> . DIVASS
    (27) asig -> . MODASS
    (28) asig -> . EXPASS

  ! shift/reduce conflict for LBRACK resolved as shift
    END             reduce using rule 31 (expr -> variable .)
    IF              reduce using rule 31 (expr -> variable .)
    WHILE           reduce using rule 31 (expr -> variable .)
    BEGIN           reduce using rule 31 (expr -> variable .)
    FOR             reduce using rule 31 (expr -> variable .)
    NUMBER          reduce using rule 31 (expr -> variable .)
    LOCAL           reduce using rule 31 (expr -> variable .)
    GLOBAL          reduce using rule 31 (expr -> variable .)
    CONSTANTS       reduce using rule 31 (expr -> variable .)
    INSTANCEVAR     reduce using rule 31 (expr -> variable .)
    CLASSVAR        reduce using rule 31 (expr -> variable .)
    NEWLINE         reduce using rule 31 (expr -> variable .)
    ASS             shift and go to state 62
    LBRACK          shift and go to state 64
    ADDASS          shift and go to state 65
    SUBASS          shift and go to state 66
    MULASS          shift and go to state 67
    DIVASS          shift and go to state 68
    MODASS          shift and go to state 69
    EXPASS          shift and go to state 70

  ! LBRACK          [ reduce using rule 31 (expr -> variable .) ]

    asig                           shift and go to state 63

state 24

    (33) expr -> array .

    END             reduce using rule 33 (expr -> array .)
    IF              reduce using rule 33 (expr -> array .)
    WHILE           reduce using rule 33 (expr -> array .)
    BEGIN           reduce using rule 33 (expr -> array .)
    FOR             reduce using rule 33 (expr -> array .)
    NUMBER          reduce using rule 33 (expr -> array .)
    LOCAL           reduce using rule 33 (expr -> array .)
    GLOBAL          reduce using rule 33 (expr -> array .)
    CONSTANTS       reduce using rule 33 (expr -> array .)
    INSTANCEVAR     reduce using rule 33 (expr -> array .)
    CLASSVAR        reduce using rule 33 (expr -> array .)
    LBRACK          reduce using rule 33 (expr -> array .)
    NEWLINE         reduce using rule 33 (expr -> array .)
    ELSE            reduce using rule 33 (expr -> array .)
    ELSIF           reduce using rule 33 (expr -> array .)


state 25

    (34) expr -> slice .

    END             reduce using rule 34 (expr -> slice .)
    IF              reduce using rule 34 (expr -> slice .)
    WHILE           reduce using rule 34 (expr -> slice .)
    BEGIN           reduce using rule 34 (expr -> slice .)
    FOR             reduce using rule 34 (expr -> slice .)
    NUMBER          reduce using rule 34 (expr -> slice .)
    LOCAL           reduce using rule 34 (expr -> slice .)
    GLOBAL          reduce using rule 34 (expr -> slice .)
    CONSTANTS       reduce using rule 34 (expr -> slice .)
    INSTANCEVAR     reduce using rule 34 (expr -> slice .)
    CLASSVAR        reduce using rule 34 (expr -> slice .)
    LBRACK          reduce using rule 34 (expr -> slice .)
    NEWLINE         reduce using rule 34 (expr -> slice .)
    ELSE            reduce using rule 34 (expr -> slice .)
    ELSIF           reduce using rule 34 (expr -> slice .)


state 26

    (35) expr -> index .

    END             reduce using rule 35 (expr -> index .)
    IF              reduce using rule 35 (expr -> index .)
    WHILE           reduce using rule 35 (expr -> index .)
    BEGIN           reduce using rule 35 (expr -> index .)
    FOR             reduce using rule 35 (expr -> index .)
    NUMBER          reduce using rule 35 (expr -> index .)
    LOCAL           reduce using rule 35 (expr -> index .)
    GLOBAL          reduce using rule 35 (expr -> index .)
    CONSTANTS       reduce using rule 35 (expr -> index .)
    INSTANCEVAR     reduce using rule 35 (expr -> index .)
    CLASSVAR        reduce using rule 35 (expr -> index .)
    LBRACK          reduce using rule 35 (expr -> index .)
    NEWLINE         reduce using rule 35 (expr -> index .)
    ELSE            reduce using rule 35 (expr -> index .)
    ELSIF           reduce using rule 35 (expr -> index .)


state 27

    (60) if -> IF . logical expr END
    (61) if -> IF . logical THEN expr END
    (62) if -> IF . logical
    (63) if -> IF . logical THEN
    (11) logical -> . term comparison term
    (12) logical -> . term comparison logical
    (13) logical -> . variable comparison term
    (14) logical -> . variable comparison BOOLEAN
    (15) logical -> . logical logcompare logical
    (16) logical -> . BOOLEAN
    (39) term -> . NUMBER
    (17) variable -> . LOCAL
    (18) variable -> . GLOBAL
    (19) variable -> . CONSTANTS
    (20) variable -> . INSTANCEVAR
    (21) variable -> . CLASSVAR

    BOOLEAN         shift and go to state 7
    NUMBER          shift and go to state 8
    LOCAL           shift and go to state 9
    GLOBAL          shift and go to state 10
    CONSTANTS       shift and go to state 11
    INSTANCEVAR     shift and go to state 12
    CLASSVAR        shift and go to state 13

    logical                        shift and go to state 71
    term                           shift and go to state 5
    variable                       shift and go to state 6

state 28

    (83) for -> FOR . iterador IN expresiones code END
    (84) for -> FOR . iterador IN expresiones DO code END
    (85) for -> FOR . iterador IN array code END
    (86) for -> FOR . iterador IN array DO code END
    (80) iterador -> . variable
    (81) iterador -> . variable , variable
    (17) variable -> . LOCAL
    (18) variable -> . GLOBAL
    (19) variable -> . CONSTANTS
    (20) variable -> . INSTANCEVAR
    (21) variable -> . CLASSVAR

    LOCAL           shift and go to state 9
    GLOBAL          shift and go to state 10
    CONSTANTS       shift and go to state 11
    INSTANCEVAR     shift and go to state 12
    CLASSVAR        shift and go to state 13

    iterador                       shift and go to state 72
    variable                       shift and go to state 73

state 29

    (87) array -> LBRACK . defarray RBRACK
    (88) defarray -> . NUMBER
    (89) defarray -> . NUMBER COMA defarray
    (90) defarray -> . STRING
    (91) defarray -> . STRING COMA defarray
    (92) defarray -> . INT
    (93) defarray -> . INT COMA defarray
    (94) defarray -> . FLOAT
    (95) defarray -> . FLOAT COMA defarray
    (96) defarray -> . BOOLEAN
    (97) defarray -> . BOOLEAN COMA defarray

    NUMBER          shift and go to state 75
    STRING          shift and go to state 76
    INT             shift and go to state 77
    FLOAT           shift and go to state 78
    BOOLEAN         shift and go to state 79

    defarray                       shift and go to state 74

state 30

    (1) while -> WHILE logical code . END
    (79) code -> code . code
    (72) code -> . expr
    (73) code -> . if
    (74) code -> . while
    (75) code -> . expresiones
    (76) code -> . for
    (77) code -> . assign
    (78) code -> . math
    (79) code -> . code code
    (29) expr -> . math
    (30) expr -> . term
    (31) expr -> . variable
    (32) expr -> . assign
    (33) expr -> . array
    (34) expr -> . slice
    (35) expr -> . index
    (60) if -> . IF logical expr END
    (61) if -> . IF logical THEN expr END
    (62) if -> . IF logical
    (63) if -> . IF logical THEN
    (64) if -> . if else
    (65) if -> . if elsif END
    (1) while -> . WHILE logical code END
    (2) while -> . WHILE logical DO salto code salto END
    (3) while -> . WHILE logical DOBLEPOINT salto code salto END
    (4) while -> . BEGIN code END WHILE logical
    (82) expresiones -> . term DOUBLESECUENCEPOINT term
    (83) for -> . FOR iterador IN expresiones code END
    (84) for -> . FOR iterador IN expresiones DO code END
    (85) for -> . FOR iterador IN array code END
    (86) for -> . FOR iterador IN array DO code END
    (5) assign -> . variable ASS expr
    (6) assign -> . variable ASS sexpr
    (7) assign -> . variable ASS array
    (8) math -> . term arith term
    (9) math -> . term arith math
    (10) math -> . variable asig term
    (39) term -> . NUMBER
    (17) variable -> . LOCAL
    (18) variable -> . GLOBAL
    (19) variable -> . CONSTANTS
    (20) variable -> . INSTANCEVAR
    (21) variable -> . CLASSVAR
    (87) array -> . LBRACK defarray RBRACK
    (99) slice -> . variable LBRACK defslice RBRACK
    (98) index -> . variable LBRACK INT RBRACK

    END             shift and go to state 80
    IF              shift and go to state 27
    WHILE           shift and go to state 2
    BEGIN           shift and go to state 3
    FOR             shift and go to state 28
    NUMBER          shift and go to state 8
    LOCAL           shift and go to state 9
    GLOBAL          shift and go to state 10
    CONSTANTS       shift and go to state 11
    INSTANCEVAR     shift and go to state 12
    CLASSVAR        shift and go to state 13
    LBRACK          shift and go to state 29

    code                           shift and go to state 48
    expr                           shift and go to state 15
    if                             shift and go to state 16
    while                          shift and go to state 17
    expresiones                    shift and go to state 18
    for                            shift and go to state 19
    assign                         shift and go to state 20
    math                           shift and go to state 21
    term                           shift and go to state 22
    variable                       shift and go to state 23
    array                          shift and go to state 24
    slice                          shift and go to state 25
    index                          shift and go to state 26

state 31

    (2) while -> WHILE logical DO . salto code salto END
    (59) salto -> . NEWLINE

    NEWLINE         shift and go to state 82

    salto                          shift and go to state 81

state 32

    (3) while -> WHILE logical DOBLEPOINT . salto code salto END
    (59) salto -> . NEWLINE

    NEWLINE         shift and go to state 82

    salto                          shift and go to state 83

state 33

    (15) logical -> logical logcompare . logical
    (11) logical -> . term comparison term
    (12) logical -> . term comparison logical
    (13) logical -> . variable comparison term
    (14) logical -> . variable comparison BOOLEAN
    (15) logical -> . logical logcompare logical
    (16) logical -> . BOOLEAN
    (39) term -> . NUMBER
    (17) variable -> . LOCAL
    (18) variable -> . GLOBAL
    (19) variable -> . CONSTANTS
    (20) variable -> . INSTANCEVAR
    (21) variable -> . CLASSVAR

    BOOLEAN         shift and go to state 7
    NUMBER          shift and go to state 8
    LOCAL           shift and go to state 9
    GLOBAL          shift and go to state 10
    CONSTANTS       shift and go to state 11
    INSTANCEVAR     shift and go to state 12
    CLASSVAR        shift and go to state 13

    logical                        shift and go to state 84
    term                           shift and go to state 5
    variable                       shift and go to state 6

state 34

    (53) logcompare -> ANDLOG .

    BOOLEAN         reduce using rule 53 (logcompare -> ANDLOG .)
    NUMBER          reduce using rule 53 (logcompare -> ANDLOG .)
    LOCAL           reduce using rule 53 (logcompare -> ANDLOG .)
    GLOBAL          reduce using rule 53 (logcompare -> ANDLOG .)
    CONSTANTS       reduce using rule 53 (logcompare -> ANDLOG .)
    INSTANCEVAR     reduce using rule 53 (logcompare -> ANDLOG .)
    CLASSVAR        reduce using rule 53 (logcompare -> ANDLOG .)


state 35

    (54) logcompare -> ORLOG .

    BOOLEAN         reduce using rule 54 (logcompare -> ORLOG .)
    NUMBER          reduce using rule 54 (logcompare -> ORLOG .)
    LOCAL           reduce using rule 54 (logcompare -> ORLOG .)
    GLOBAL          reduce using rule 54 (logcompare -> ORLOG .)
    CONSTANTS       reduce using rule 54 (logcompare -> ORLOG .)
    INSTANCEVAR     reduce using rule 54 (logcompare -> ORLOG .)
    CLASSVAR        reduce using rule 54 (logcompare -> ORLOG .)


state 36

    (55) logcompare -> NOTLOG .

    BOOLEAN         reduce using rule 55 (logcompare -> NOTLOG .)
    NUMBER          reduce using rule 55 (logcompare -> NOTLOG .)
    LOCAL           reduce using rule 55 (logcompare -> NOTLOG .)
    GLOBAL          reduce using rule 55 (logcompare -> NOTLOG .)
    CONSTANTS       reduce using rule 55 (logcompare -> NOTLOG .)
    INSTANCEVAR     reduce using rule 55 (logcompare -> NOTLOG .)
    CLASSVAR        reduce using rule 55 (logcompare -> NOTLOG .)


state 37

    (56) logcompare -> AND .

    BOOLEAN         reduce using rule 56 (logcompare -> AND .)
    NUMBER          reduce using rule 56 (logcompare -> AND .)
    LOCAL           reduce using rule 56 (logcompare -> AND .)
    GLOBAL          reduce using rule 56 (logcompare -> AND .)
    CONSTANTS       reduce using rule 56 (logcompare -> AND .)
    INSTANCEVAR     reduce using rule 56 (logcompare -> AND .)
    CLASSVAR        reduce using rule 56 (logcompare -> AND .)


state 38

    (57) logcompare -> OR .

    BOOLEAN         reduce using rule 57 (logcompare -> OR .)
    NUMBER          reduce using rule 57 (logcompare -> OR .)
    LOCAL           reduce using rule 57 (logcompare -> OR .)
    GLOBAL          reduce using rule 57 (logcompare -> OR .)
    CONSTANTS       reduce using rule 57 (logcompare -> OR .)
    INSTANCEVAR     reduce using rule 57 (logcompare -> OR .)
    CLASSVAR        reduce using rule 57 (logcompare -> OR .)


state 39

    (58) logcompare -> NOT .

    BOOLEAN         reduce using rule 58 (logcompare -> NOT .)
    NUMBER          reduce using rule 58 (logcompare -> NOT .)
    LOCAL           reduce using rule 58 (logcompare -> NOT .)
    GLOBAL          reduce using rule 58 (logcompare -> NOT .)
    CONSTANTS       reduce using rule 58 (logcompare -> NOT .)
    INSTANCEVAR     reduce using rule 58 (logcompare -> NOT .)
    CLASSVAR        reduce using rule 58 (logcompare -> NOT .)


state 40

    (11) logical -> term comparison . term
    (12) logical -> term comparison . logical
    (39) term -> . NUMBER
    (11) logical -> . term comparison term
    (12) logical -> . term comparison logical
    (13) logical -> . variable comparison term
    (14) logical -> . variable comparison BOOLEAN
    (15) logical -> . logical logcompare logical
    (16) logical -> . BOOLEAN
    (17) variable -> . LOCAL
    (18) variable -> . GLOBAL
    (19) variable -> . CONSTANTS
    (20) variable -> . INSTANCEVAR
    (21) variable -> . CLASSVAR

    NUMBER          shift and go to state 8
    BOOLEAN         shift and go to state 7
    LOCAL           shift and go to state 9
    GLOBAL          shift and go to state 10
    CONSTANTS       shift and go to state 11
    INSTANCEVAR     shift and go to state 12
    CLASSVAR        shift and go to state 13

    term                           shift and go to state 85
    logical                        shift and go to state 86
    variable                       shift and go to state 6

state 41

    (47) comparison -> EQUAL .

    NUMBER          reduce using rule 47 (comparison -> EQUAL .)
    BOOLEAN         reduce using rule 47 (comparison -> EQUAL .)
    LOCAL           reduce using rule 47 (comparison -> EQUAL .)
    GLOBAL          reduce using rule 47 (comparison -> EQUAL .)
    CONSTANTS       reduce using rule 47 (comparison -> EQUAL .)
    INSTANCEVAR     reduce using rule 47 (comparison -> EQUAL .)
    CLASSVAR        reduce using rule 47 (comparison -> EQUAL .)


state 42

    (48) comparison -> NOTEQ .

    NUMBER          reduce using rule 48 (comparison -> NOTEQ .)
    BOOLEAN         reduce using rule 48 (comparison -> NOTEQ .)
    LOCAL           reduce using rule 48 (comparison -> NOTEQ .)
    GLOBAL          reduce using rule 48 (comparison -> NOTEQ .)
    CONSTANTS       reduce using rule 48 (comparison -> NOTEQ .)
    INSTANCEVAR     reduce using rule 48 (comparison -> NOTEQ .)
    CLASSVAR        reduce using rule 48 (comparison -> NOTEQ .)


state 43

    (49) comparison -> GREATHER .

    NUMBER          reduce using rule 49 (comparison -> GREATHER .)
    BOOLEAN         reduce using rule 49 (comparison -> GREATHER .)
    LOCAL           reduce using rule 49 (comparison -> GREATHER .)
    GLOBAL          reduce using rule 49 (comparison -> GREATHER .)
    CONSTANTS       reduce using rule 49 (comparison -> GREATHER .)
    INSTANCEVAR     reduce using rule 49 (comparison -> GREATHER .)
    CLASSVAR        reduce using rule 49 (comparison -> GREATHER .)


state 44

    (50) comparison -> LOWER .

    NUMBER          reduce using rule 50 (comparison -> LOWER .)
    BOOLEAN         reduce using rule 50 (comparison -> LOWER .)
    LOCAL           reduce using rule 50 (comparison -> LOWER .)
    GLOBAL          reduce using rule 50 (comparison -> LOWER .)
    CONSTANTS       reduce using rule 50 (comparison -> LOWER .)
    INSTANCEVAR     reduce using rule 50 (comparison -> LOWER .)
    CLASSVAR        reduce using rule 50 (comparison -> LOWER .)


state 45

    (51) comparison -> GREATHEREQ .

    NUMBER          reduce using rule 51 (comparison -> GREATHEREQ .)
    BOOLEAN         reduce using rule 51 (comparison -> GREATHEREQ .)
    LOCAL           reduce using rule 51 (comparison -> GREATHEREQ .)
    GLOBAL          reduce using rule 51 (comparison -> GREATHEREQ .)
    CONSTANTS       reduce using rule 51 (comparison -> GREATHEREQ .)
    INSTANCEVAR     reduce using rule 51 (comparison -> GREATHEREQ .)
    CLASSVAR        reduce using rule 51 (comparison -> GREATHEREQ .)


state 46

    (52) comparison -> LOWEREQ .

    NUMBER          reduce using rule 52 (comparison -> LOWEREQ .)
    BOOLEAN         reduce using rule 52 (comparison -> LOWEREQ .)
    LOCAL           reduce using rule 52 (comparison -> LOWEREQ .)
    GLOBAL          reduce using rule 52 (comparison -> LOWEREQ .)
    CONSTANTS       reduce using rule 52 (comparison -> LOWEREQ .)
    INSTANCEVAR     reduce using rule 52 (comparison -> LOWEREQ .)
    CLASSVAR        reduce using rule 52 (comparison -> LOWEREQ .)


state 47

    (13) logical -> variable comparison . term
    (14) logical -> variable comparison . BOOLEAN
    (39) term -> . NUMBER

    BOOLEAN         shift and go to state 88
    NUMBER          shift and go to state 8

    term                           shift and go to state 87

state 48

    (79) code -> code code .
    (79) code -> code . code
    (72) code -> . expr
    (73) code -> . if
    (74) code -> . while
    (75) code -> . expresiones
    (76) code -> . for
    (77) code -> . assign
    (78) code -> . math
    (79) code -> . code code
    (29) expr -> . math
    (30) expr -> . term
    (31) expr -> . variable
    (32) expr -> . assign
    (33) expr -> . array
    (34) expr -> . slice
    (35) expr -> . index
    (60) if -> . IF logical expr END
    (61) if -> . IF logical THEN expr END
    (62) if -> . IF logical
    (63) if -> . IF logical THEN
    (64) if -> . if else
    (65) if -> . if elsif END
    (1) while -> . WHILE logical code END
    (2) while -> . WHILE logical DO salto code salto END
    (3) while -> . WHILE logical DOBLEPOINT salto code salto END
    (4) while -> . BEGIN code END WHILE logical
    (82) expresiones -> . term DOUBLESECUENCEPOINT term
    (83) for -> . FOR iterador IN expresiones code END
    (84) for -> . FOR iterador IN expresiones DO code END
    (85) for -> . FOR iterador IN array code END
    (86) for -> . FOR iterador IN array DO code END
    (5) assign -> . variable ASS expr
    (6) assign -> . variable ASS sexpr
    (7) assign -> . variable ASS array
    (8) math -> . term arith term
    (9) math -> . term arith math
    (10) math -> . variable asig term
    (39) term -> . NUMBER
    (17) variable -> . LOCAL
    (18) variable -> . GLOBAL
    (19) variable -> . CONSTANTS
    (20) variable -> . INSTANCEVAR
    (21) variable -> . CLASSVAR
    (87) array -> . LBRACK defarray RBRACK
    (99) slice -> . variable LBRACK defslice RBRACK
    (98) index -> . variable LBRACK INT RBRACK

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for LOCAL resolved as shift
  ! shift/reduce conflict for GLOBAL resolved as shift
  ! shift/reduce conflict for CONSTANTS resolved as shift
  ! shift/reduce conflict for INSTANCEVAR resolved as shift
  ! shift/reduce conflict for CLASSVAR resolved as shift
  ! shift/reduce conflict for LBRACK resolved as shift
    END             reduce using rule 79 (code -> code code .)
    NEWLINE         reduce using rule 79 (code -> code code .)
    IF              shift and go to state 27
    WHILE           shift and go to state 2
    BEGIN           shift and go to state 3
    FOR             shift and go to state 28
    NUMBER          shift and go to state 8
    LOCAL           shift and go to state 9
    GLOBAL          shift and go to state 10
    CONSTANTS       shift and go to state 11
    INSTANCEVAR     shift and go to state 12
    CLASSVAR        shift and go to state 13
    LBRACK          shift and go to state 29

  ! IF              [ reduce using rule 79 (code -> code code .) ]
  ! WHILE           [ reduce using rule 79 (code -> code code .) ]
  ! BEGIN           [ reduce using rule 79 (code -> code code .) ]
  ! FOR             [ reduce using rule 79 (code -> code code .) ]
  ! NUMBER          [ reduce using rule 79 (code -> code code .) ]
  ! LOCAL           [ reduce using rule 79 (code -> code code .) ]
  ! GLOBAL          [ reduce using rule 79 (code -> code code .) ]
  ! CONSTANTS       [ reduce using rule 79 (code -> code code .) ]
  ! INSTANCEVAR     [ reduce using rule 79 (code -> code code .) ]
  ! CLASSVAR        [ reduce using rule 79 (code -> code code .) ]
  ! LBRACK          [ reduce using rule 79 (code -> code code .) ]

    code                           shift and go to state 48
    expr                           shift and go to state 15
    if                             shift and go to state 16
    while                          shift and go to state 17
    expresiones                    shift and go to state 18
    for                            shift and go to state 19
    assign                         shift and go to state 20
    math                           shift and go to state 21
    term                           shift and go to state 22
    variable                       shift and go to state 23
    array                          shift and go to state 24
    slice                          shift and go to state 25
    index                          shift and go to state 26

state 49

    (4) while -> BEGIN code END . WHILE logical

    WHILE           shift and go to state 89


state 50

    (64) if -> if else .

    ELSE            reduce using rule 64 (if -> if else .)
    ELSIF           reduce using rule 64 (if -> if else .)
    END             reduce using rule 64 (if -> if else .)
    IF              reduce using rule 64 (if -> if else .)
    WHILE           reduce using rule 64 (if -> if else .)
    BEGIN           reduce using rule 64 (if -> if else .)
    FOR             reduce using rule 64 (if -> if else .)
    NUMBER          reduce using rule 64 (if -> if else .)
    LOCAL           reduce using rule 64 (if -> if else .)
    GLOBAL          reduce using rule 64 (if -> if else .)
    CONSTANTS       reduce using rule 64 (if -> if else .)
    INSTANCEVAR     reduce using rule 64 (if -> if else .)
    CLASSVAR        reduce using rule 64 (if -> if else .)
    LBRACK          reduce using rule 64 (if -> if else .)
    NEWLINE         reduce using rule 64 (if -> if else .)


state 51

    (65) if -> if elsif . END

    END             shift and go to state 90


state 52

    (66) else -> ELSE . expr END
    (29) expr -> . math
    (30) expr -> . term
    (31) expr -> . variable
    (32) expr -> . assign
    (33) expr -> . array
    (34) expr -> . slice
    (35) expr -> . index
    (8) math -> . term arith term
    (9) math -> . term arith math
    (10) math -> . variable asig term
    (39) term -> . NUMBER
    (17) variable -> . LOCAL
    (18) variable -> . GLOBAL
    (19) variable -> . CONSTANTS
    (20) variable -> . INSTANCEVAR
    (21) variable -> . CLASSVAR
    (5) assign -> . variable ASS expr
    (6) assign -> . variable ASS sexpr
    (7) assign -> . variable ASS array
    (87) array -> . LBRACK defarray RBRACK
    (99) slice -> . variable LBRACK defslice RBRACK
    (98) index -> . variable LBRACK INT RBRACK

    NUMBER          shift and go to state 8
    LOCAL           shift and go to state 9
    GLOBAL          shift and go to state 10
    CONSTANTS       shift and go to state 11
    INSTANCEVAR     shift and go to state 12
    CLASSVAR        shift and go to state 13
    LBRACK          shift and go to state 29

    expr                           shift and go to state 91
    math                           shift and go to state 92
    term                           shift and go to state 93
    variable                       shift and go to state 94
    assign                         shift and go to state 95
    array                          shift and go to state 24
    slice                          shift and go to state 25
    index                          shift and go to state 26

state 53

    (67) elsif -> ELSIF . logical final
    (11) logical -> . term comparison term
    (12) logical -> . term comparison logical
    (13) logical -> . variable comparison term
    (14) logical -> . variable comparison BOOLEAN
    (15) logical -> . logical logcompare logical
    (16) logical -> . BOOLEAN
    (39) term -> . NUMBER
    (17) variable -> . LOCAL
    (18) variable -> . GLOBAL
    (19) variable -> . CONSTANTS
    (20) variable -> . INSTANCEVAR
    (21) variable -> . CLASSVAR

    BOOLEAN         shift and go to state 7
    NUMBER          shift and go to state 8
    LOCAL           shift and go to state 9
    GLOBAL          shift and go to state 10
    CONSTANTS       shift and go to state 11
    INSTANCEVAR     shift and go to state 12
    CLASSVAR        shift and go to state 13

    logical                        shift and go to state 96
    term                           shift and go to state 5
    variable                       shift and go to state 6

state 54

    (82) expresiones -> term DOUBLESECUENCEPOINT . term
    (39) term -> . NUMBER

    NUMBER          shift and go to state 8

    term                           shift and go to state 97

state 55

    (8) math -> term arith . term
    (9) math -> term arith . math
    (39) term -> . NUMBER
    (8) math -> . term arith term
    (9) math -> . term arith math
    (10) math -> . variable asig term
    (17) variable -> . LOCAL
    (18) variable -> . GLOBAL
    (19) variable -> . CONSTANTS
    (20) variable -> . INSTANCEVAR
    (21) variable -> . CLASSVAR

    NUMBER          shift and go to state 8
    LOCAL           shift and go to state 9
    GLOBAL          shift and go to state 10
    CONSTANTS       shift and go to state 11
    INSTANCEVAR     shift and go to state 12
    CLASSVAR        shift and go to state 13

    term                           shift and go to state 98
    math                           shift and go to state 99
    variable                       shift and go to state 100

state 56

    (41) arith -> EXP .

    NUMBER          reduce using rule 41 (arith -> EXP .)
    LOCAL           reduce using rule 41 (arith -> EXP .)
    GLOBAL          reduce using rule 41 (arith -> EXP .)
    CONSTANTS       reduce using rule 41 (arith -> EXP .)
    INSTANCEVAR     reduce using rule 41 (arith -> EXP .)
    CLASSVAR        reduce using rule 41 (arith -> EXP .)


state 57

    (42) arith -> MUL .

    NUMBER          reduce using rule 42 (arith -> MUL .)
    LOCAL           reduce using rule 42 (arith -> MUL .)
    GLOBAL          reduce using rule 42 (arith -> MUL .)
    CONSTANTS       reduce using rule 42 (arith -> MUL .)
    INSTANCEVAR     reduce using rule 42 (arith -> MUL .)
    CLASSVAR        reduce using rule 42 (arith -> MUL .)


state 58

    (43) arith -> DIV .

    NUMBER          reduce using rule 43 (arith -> DIV .)
    LOCAL           reduce using rule 43 (arith -> DIV .)
    GLOBAL          reduce using rule 43 (arith -> DIV .)
    CONSTANTS       reduce using rule 43 (arith -> DIV .)
    INSTANCEVAR     reduce using rule 43 (arith -> DIV .)
    CLASSVAR        reduce using rule 43 (arith -> DIV .)


state 59

    (44) arith -> MOD .

    NUMBER          reduce using rule 44 (arith -> MOD .)
    LOCAL           reduce using rule 44 (arith -> MOD .)
    GLOBAL          reduce using rule 44 (arith -> MOD .)
    CONSTANTS       reduce using rule 44 (arith -> MOD .)
    INSTANCEVAR     reduce using rule 44 (arith -> MOD .)
    CLASSVAR        reduce using rule 44 (arith -> MOD .)


state 60

    (45) arith -> ADD .

    NUMBER          reduce using rule 45 (arith -> ADD .)
    LOCAL           reduce using rule 45 (arith -> ADD .)
    GLOBAL          reduce using rule 45 (arith -> ADD .)
    CONSTANTS       reduce using rule 45 (arith -> ADD .)
    INSTANCEVAR     reduce using rule 45 (arith -> ADD .)
    CLASSVAR        reduce using rule 45 (arith -> ADD .)


state 61

    (46) arith -> SUB .

    NUMBER          reduce using rule 46 (arith -> SUB .)
    LOCAL           reduce using rule 46 (arith -> SUB .)
    GLOBAL          reduce using rule 46 (arith -> SUB .)
    CONSTANTS       reduce using rule 46 (arith -> SUB .)
    INSTANCEVAR     reduce using rule 46 (arith -> SUB .)
    CLASSVAR        reduce using rule 46 (arith -> SUB .)


state 62

    (5) assign -> variable ASS . expr
    (6) assign -> variable ASS . sexpr
    (7) assign -> variable ASS . array
    (22) asig -> ASS .
    (29) expr -> . math
    (30) expr -> . term
    (31) expr -> . variable
    (32) expr -> . assign
    (33) expr -> . array
    (34) expr -> . slice
    (35) expr -> . index
    (36) sexpr -> . sterm MUL term
    (37) sexpr -> . sterm ADD sexpr
    (38) sexpr -> . sterm
    (87) array -> . LBRACK defarray RBRACK
    (8) math -> . term arith term
    (9) math -> . term arith math
    (10) math -> . variable asig term
    (39) term -> . NUMBER
    (17) variable -> . LOCAL
    (18) variable -> . GLOBAL
    (19) variable -> . CONSTANTS
    (20) variable -> . INSTANCEVAR
    (21) variable -> . CLASSVAR
    (5) assign -> . variable ASS expr
    (6) assign -> . variable ASS sexpr
    (7) assign -> . variable ASS array
    (99) slice -> . variable LBRACK defslice RBRACK
    (98) index -> . variable LBRACK INT RBRACK
    (40) sterm -> . STRING

  ! shift/reduce conflict for NUMBER resolved as shift
    LBRACK          shift and go to state 29
    NUMBER          shift and go to state 8
    LOCAL           shift and go to state 9
    GLOBAL          shift and go to state 10
    CONSTANTS       shift and go to state 11
    INSTANCEVAR     shift and go to state 12
    CLASSVAR        shift and go to state 13
    STRING          shift and go to state 105

  ! NUMBER          [ reduce using rule 22 (asig -> ASS .) ]

    variable                       shift and go to state 94
    expr                           shift and go to state 101
    sexpr                          shift and go to state 102
    array                          shift and go to state 103
    math                           shift and go to state 92
    term                           shift and go to state 93
    assign                         shift and go to state 95
    slice                          shift and go to state 25
    index                          shift and go to state 26
    sterm                          shift and go to state 104

state 63

    (10) math -> variable asig . term
    (39) term -> . NUMBER

    NUMBER          shift and go to state 8

    term                           shift and go to state 106

state 64

    (99) slice -> variable LBRACK . defslice RBRACK
    (98) index -> variable LBRACK . INT RBRACK
    (100) defslice -> . INT DOBLEPOINT INT
    (101) defslice -> . INT DOBLEPOINT
    (102) defslice -> . DOBLEPOINT INT

    INT             shift and go to state 108
    DOBLEPOINT      shift and go to state 109

    defslice                       shift and go to state 107

state 65

    (23) asig -> ADDASS .

    NUMBER          reduce using rule 23 (asig -> ADDASS .)


state 66

    (24) asig -> SUBASS .

    NUMBER          reduce using rule 24 (asig -> SUBASS .)


state 67

    (25) asig -> MULASS .

    NUMBER          reduce using rule 25 (asig -> MULASS .)


state 68

    (26) asig -> DIVASS .

    NUMBER          reduce using rule 26 (asig -> DIVASS .)


state 69

    (27) asig -> MODASS .

    NUMBER          reduce using rule 27 (asig -> MODASS .)


state 70

    (28) asig -> EXPASS .

    NUMBER          reduce using rule 28 (asig -> EXPASS .)


state 71

    (60) if -> IF logical . expr END
    (61) if -> IF logical . THEN expr END
    (62) if -> IF logical .
    (63) if -> IF logical . THEN
    (15) logical -> logical . logcompare logical
    (29) expr -> . math
    (30) expr -> . term
    (31) expr -> . variable
    (32) expr -> . assign
    (33) expr -> . array
    (34) expr -> . slice
    (35) expr -> . index
    (53) logcompare -> . ANDLOG
    (54) logcompare -> . ORLOG
    (55) logcompare -> . NOTLOG
    (56) logcompare -> . AND
    (57) logcompare -> . OR
    (58) logcompare -> . NOT
    (8) math -> . term arith term
    (9) math -> . term arith math
    (10) math -> . variable asig term
    (39) term -> . NUMBER
    (17) variable -> . LOCAL
    (18) variable -> . GLOBAL
    (19) variable -> . CONSTANTS
    (20) variable -> . INSTANCEVAR
    (21) variable -> . CLASSVAR
    (5) assign -> . variable ASS expr
    (6) assign -> . variable ASS sexpr
    (7) assign -> . variable ASS array
    (87) array -> . LBRACK defarray RBRACK
    (99) slice -> . variable LBRACK defslice RBRACK
    (98) index -> . variable LBRACK INT RBRACK

  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for LOCAL resolved as shift
  ! shift/reduce conflict for GLOBAL resolved as shift
  ! shift/reduce conflict for CONSTANTS resolved as shift
  ! shift/reduce conflict for INSTANCEVAR resolved as shift
  ! shift/reduce conflict for CLASSVAR resolved as shift
  ! shift/reduce conflict for LBRACK resolved as shift
    THEN            shift and go to state 111
    ELSE            reduce using rule 62 (if -> IF logical .)
    ELSIF           reduce using rule 62 (if -> IF logical .)
    END             reduce using rule 62 (if -> IF logical .)
    IF              reduce using rule 62 (if -> IF logical .)
    WHILE           reduce using rule 62 (if -> IF logical .)
    BEGIN           reduce using rule 62 (if -> IF logical .)
    FOR             reduce using rule 62 (if -> IF logical .)
    NEWLINE         reduce using rule 62 (if -> IF logical .)
    ANDLOG          shift and go to state 34
    ORLOG           shift and go to state 35
    NOTLOG          shift and go to state 36
    AND             shift and go to state 37
    OR              shift and go to state 38
    NOT             shift and go to state 39
    NUMBER          shift and go to state 8
    LOCAL           shift and go to state 9
    GLOBAL          shift and go to state 10
    CONSTANTS       shift and go to state 11
    INSTANCEVAR     shift and go to state 12
    CLASSVAR        shift and go to state 13
    LBRACK          shift and go to state 29

  ! NUMBER          [ reduce using rule 62 (if -> IF logical .) ]
  ! LOCAL           [ reduce using rule 62 (if -> IF logical .) ]
  ! GLOBAL          [ reduce using rule 62 (if -> IF logical .) ]
  ! CONSTANTS       [ reduce using rule 62 (if -> IF logical .) ]
  ! INSTANCEVAR     [ reduce using rule 62 (if -> IF logical .) ]
  ! CLASSVAR        [ reduce using rule 62 (if -> IF logical .) ]
  ! LBRACK          [ reduce using rule 62 (if -> IF logical .) ]

    expr                           shift and go to state 110
    logcompare                     shift and go to state 33
    math                           shift and go to state 92
    term                           shift and go to state 93
    variable                       shift and go to state 94
    assign                         shift and go to state 95
    array                          shift and go to state 24
    slice                          shift and go to state 25
    index                          shift and go to state 26

state 72

    (83) for -> FOR iterador . IN expresiones code END
    (84) for -> FOR iterador . IN expresiones DO code END
    (85) for -> FOR iterador . IN array code END
    (86) for -> FOR iterador . IN array DO code END

    IN              shift and go to state 112


state 73

    (80) iterador -> variable .
    (81) iterador -> variable . , variable

    IN              reduce using rule 80 (iterador -> variable .)
    ,               shift and go to state 113


state 74

    (87) array -> LBRACK defarray . RBRACK

    RBRACK          shift and go to state 114


state 75

    (88) defarray -> NUMBER .
    (89) defarray -> NUMBER . COMA defarray

    RBRACK          reduce using rule 88 (defarray -> NUMBER .)
    COMA            shift and go to state 115


state 76

    (90) defarray -> STRING .
    (91) defarray -> STRING . COMA defarray

    RBRACK          reduce using rule 90 (defarray -> STRING .)
    COMA            shift and go to state 116


state 77

    (92) defarray -> INT .
    (93) defarray -> INT . COMA defarray

    RBRACK          reduce using rule 92 (defarray -> INT .)
    COMA            shift and go to state 117


state 78

    (94) defarray -> FLOAT .
    (95) defarray -> FLOAT . COMA defarray

    RBRACK          reduce using rule 94 (defarray -> FLOAT .)
    COMA            shift and go to state 118


state 79

    (96) defarray -> BOOLEAN .
    (97) defarray -> BOOLEAN . COMA defarray

    RBRACK          reduce using rule 96 (defarray -> BOOLEAN .)
    COMA            shift and go to state 119


state 80

    (1) while -> WHILE logical code END .

    $end            reduce using rule 1 (while -> WHILE logical code END .)
    END             reduce using rule 1 (while -> WHILE logical code END .)
    IF              reduce using rule 1 (while -> WHILE logical code END .)
    WHILE           reduce using rule 1 (while -> WHILE logical code END .)
    BEGIN           reduce using rule 1 (while -> WHILE logical code END .)
    FOR             reduce using rule 1 (while -> WHILE logical code END .)
    NUMBER          reduce using rule 1 (while -> WHILE logical code END .)
    LOCAL           reduce using rule 1 (while -> WHILE logical code END .)
    GLOBAL          reduce using rule 1 (while -> WHILE logical code END .)
    CONSTANTS       reduce using rule 1 (while -> WHILE logical code END .)
    INSTANCEVAR     reduce using rule 1 (while -> WHILE logical code END .)
    CLASSVAR        reduce using rule 1 (while -> WHILE logical code END .)
    LBRACK          reduce using rule 1 (while -> WHILE logical code END .)
    NEWLINE         reduce using rule 1 (while -> WHILE logical code END .)


state 81

    (2) while -> WHILE logical DO salto . code salto END
    (72) code -> . expr
    (73) code -> . if
    (74) code -> . while
    (75) code -> . expresiones
    (76) code -> . for
    (77) code -> . assign
    (78) code -> . math
    (79) code -> . code code
    (29) expr -> . math
    (30) expr -> . term
    (31) expr -> . variable
    (32) expr -> . assign
    (33) expr -> . array
    (34) expr -> . slice
    (35) expr -> . index
    (60) if -> . IF logical expr END
    (61) if -> . IF logical THEN expr END
    (62) if -> . IF logical
    (63) if -> . IF logical THEN
    (64) if -> . if else
    (65) if -> . if elsif END
    (1) while -> . WHILE logical code END
    (2) while -> . WHILE logical DO salto code salto END
    (3) while -> . WHILE logical DOBLEPOINT salto code salto END
    (4) while -> . BEGIN code END WHILE logical
    (82) expresiones -> . term DOUBLESECUENCEPOINT term
    (83) for -> . FOR iterador IN expresiones code END
    (84) for -> . FOR iterador IN expresiones DO code END
    (85) for -> . FOR iterador IN array code END
    (86) for -> . FOR iterador IN array DO code END
    (5) assign -> . variable ASS expr
    (6) assign -> . variable ASS sexpr
    (7) assign -> . variable ASS array
    (8) math -> . term arith term
    (9) math -> . term arith math
    (10) math -> . variable asig term
    (39) term -> . NUMBER
    (17) variable -> . LOCAL
    (18) variable -> . GLOBAL
    (19) variable -> . CONSTANTS
    (20) variable -> . INSTANCEVAR
    (21) variable -> . CLASSVAR
    (87) array -> . LBRACK defarray RBRACK
    (99) slice -> . variable LBRACK defslice RBRACK
    (98) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 27
    WHILE           shift and go to state 2
    BEGIN           shift and go to state 3
    FOR             shift and go to state 28
    NUMBER          shift and go to state 8
    LOCAL           shift and go to state 9
    GLOBAL          shift and go to state 10
    CONSTANTS       shift and go to state 11
    INSTANCEVAR     shift and go to state 12
    CLASSVAR        shift and go to state 13
    LBRACK          shift and go to state 29

    code                           shift and go to state 120
    expr                           shift and go to state 15
    if                             shift and go to state 16
    while                          shift and go to state 17
    expresiones                    shift and go to state 18
    for                            shift and go to state 19
    assign                         shift and go to state 20
    math                           shift and go to state 21
    term                           shift and go to state 22
    variable                       shift and go to state 23
    array                          shift and go to state 24
    slice                          shift and go to state 25
    index                          shift and go to state 26

state 82

    (59) salto -> NEWLINE .

    IF              reduce using rule 59 (salto -> NEWLINE .)
    WHILE           reduce using rule 59 (salto -> NEWLINE .)
    BEGIN           reduce using rule 59 (salto -> NEWLINE .)
    FOR             reduce using rule 59 (salto -> NEWLINE .)
    NUMBER          reduce using rule 59 (salto -> NEWLINE .)
    LOCAL           reduce using rule 59 (salto -> NEWLINE .)
    GLOBAL          reduce using rule 59 (salto -> NEWLINE .)
    CONSTANTS       reduce using rule 59 (salto -> NEWLINE .)
    INSTANCEVAR     reduce using rule 59 (salto -> NEWLINE .)
    CLASSVAR        reduce using rule 59 (salto -> NEWLINE .)
    LBRACK          reduce using rule 59 (salto -> NEWLINE .)
    END             reduce using rule 59 (salto -> NEWLINE .)


state 83

    (3) while -> WHILE logical DOBLEPOINT salto . code salto END
    (72) code -> . expr
    (73) code -> . if
    (74) code -> . while
    (75) code -> . expresiones
    (76) code -> . for
    (77) code -> . assign
    (78) code -> . math
    (79) code -> . code code
    (29) expr -> . math
    (30) expr -> . term
    (31) expr -> . variable
    (32) expr -> . assign
    (33) expr -> . array
    (34) expr -> . slice
    (35) expr -> . index
    (60) if -> . IF logical expr END
    (61) if -> . IF logical THEN expr END
    (62) if -> . IF logical
    (63) if -> . IF logical THEN
    (64) if -> . if else
    (65) if -> . if elsif END
    (1) while -> . WHILE logical code END
    (2) while -> . WHILE logical DO salto code salto END
    (3) while -> . WHILE logical DOBLEPOINT salto code salto END
    (4) while -> . BEGIN code END WHILE logical
    (82) expresiones -> . term DOUBLESECUENCEPOINT term
    (83) for -> . FOR iterador IN expresiones code END
    (84) for -> . FOR iterador IN expresiones DO code END
    (85) for -> . FOR iterador IN array code END
    (86) for -> . FOR iterador IN array DO code END
    (5) assign -> . variable ASS expr
    (6) assign -> . variable ASS sexpr
    (7) assign -> . variable ASS array
    (8) math -> . term arith term
    (9) math -> . term arith math
    (10) math -> . variable asig term
    (39) term -> . NUMBER
    (17) variable -> . LOCAL
    (18) variable -> . GLOBAL
    (19) variable -> . CONSTANTS
    (20) variable -> . INSTANCEVAR
    (21) variable -> . CLASSVAR
    (87) array -> . LBRACK defarray RBRACK
    (99) slice -> . variable LBRACK defslice RBRACK
    (98) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 27
    WHILE           shift and go to state 2
    BEGIN           shift and go to state 3
    FOR             shift and go to state 28
    NUMBER          shift and go to state 8
    LOCAL           shift and go to state 9
    GLOBAL          shift and go to state 10
    CONSTANTS       shift and go to state 11
    INSTANCEVAR     shift and go to state 12
    CLASSVAR        shift and go to state 13
    LBRACK          shift and go to state 29

    code                           shift and go to state 121
    expr                           shift and go to state 15
    if                             shift and go to state 16
    while                          shift and go to state 17
    expresiones                    shift and go to state 18
    for                            shift and go to state 19
    assign                         shift and go to state 20
    math                           shift and go to state 21
    term                           shift and go to state 22
    variable                       shift and go to state 23
    array                          shift and go to state 24
    slice                          shift and go to state 25
    index                          shift and go to state 26

state 84

    (15) logical -> logical logcompare logical .
    (15) logical -> logical . logcompare logical
    (53) logcompare -> . ANDLOG
    (54) logcompare -> . ORLOG
    (55) logcompare -> . NOTLOG
    (56) logcompare -> . AND
    (57) logcompare -> . OR
    (58) logcompare -> . NOT

  ! shift/reduce conflict for ANDLOG resolved as shift
  ! shift/reduce conflict for ORLOG resolved as shift
  ! shift/reduce conflict for NOTLOG resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    DO              reduce using rule 15 (logical -> logical logcompare logical .)
    DOBLEPOINT      reduce using rule 15 (logical -> logical logcompare logical .)
    IF              reduce using rule 15 (logical -> logical logcompare logical .)
    WHILE           reduce using rule 15 (logical -> logical logcompare logical .)
    BEGIN           reduce using rule 15 (logical -> logical logcompare logical .)
    FOR             reduce using rule 15 (logical -> logical logcompare logical .)
    NUMBER          reduce using rule 15 (logical -> logical logcompare logical .)
    LOCAL           reduce using rule 15 (logical -> logical logcompare logical .)
    GLOBAL          reduce using rule 15 (logical -> logical logcompare logical .)
    CONSTANTS       reduce using rule 15 (logical -> logical logcompare logical .)
    INSTANCEVAR     reduce using rule 15 (logical -> logical logcompare logical .)
    CLASSVAR        reduce using rule 15 (logical -> logical logcompare logical .)
    LBRACK          reduce using rule 15 (logical -> logical logcompare logical .)
    THEN            reduce using rule 15 (logical -> logical logcompare logical .)
    ELSE            reduce using rule 15 (logical -> logical logcompare logical .)
    ELSIF           reduce using rule 15 (logical -> logical logcompare logical .)
    END             reduce using rule 15 (logical -> logical logcompare logical .)
    NEWLINE         reduce using rule 15 (logical -> logical logcompare logical .)
    $end            reduce using rule 15 (logical -> logical logcompare logical .)
    ANDLOG          shift and go to state 34
    ORLOG           shift and go to state 35
    NOTLOG          shift and go to state 36
    AND             shift and go to state 37
    OR              shift and go to state 38
    NOT             shift and go to state 39

  ! ANDLOG          [ reduce using rule 15 (logical -> logical logcompare logical .) ]
  ! ORLOG           [ reduce using rule 15 (logical -> logical logcompare logical .) ]
  ! NOTLOG          [ reduce using rule 15 (logical -> logical logcompare logical .) ]
  ! AND             [ reduce using rule 15 (logical -> logical logcompare logical .) ]
  ! OR              [ reduce using rule 15 (logical -> logical logcompare logical .) ]
  ! NOT             [ reduce using rule 15 (logical -> logical logcompare logical .) ]

    logcompare                     shift and go to state 33

state 85

    (11) logical -> term comparison term .
    (11) logical -> term . comparison term
    (12) logical -> term . comparison logical
    (47) comparison -> . EQUAL
    (48) comparison -> . NOTEQ
    (49) comparison -> . GREATHER
    (50) comparison -> . LOWER
    (51) comparison -> . GREATHEREQ
    (52) comparison -> . LOWEREQ

    DO              reduce using rule 11 (logical -> term comparison term .)
    DOBLEPOINT      reduce using rule 11 (logical -> term comparison term .)
    ANDLOG          reduce using rule 11 (logical -> term comparison term .)
    ORLOG           reduce using rule 11 (logical -> term comparison term .)
    NOTLOG          reduce using rule 11 (logical -> term comparison term .)
    AND             reduce using rule 11 (logical -> term comparison term .)
    OR              reduce using rule 11 (logical -> term comparison term .)
    NOT             reduce using rule 11 (logical -> term comparison term .)
    IF              reduce using rule 11 (logical -> term comparison term .)
    WHILE           reduce using rule 11 (logical -> term comparison term .)
    BEGIN           reduce using rule 11 (logical -> term comparison term .)
    FOR             reduce using rule 11 (logical -> term comparison term .)
    NUMBER          reduce using rule 11 (logical -> term comparison term .)
    LOCAL           reduce using rule 11 (logical -> term comparison term .)
    GLOBAL          reduce using rule 11 (logical -> term comparison term .)
    CONSTANTS       reduce using rule 11 (logical -> term comparison term .)
    INSTANCEVAR     reduce using rule 11 (logical -> term comparison term .)
    CLASSVAR        reduce using rule 11 (logical -> term comparison term .)
    LBRACK          reduce using rule 11 (logical -> term comparison term .)
    THEN            reduce using rule 11 (logical -> term comparison term .)
    ELSE            reduce using rule 11 (logical -> term comparison term .)
    ELSIF           reduce using rule 11 (logical -> term comparison term .)
    END             reduce using rule 11 (logical -> term comparison term .)
    NEWLINE         reduce using rule 11 (logical -> term comparison term .)
    $end            reduce using rule 11 (logical -> term comparison term .)
    EQUAL           shift and go to state 41
    NOTEQ           shift and go to state 42
    GREATHER        shift and go to state 43
    LOWER           shift and go to state 44
    GREATHEREQ      shift and go to state 45
    LOWEREQ         shift and go to state 46

    comparison                     shift and go to state 40

state 86

    (12) logical -> term comparison logical .
    (15) logical -> logical . logcompare logical
    (53) logcompare -> . ANDLOG
    (54) logcompare -> . ORLOG
    (55) logcompare -> . NOTLOG
    (56) logcompare -> . AND
    (57) logcompare -> . OR
    (58) logcompare -> . NOT

  ! shift/reduce conflict for ANDLOG resolved as shift
  ! shift/reduce conflict for ORLOG resolved as shift
  ! shift/reduce conflict for NOTLOG resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    DO              reduce using rule 12 (logical -> term comparison logical .)
    DOBLEPOINT      reduce using rule 12 (logical -> term comparison logical .)
    IF              reduce using rule 12 (logical -> term comparison logical .)
    WHILE           reduce using rule 12 (logical -> term comparison logical .)
    BEGIN           reduce using rule 12 (logical -> term comparison logical .)
    FOR             reduce using rule 12 (logical -> term comparison logical .)
    NUMBER          reduce using rule 12 (logical -> term comparison logical .)
    LOCAL           reduce using rule 12 (logical -> term comparison logical .)
    GLOBAL          reduce using rule 12 (logical -> term comparison logical .)
    CONSTANTS       reduce using rule 12 (logical -> term comparison logical .)
    INSTANCEVAR     reduce using rule 12 (logical -> term comparison logical .)
    CLASSVAR        reduce using rule 12 (logical -> term comparison logical .)
    LBRACK          reduce using rule 12 (logical -> term comparison logical .)
    THEN            reduce using rule 12 (logical -> term comparison logical .)
    ELSE            reduce using rule 12 (logical -> term comparison logical .)
    ELSIF           reduce using rule 12 (logical -> term comparison logical .)
    END             reduce using rule 12 (logical -> term comparison logical .)
    NEWLINE         reduce using rule 12 (logical -> term comparison logical .)
    $end            reduce using rule 12 (logical -> term comparison logical .)
    ANDLOG          shift and go to state 34
    ORLOG           shift and go to state 35
    NOTLOG          shift and go to state 36
    AND             shift and go to state 37
    OR              shift and go to state 38
    NOT             shift and go to state 39

  ! ANDLOG          [ reduce using rule 12 (logical -> term comparison logical .) ]
  ! ORLOG           [ reduce using rule 12 (logical -> term comparison logical .) ]
  ! NOTLOG          [ reduce using rule 12 (logical -> term comparison logical .) ]
  ! AND             [ reduce using rule 12 (logical -> term comparison logical .) ]
  ! OR              [ reduce using rule 12 (logical -> term comparison logical .) ]
  ! NOT             [ reduce using rule 12 (logical -> term comparison logical .) ]

    logcompare                     shift and go to state 33

state 87

    (13) logical -> variable comparison term .

    DO              reduce using rule 13 (logical -> variable comparison term .)
    DOBLEPOINT      reduce using rule 13 (logical -> variable comparison term .)
    ANDLOG          reduce using rule 13 (logical -> variable comparison term .)
    ORLOG           reduce using rule 13 (logical -> variable comparison term .)
    NOTLOG          reduce using rule 13 (logical -> variable comparison term .)
    AND             reduce using rule 13 (logical -> variable comparison term .)
    OR              reduce using rule 13 (logical -> variable comparison term .)
    NOT             reduce using rule 13 (logical -> variable comparison term .)
    IF              reduce using rule 13 (logical -> variable comparison term .)
    WHILE           reduce using rule 13 (logical -> variable comparison term .)
    BEGIN           reduce using rule 13 (logical -> variable comparison term .)
    FOR             reduce using rule 13 (logical -> variable comparison term .)
    NUMBER          reduce using rule 13 (logical -> variable comparison term .)
    LOCAL           reduce using rule 13 (logical -> variable comparison term .)
    GLOBAL          reduce using rule 13 (logical -> variable comparison term .)
    CONSTANTS       reduce using rule 13 (logical -> variable comparison term .)
    INSTANCEVAR     reduce using rule 13 (logical -> variable comparison term .)
    CLASSVAR        reduce using rule 13 (logical -> variable comparison term .)
    LBRACK          reduce using rule 13 (logical -> variable comparison term .)
    THEN            reduce using rule 13 (logical -> variable comparison term .)
    ELSE            reduce using rule 13 (logical -> variable comparison term .)
    ELSIF           reduce using rule 13 (logical -> variable comparison term .)
    END             reduce using rule 13 (logical -> variable comparison term .)
    NEWLINE         reduce using rule 13 (logical -> variable comparison term .)
    $end            reduce using rule 13 (logical -> variable comparison term .)


state 88

    (14) logical -> variable comparison BOOLEAN .

    DO              reduce using rule 14 (logical -> variable comparison BOOLEAN .)
    DOBLEPOINT      reduce using rule 14 (logical -> variable comparison BOOLEAN .)
    ANDLOG          reduce using rule 14 (logical -> variable comparison BOOLEAN .)
    ORLOG           reduce using rule 14 (logical -> variable comparison BOOLEAN .)
    NOTLOG          reduce using rule 14 (logical -> variable comparison BOOLEAN .)
    AND             reduce using rule 14 (logical -> variable comparison BOOLEAN .)
    OR              reduce using rule 14 (logical -> variable comparison BOOLEAN .)
    NOT             reduce using rule 14 (logical -> variable comparison BOOLEAN .)
    IF              reduce using rule 14 (logical -> variable comparison BOOLEAN .)
    WHILE           reduce using rule 14 (logical -> variable comparison BOOLEAN .)
    BEGIN           reduce using rule 14 (logical -> variable comparison BOOLEAN .)
    FOR             reduce using rule 14 (logical -> variable comparison BOOLEAN .)
    NUMBER          reduce using rule 14 (logical -> variable comparison BOOLEAN .)
    LOCAL           reduce using rule 14 (logical -> variable comparison BOOLEAN .)
    GLOBAL          reduce using rule 14 (logical -> variable comparison BOOLEAN .)
    CONSTANTS       reduce using rule 14 (logical -> variable comparison BOOLEAN .)
    INSTANCEVAR     reduce using rule 14 (logical -> variable comparison BOOLEAN .)
    CLASSVAR        reduce using rule 14 (logical -> variable comparison BOOLEAN .)
    LBRACK          reduce using rule 14 (logical -> variable comparison BOOLEAN .)
    THEN            reduce using rule 14 (logical -> variable comparison BOOLEAN .)
    ELSE            reduce using rule 14 (logical -> variable comparison BOOLEAN .)
    ELSIF           reduce using rule 14 (logical -> variable comparison BOOLEAN .)
    END             reduce using rule 14 (logical -> variable comparison BOOLEAN .)
    NEWLINE         reduce using rule 14 (logical -> variable comparison BOOLEAN .)
    $end            reduce using rule 14 (logical -> variable comparison BOOLEAN .)


state 89

    (4) while -> BEGIN code END WHILE . logical
    (11) logical -> . term comparison term
    (12) logical -> . term comparison logical
    (13) logical -> . variable comparison term
    (14) logical -> . variable comparison BOOLEAN
    (15) logical -> . logical logcompare logical
    (16) logical -> . BOOLEAN
    (39) term -> . NUMBER
    (17) variable -> . LOCAL
    (18) variable -> . GLOBAL
    (19) variable -> . CONSTANTS
    (20) variable -> . INSTANCEVAR
    (21) variable -> . CLASSVAR

    BOOLEAN         shift and go to state 7
    NUMBER          shift and go to state 8
    LOCAL           shift and go to state 9
    GLOBAL          shift and go to state 10
    CONSTANTS       shift and go to state 11
    INSTANCEVAR     shift and go to state 12
    CLASSVAR        shift and go to state 13

    logical                        shift and go to state 122
    term                           shift and go to state 5
    variable                       shift and go to state 6

state 90

    (65) if -> if elsif END .

    ELSE            reduce using rule 65 (if -> if elsif END .)
    ELSIF           reduce using rule 65 (if -> if elsif END .)
    END             reduce using rule 65 (if -> if elsif END .)
    IF              reduce using rule 65 (if -> if elsif END .)
    WHILE           reduce using rule 65 (if -> if elsif END .)
    BEGIN           reduce using rule 65 (if -> if elsif END .)
    FOR             reduce using rule 65 (if -> if elsif END .)
    NUMBER          reduce using rule 65 (if -> if elsif END .)
    LOCAL           reduce using rule 65 (if -> if elsif END .)
    GLOBAL          reduce using rule 65 (if -> if elsif END .)
    CONSTANTS       reduce using rule 65 (if -> if elsif END .)
    INSTANCEVAR     reduce using rule 65 (if -> if elsif END .)
    CLASSVAR        reduce using rule 65 (if -> if elsif END .)
    LBRACK          reduce using rule 65 (if -> if elsif END .)
    NEWLINE         reduce using rule 65 (if -> if elsif END .)


state 91

    (66) else -> ELSE expr . END

    END             shift and go to state 123


state 92

    (29) expr -> math .

    END             reduce using rule 29 (expr -> math .)
    IF              reduce using rule 29 (expr -> math .)
    WHILE           reduce using rule 29 (expr -> math .)
    BEGIN           reduce using rule 29 (expr -> math .)
    FOR             reduce using rule 29 (expr -> math .)
    NUMBER          reduce using rule 29 (expr -> math .)
    LOCAL           reduce using rule 29 (expr -> math .)
    GLOBAL          reduce using rule 29 (expr -> math .)
    CONSTANTS       reduce using rule 29 (expr -> math .)
    INSTANCEVAR     reduce using rule 29 (expr -> math .)
    CLASSVAR        reduce using rule 29 (expr -> math .)
    LBRACK          reduce using rule 29 (expr -> math .)
    NEWLINE         reduce using rule 29 (expr -> math .)
    ELSE            reduce using rule 29 (expr -> math .)
    ELSIF           reduce using rule 29 (expr -> math .)


state 93

    (30) expr -> term .
    (8) math -> term . arith term
    (9) math -> term . arith math
    (41) arith -> . EXP
    (42) arith -> . MUL
    (43) arith -> . DIV
    (44) arith -> . MOD
    (45) arith -> . ADD
    (46) arith -> . SUB

    END             reduce using rule 30 (expr -> term .)
    IF              reduce using rule 30 (expr -> term .)
    WHILE           reduce using rule 30 (expr -> term .)
    BEGIN           reduce using rule 30 (expr -> term .)
    FOR             reduce using rule 30 (expr -> term .)
    NUMBER          reduce using rule 30 (expr -> term .)
    LOCAL           reduce using rule 30 (expr -> term .)
    GLOBAL          reduce using rule 30 (expr -> term .)
    CONSTANTS       reduce using rule 30 (expr -> term .)
    INSTANCEVAR     reduce using rule 30 (expr -> term .)
    CLASSVAR        reduce using rule 30 (expr -> term .)
    LBRACK          reduce using rule 30 (expr -> term .)
    NEWLINE         reduce using rule 30 (expr -> term .)
    ELSE            reduce using rule 30 (expr -> term .)
    ELSIF           reduce using rule 30 (expr -> term .)
    EXP             shift and go to state 56
    MUL             shift and go to state 57
    DIV             shift and go to state 58
    MOD             shift and go to state 59
    ADD             shift and go to state 60
    SUB             shift and go to state 61

    arith                          shift and go to state 55

state 94

    (31) expr -> variable .
    (10) math -> variable . asig term
    (5) assign -> variable . ASS expr
    (6) assign -> variable . ASS sexpr
    (7) assign -> variable . ASS array
    (99) slice -> variable . LBRACK defslice RBRACK
    (98) index -> variable . LBRACK INT RBRACK
    (22) asig -> . ASS
    (23) asig -> . ADDASS
    (24) asig -> . SUBASS
    (25) asig -> . MULASS
    (26) asig -> . DIVASS
    (27) asig -> . MODASS
    (28) asig -> . EXPASS

  ! shift/reduce conflict for LBRACK resolved as shift
    END             reduce using rule 31 (expr -> variable .)
    IF              reduce using rule 31 (expr -> variable .)
    WHILE           reduce using rule 31 (expr -> variable .)
    BEGIN           reduce using rule 31 (expr -> variable .)
    FOR             reduce using rule 31 (expr -> variable .)
    NUMBER          reduce using rule 31 (expr -> variable .)
    LOCAL           reduce using rule 31 (expr -> variable .)
    GLOBAL          reduce using rule 31 (expr -> variable .)
    CONSTANTS       reduce using rule 31 (expr -> variable .)
    INSTANCEVAR     reduce using rule 31 (expr -> variable .)
    CLASSVAR        reduce using rule 31 (expr -> variable .)
    NEWLINE         reduce using rule 31 (expr -> variable .)
    ELSE            reduce using rule 31 (expr -> variable .)
    ELSIF           reduce using rule 31 (expr -> variable .)
    ASS             shift and go to state 62
    LBRACK          shift and go to state 64
    ADDASS          shift and go to state 65
    SUBASS          shift and go to state 66
    MULASS          shift and go to state 67
    DIVASS          shift and go to state 68
    MODASS          shift and go to state 69
    EXPASS          shift and go to state 70

  ! LBRACK          [ reduce using rule 31 (expr -> variable .) ]

    asig                           shift and go to state 63

state 95

    (32) expr -> assign .

    END             reduce using rule 32 (expr -> assign .)
    IF              reduce using rule 32 (expr -> assign .)
    WHILE           reduce using rule 32 (expr -> assign .)
    BEGIN           reduce using rule 32 (expr -> assign .)
    FOR             reduce using rule 32 (expr -> assign .)
    NUMBER          reduce using rule 32 (expr -> assign .)
    LOCAL           reduce using rule 32 (expr -> assign .)
    GLOBAL          reduce using rule 32 (expr -> assign .)
    CONSTANTS       reduce using rule 32 (expr -> assign .)
    INSTANCEVAR     reduce using rule 32 (expr -> assign .)
    CLASSVAR        reduce using rule 32 (expr -> assign .)
    LBRACK          reduce using rule 32 (expr -> assign .)
    NEWLINE         reduce using rule 32 (expr -> assign .)
    ELSE            reduce using rule 32 (expr -> assign .)
    ELSIF           reduce using rule 32 (expr -> assign .)


state 96

    (67) elsif -> ELSIF logical . final
    (15) logical -> logical . logcompare logical
    (68) final -> . expr
    (69) final -> . THEN expr
    (70) final -> . expr else
    (71) final -> . expr elsif
    (53) logcompare -> . ANDLOG
    (54) logcompare -> . ORLOG
    (55) logcompare -> . NOTLOG
    (56) logcompare -> . AND
    (57) logcompare -> . OR
    (58) logcompare -> . NOT
    (29) expr -> . math
    (30) expr -> . term
    (31) expr -> . variable
    (32) expr -> . assign
    (33) expr -> . array
    (34) expr -> . slice
    (35) expr -> . index
    (8) math -> . term arith term
    (9) math -> . term arith math
    (10) math -> . variable asig term
    (39) term -> . NUMBER
    (17) variable -> . LOCAL
    (18) variable -> . GLOBAL
    (19) variable -> . CONSTANTS
    (20) variable -> . INSTANCEVAR
    (21) variable -> . CLASSVAR
    (5) assign -> . variable ASS expr
    (6) assign -> . variable ASS sexpr
    (7) assign -> . variable ASS array
    (87) array -> . LBRACK defarray RBRACK
    (99) slice -> . variable LBRACK defslice RBRACK
    (98) index -> . variable LBRACK INT RBRACK

    THEN            shift and go to state 126
    ANDLOG          shift and go to state 34
    ORLOG           shift and go to state 35
    NOTLOG          shift and go to state 36
    AND             shift and go to state 37
    OR              shift and go to state 38
    NOT             shift and go to state 39
    NUMBER          shift and go to state 8
    LOCAL           shift and go to state 9
    GLOBAL          shift and go to state 10
    CONSTANTS       shift and go to state 11
    INSTANCEVAR     shift and go to state 12
    CLASSVAR        shift and go to state 13
    LBRACK          shift and go to state 29

    final                          shift and go to state 124
    logcompare                     shift and go to state 33
    expr                           shift and go to state 125
    math                           shift and go to state 92
    term                           shift and go to state 93
    variable                       shift and go to state 94
    assign                         shift and go to state 95
    array                          shift and go to state 24
    slice                          shift and go to state 25
    index                          shift and go to state 26

state 97

    (82) expresiones -> term DOUBLESECUENCEPOINT term .

    END             reduce using rule 82 (expresiones -> term DOUBLESECUENCEPOINT term .)
    IF              reduce using rule 82 (expresiones -> term DOUBLESECUENCEPOINT term .)
    WHILE           reduce using rule 82 (expresiones -> term DOUBLESECUENCEPOINT term .)
    BEGIN           reduce using rule 82 (expresiones -> term DOUBLESECUENCEPOINT term .)
    FOR             reduce using rule 82 (expresiones -> term DOUBLESECUENCEPOINT term .)
    NUMBER          reduce using rule 82 (expresiones -> term DOUBLESECUENCEPOINT term .)
    LOCAL           reduce using rule 82 (expresiones -> term DOUBLESECUENCEPOINT term .)
    GLOBAL          reduce using rule 82 (expresiones -> term DOUBLESECUENCEPOINT term .)
    CONSTANTS       reduce using rule 82 (expresiones -> term DOUBLESECUENCEPOINT term .)
    INSTANCEVAR     reduce using rule 82 (expresiones -> term DOUBLESECUENCEPOINT term .)
    CLASSVAR        reduce using rule 82 (expresiones -> term DOUBLESECUENCEPOINT term .)
    LBRACK          reduce using rule 82 (expresiones -> term DOUBLESECUENCEPOINT term .)
    NEWLINE         reduce using rule 82 (expresiones -> term DOUBLESECUENCEPOINT term .)
    DO              reduce using rule 82 (expresiones -> term DOUBLESECUENCEPOINT term .)


state 98

    (8) math -> term arith term .
    (8) math -> term . arith term
    (9) math -> term . arith math
    (41) arith -> . EXP
    (42) arith -> . MUL
    (43) arith -> . DIV
    (44) arith -> . MOD
    (45) arith -> . ADD
    (46) arith -> . SUB

    END             reduce using rule 8 (math -> term arith term .)
    IF              reduce using rule 8 (math -> term arith term .)
    WHILE           reduce using rule 8 (math -> term arith term .)
    BEGIN           reduce using rule 8 (math -> term arith term .)
    FOR             reduce using rule 8 (math -> term arith term .)
    NUMBER          reduce using rule 8 (math -> term arith term .)
    LOCAL           reduce using rule 8 (math -> term arith term .)
    GLOBAL          reduce using rule 8 (math -> term arith term .)
    CONSTANTS       reduce using rule 8 (math -> term arith term .)
    INSTANCEVAR     reduce using rule 8 (math -> term arith term .)
    CLASSVAR        reduce using rule 8 (math -> term arith term .)
    LBRACK          reduce using rule 8 (math -> term arith term .)
    NEWLINE         reduce using rule 8 (math -> term arith term .)
    ELSE            reduce using rule 8 (math -> term arith term .)
    ELSIF           reduce using rule 8 (math -> term arith term .)
    EXP             shift and go to state 56
    MUL             shift and go to state 57
    DIV             shift and go to state 58
    MOD             shift and go to state 59
    ADD             shift and go to state 60
    SUB             shift and go to state 61

    arith                          shift and go to state 55

state 99

    (9) math -> term arith math .

    END             reduce using rule 9 (math -> term arith math .)
    IF              reduce using rule 9 (math -> term arith math .)
    WHILE           reduce using rule 9 (math -> term arith math .)
    BEGIN           reduce using rule 9 (math -> term arith math .)
    FOR             reduce using rule 9 (math -> term arith math .)
    NUMBER          reduce using rule 9 (math -> term arith math .)
    LOCAL           reduce using rule 9 (math -> term arith math .)
    GLOBAL          reduce using rule 9 (math -> term arith math .)
    CONSTANTS       reduce using rule 9 (math -> term arith math .)
    INSTANCEVAR     reduce using rule 9 (math -> term arith math .)
    CLASSVAR        reduce using rule 9 (math -> term arith math .)
    LBRACK          reduce using rule 9 (math -> term arith math .)
    NEWLINE         reduce using rule 9 (math -> term arith math .)
    ELSE            reduce using rule 9 (math -> term arith math .)
    ELSIF           reduce using rule 9 (math -> term arith math .)


state 100

    (10) math -> variable . asig term
    (22) asig -> . ASS
    (23) asig -> . ADDASS
    (24) asig -> . SUBASS
    (25) asig -> . MULASS
    (26) asig -> . DIVASS
    (27) asig -> . MODASS
    (28) asig -> . EXPASS

    ASS             shift and go to state 127
    ADDASS          shift and go to state 65
    SUBASS          shift and go to state 66
    MULASS          shift and go to state 67
    DIVASS          shift and go to state 68
    MODASS          shift and go to state 69
    EXPASS          shift and go to state 70

    asig                           shift and go to state 63

state 101

    (5) assign -> variable ASS expr .

    END             reduce using rule 5 (assign -> variable ASS expr .)
    IF              reduce using rule 5 (assign -> variable ASS expr .)
    WHILE           reduce using rule 5 (assign -> variable ASS expr .)
    BEGIN           reduce using rule 5 (assign -> variable ASS expr .)
    FOR             reduce using rule 5 (assign -> variable ASS expr .)
    NUMBER          reduce using rule 5 (assign -> variable ASS expr .)
    LOCAL           reduce using rule 5 (assign -> variable ASS expr .)
    GLOBAL          reduce using rule 5 (assign -> variable ASS expr .)
    CONSTANTS       reduce using rule 5 (assign -> variable ASS expr .)
    INSTANCEVAR     reduce using rule 5 (assign -> variable ASS expr .)
    CLASSVAR        reduce using rule 5 (assign -> variable ASS expr .)
    LBRACK          reduce using rule 5 (assign -> variable ASS expr .)
    NEWLINE         reduce using rule 5 (assign -> variable ASS expr .)
    ELSE            reduce using rule 5 (assign -> variable ASS expr .)
    ELSIF           reduce using rule 5 (assign -> variable ASS expr .)


state 102

    (6) assign -> variable ASS sexpr .

    END             reduce using rule 6 (assign -> variable ASS sexpr .)
    IF              reduce using rule 6 (assign -> variable ASS sexpr .)
    WHILE           reduce using rule 6 (assign -> variable ASS sexpr .)
    BEGIN           reduce using rule 6 (assign -> variable ASS sexpr .)
    FOR             reduce using rule 6 (assign -> variable ASS sexpr .)
    NUMBER          reduce using rule 6 (assign -> variable ASS sexpr .)
    LOCAL           reduce using rule 6 (assign -> variable ASS sexpr .)
    GLOBAL          reduce using rule 6 (assign -> variable ASS sexpr .)
    CONSTANTS       reduce using rule 6 (assign -> variable ASS sexpr .)
    INSTANCEVAR     reduce using rule 6 (assign -> variable ASS sexpr .)
    CLASSVAR        reduce using rule 6 (assign -> variable ASS sexpr .)
    LBRACK          reduce using rule 6 (assign -> variable ASS sexpr .)
    NEWLINE         reduce using rule 6 (assign -> variable ASS sexpr .)
    ELSE            reduce using rule 6 (assign -> variable ASS sexpr .)
    ELSIF           reduce using rule 6 (assign -> variable ASS sexpr .)


state 103

    (7) assign -> variable ASS array .
    (33) expr -> array .

  ! reduce/reduce conflict for END resolved using rule 7 (assign -> variable ASS array .)
  ! reduce/reduce conflict for IF resolved using rule 7 (assign -> variable ASS array .)
  ! reduce/reduce conflict for WHILE resolved using rule 7 (assign -> variable ASS array .)
  ! reduce/reduce conflict for BEGIN resolved using rule 7 (assign -> variable ASS array .)
  ! reduce/reduce conflict for FOR resolved using rule 7 (assign -> variable ASS array .)
  ! reduce/reduce conflict for NUMBER resolved using rule 7 (assign -> variable ASS array .)
  ! reduce/reduce conflict for LOCAL resolved using rule 7 (assign -> variable ASS array .)
  ! reduce/reduce conflict for GLOBAL resolved using rule 7 (assign -> variable ASS array .)
  ! reduce/reduce conflict for CONSTANTS resolved using rule 7 (assign -> variable ASS array .)
  ! reduce/reduce conflict for INSTANCEVAR resolved using rule 7 (assign -> variable ASS array .)
  ! reduce/reduce conflict for CLASSVAR resolved using rule 7 (assign -> variable ASS array .)
  ! reduce/reduce conflict for LBRACK resolved using rule 7 (assign -> variable ASS array .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 7 (assign -> variable ASS array .)
  ! reduce/reduce conflict for ELSE resolved using rule 7 (assign -> variable ASS array .)
  ! reduce/reduce conflict for ELSIF resolved using rule 7 (assign -> variable ASS array .)
    END             reduce using rule 7 (assign -> variable ASS array .)
    IF              reduce using rule 7 (assign -> variable ASS array .)
    WHILE           reduce using rule 7 (assign -> variable ASS array .)
    BEGIN           reduce using rule 7 (assign -> variable ASS array .)
    FOR             reduce using rule 7 (assign -> variable ASS array .)
    NUMBER          reduce using rule 7 (assign -> variable ASS array .)
    LOCAL           reduce using rule 7 (assign -> variable ASS array .)
    GLOBAL          reduce using rule 7 (assign -> variable ASS array .)
    CONSTANTS       reduce using rule 7 (assign -> variable ASS array .)
    INSTANCEVAR     reduce using rule 7 (assign -> variable ASS array .)
    CLASSVAR        reduce using rule 7 (assign -> variable ASS array .)
    LBRACK          reduce using rule 7 (assign -> variable ASS array .)
    NEWLINE         reduce using rule 7 (assign -> variable ASS array .)
    ELSE            reduce using rule 7 (assign -> variable ASS array .)
    ELSIF           reduce using rule 7 (assign -> variable ASS array .)

  ! END             [ reduce using rule 33 (expr -> array .) ]
  ! IF              [ reduce using rule 33 (expr -> array .) ]
  ! WHILE           [ reduce using rule 33 (expr -> array .) ]
  ! BEGIN           [ reduce using rule 33 (expr -> array .) ]
  ! FOR             [ reduce using rule 33 (expr -> array .) ]
  ! NUMBER          [ reduce using rule 33 (expr -> array .) ]
  ! LOCAL           [ reduce using rule 33 (expr -> array .) ]
  ! GLOBAL          [ reduce using rule 33 (expr -> array .) ]
  ! CONSTANTS       [ reduce using rule 33 (expr -> array .) ]
  ! INSTANCEVAR     [ reduce using rule 33 (expr -> array .) ]
  ! CLASSVAR        [ reduce using rule 33 (expr -> array .) ]
  ! LBRACK          [ reduce using rule 33 (expr -> array .) ]
  ! NEWLINE         [ reduce using rule 33 (expr -> array .) ]
  ! ELSE            [ reduce using rule 33 (expr -> array .) ]
  ! ELSIF           [ reduce using rule 33 (expr -> array .) ]


state 104

    (36) sexpr -> sterm . MUL term
    (37) sexpr -> sterm . ADD sexpr
    (38) sexpr -> sterm .

    MUL             shift and go to state 128
    ADD             shift and go to state 129
    END             reduce using rule 38 (sexpr -> sterm .)
    IF              reduce using rule 38 (sexpr -> sterm .)
    WHILE           reduce using rule 38 (sexpr -> sterm .)
    BEGIN           reduce using rule 38 (sexpr -> sterm .)
    FOR             reduce using rule 38 (sexpr -> sterm .)
    NUMBER          reduce using rule 38 (sexpr -> sterm .)
    LOCAL           reduce using rule 38 (sexpr -> sterm .)
    GLOBAL          reduce using rule 38 (sexpr -> sterm .)
    CONSTANTS       reduce using rule 38 (sexpr -> sterm .)
    INSTANCEVAR     reduce using rule 38 (sexpr -> sterm .)
    CLASSVAR        reduce using rule 38 (sexpr -> sterm .)
    LBRACK          reduce using rule 38 (sexpr -> sterm .)
    NEWLINE         reduce using rule 38 (sexpr -> sterm .)
    ELSE            reduce using rule 38 (sexpr -> sterm .)
    ELSIF           reduce using rule 38 (sexpr -> sterm .)


state 105

    (40) sterm -> STRING .

    MUL             reduce using rule 40 (sterm -> STRING .)
    ADD             reduce using rule 40 (sterm -> STRING .)
    END             reduce using rule 40 (sterm -> STRING .)
    IF              reduce using rule 40 (sterm -> STRING .)
    WHILE           reduce using rule 40 (sterm -> STRING .)
    BEGIN           reduce using rule 40 (sterm -> STRING .)
    FOR             reduce using rule 40 (sterm -> STRING .)
    NUMBER          reduce using rule 40 (sterm -> STRING .)
    LOCAL           reduce using rule 40 (sterm -> STRING .)
    GLOBAL          reduce using rule 40 (sterm -> STRING .)
    CONSTANTS       reduce using rule 40 (sterm -> STRING .)
    INSTANCEVAR     reduce using rule 40 (sterm -> STRING .)
    CLASSVAR        reduce using rule 40 (sterm -> STRING .)
    LBRACK          reduce using rule 40 (sterm -> STRING .)
    NEWLINE         reduce using rule 40 (sterm -> STRING .)
    ELSE            reduce using rule 40 (sterm -> STRING .)
    ELSIF           reduce using rule 40 (sterm -> STRING .)


state 106

    (10) math -> variable asig term .

    END             reduce using rule 10 (math -> variable asig term .)
    IF              reduce using rule 10 (math -> variable asig term .)
    WHILE           reduce using rule 10 (math -> variable asig term .)
    BEGIN           reduce using rule 10 (math -> variable asig term .)
    FOR             reduce using rule 10 (math -> variable asig term .)
    NUMBER          reduce using rule 10 (math -> variable asig term .)
    LOCAL           reduce using rule 10 (math -> variable asig term .)
    GLOBAL          reduce using rule 10 (math -> variable asig term .)
    CONSTANTS       reduce using rule 10 (math -> variable asig term .)
    INSTANCEVAR     reduce using rule 10 (math -> variable asig term .)
    CLASSVAR        reduce using rule 10 (math -> variable asig term .)
    LBRACK          reduce using rule 10 (math -> variable asig term .)
    NEWLINE         reduce using rule 10 (math -> variable asig term .)
    ELSE            reduce using rule 10 (math -> variable asig term .)
    ELSIF           reduce using rule 10 (math -> variable asig term .)


state 107

    (99) slice -> variable LBRACK defslice . RBRACK

    RBRACK          shift and go to state 130


state 108

    (98) index -> variable LBRACK INT . RBRACK
    (100) defslice -> INT . DOBLEPOINT INT
    (101) defslice -> INT . DOBLEPOINT

    RBRACK          shift and go to state 131
    DOBLEPOINT      shift and go to state 132


state 109

    (102) defslice -> DOBLEPOINT . INT

    INT             shift and go to state 133


state 110

    (60) if -> IF logical expr . END

    END             shift and go to state 134


state 111

    (61) if -> IF logical THEN . expr END
    (63) if -> IF logical THEN .
    (29) expr -> . math
    (30) expr -> . term
    (31) expr -> . variable
    (32) expr -> . assign
    (33) expr -> . array
    (34) expr -> . slice
    (35) expr -> . index
    (8) math -> . term arith term
    (9) math -> . term arith math
    (10) math -> . variable asig term
    (39) term -> . NUMBER
    (17) variable -> . LOCAL
    (18) variable -> . GLOBAL
    (19) variable -> . CONSTANTS
    (20) variable -> . INSTANCEVAR
    (21) variable -> . CLASSVAR
    (5) assign -> . variable ASS expr
    (6) assign -> . variable ASS sexpr
    (7) assign -> . variable ASS array
    (87) array -> . LBRACK defarray RBRACK
    (99) slice -> . variable LBRACK defslice RBRACK
    (98) index -> . variable LBRACK INT RBRACK

  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for LOCAL resolved as shift
  ! shift/reduce conflict for GLOBAL resolved as shift
  ! shift/reduce conflict for CONSTANTS resolved as shift
  ! shift/reduce conflict for INSTANCEVAR resolved as shift
  ! shift/reduce conflict for CLASSVAR resolved as shift
  ! shift/reduce conflict for LBRACK resolved as shift
    ELSE            reduce using rule 63 (if -> IF logical THEN .)
    ELSIF           reduce using rule 63 (if -> IF logical THEN .)
    END             reduce using rule 63 (if -> IF logical THEN .)
    IF              reduce using rule 63 (if -> IF logical THEN .)
    WHILE           reduce using rule 63 (if -> IF logical THEN .)
    BEGIN           reduce using rule 63 (if -> IF logical THEN .)
    FOR             reduce using rule 63 (if -> IF logical THEN .)
    NEWLINE         reduce using rule 63 (if -> IF logical THEN .)
    NUMBER          shift and go to state 8
    LOCAL           shift and go to state 9
    GLOBAL          shift and go to state 10
    CONSTANTS       shift and go to state 11
    INSTANCEVAR     shift and go to state 12
    CLASSVAR        shift and go to state 13
    LBRACK          shift and go to state 29

  ! NUMBER          [ reduce using rule 63 (if -> IF logical THEN .) ]
  ! LOCAL           [ reduce using rule 63 (if -> IF logical THEN .) ]
  ! GLOBAL          [ reduce using rule 63 (if -> IF logical THEN .) ]
  ! CONSTANTS       [ reduce using rule 63 (if -> IF logical THEN .) ]
  ! INSTANCEVAR     [ reduce using rule 63 (if -> IF logical THEN .) ]
  ! CLASSVAR        [ reduce using rule 63 (if -> IF logical THEN .) ]
  ! LBRACK          [ reduce using rule 63 (if -> IF logical THEN .) ]

    expr                           shift and go to state 135
    math                           shift and go to state 92
    term                           shift and go to state 93
    variable                       shift and go to state 94
    assign                         shift and go to state 95
    array                          shift and go to state 24
    slice                          shift and go to state 25
    index                          shift and go to state 26

state 112

    (83) for -> FOR iterador IN . expresiones code END
    (84) for -> FOR iterador IN . expresiones DO code END
    (85) for -> FOR iterador IN . array code END
    (86) for -> FOR iterador IN . array DO code END
    (82) expresiones -> . term DOUBLESECUENCEPOINT term
    (87) array -> . LBRACK defarray RBRACK
    (39) term -> . NUMBER

    LBRACK          shift and go to state 29
    NUMBER          shift and go to state 8

    expresiones                    shift and go to state 136
    array                          shift and go to state 137
    term                           shift and go to state 138

state 113

    (81) iterador -> variable , . variable
    (17) variable -> . LOCAL
    (18) variable -> . GLOBAL
    (19) variable -> . CONSTANTS
    (20) variable -> . INSTANCEVAR
    (21) variable -> . CLASSVAR

    LOCAL           shift and go to state 9
    GLOBAL          shift and go to state 10
    CONSTANTS       shift and go to state 11
    INSTANCEVAR     shift and go to state 12
    CLASSVAR        shift and go to state 13

    variable                       shift and go to state 139

state 114

    (87) array -> LBRACK defarray RBRACK .

    END             reduce using rule 87 (array -> LBRACK defarray RBRACK .)
    IF              reduce using rule 87 (array -> LBRACK defarray RBRACK .)
    WHILE           reduce using rule 87 (array -> LBRACK defarray RBRACK .)
    BEGIN           reduce using rule 87 (array -> LBRACK defarray RBRACK .)
    FOR             reduce using rule 87 (array -> LBRACK defarray RBRACK .)
    NUMBER          reduce using rule 87 (array -> LBRACK defarray RBRACK .)
    LOCAL           reduce using rule 87 (array -> LBRACK defarray RBRACK .)
    GLOBAL          reduce using rule 87 (array -> LBRACK defarray RBRACK .)
    CONSTANTS       reduce using rule 87 (array -> LBRACK defarray RBRACK .)
    INSTANCEVAR     reduce using rule 87 (array -> LBRACK defarray RBRACK .)
    CLASSVAR        reduce using rule 87 (array -> LBRACK defarray RBRACK .)
    LBRACK          reduce using rule 87 (array -> LBRACK defarray RBRACK .)
    NEWLINE         reduce using rule 87 (array -> LBRACK defarray RBRACK .)
    ELSE            reduce using rule 87 (array -> LBRACK defarray RBRACK .)
    ELSIF           reduce using rule 87 (array -> LBRACK defarray RBRACK .)
    DO              reduce using rule 87 (array -> LBRACK defarray RBRACK .)


state 115

    (89) defarray -> NUMBER COMA . defarray
    (88) defarray -> . NUMBER
    (89) defarray -> . NUMBER COMA defarray
    (90) defarray -> . STRING
    (91) defarray -> . STRING COMA defarray
    (92) defarray -> . INT
    (93) defarray -> . INT COMA defarray
    (94) defarray -> . FLOAT
    (95) defarray -> . FLOAT COMA defarray
    (96) defarray -> . BOOLEAN
    (97) defarray -> . BOOLEAN COMA defarray

    NUMBER          shift and go to state 75
    STRING          shift and go to state 76
    INT             shift and go to state 77
    FLOAT           shift and go to state 78
    BOOLEAN         shift and go to state 79

    defarray                       shift and go to state 140

state 116

    (91) defarray -> STRING COMA . defarray
    (88) defarray -> . NUMBER
    (89) defarray -> . NUMBER COMA defarray
    (90) defarray -> . STRING
    (91) defarray -> . STRING COMA defarray
    (92) defarray -> . INT
    (93) defarray -> . INT COMA defarray
    (94) defarray -> . FLOAT
    (95) defarray -> . FLOAT COMA defarray
    (96) defarray -> . BOOLEAN
    (97) defarray -> . BOOLEAN COMA defarray

    NUMBER          shift and go to state 75
    STRING          shift and go to state 76
    INT             shift and go to state 77
    FLOAT           shift and go to state 78
    BOOLEAN         shift and go to state 79

    defarray                       shift and go to state 141

state 117

    (93) defarray -> INT COMA . defarray
    (88) defarray -> . NUMBER
    (89) defarray -> . NUMBER COMA defarray
    (90) defarray -> . STRING
    (91) defarray -> . STRING COMA defarray
    (92) defarray -> . INT
    (93) defarray -> . INT COMA defarray
    (94) defarray -> . FLOAT
    (95) defarray -> . FLOAT COMA defarray
    (96) defarray -> . BOOLEAN
    (97) defarray -> . BOOLEAN COMA defarray

    NUMBER          shift and go to state 75
    STRING          shift and go to state 76
    INT             shift and go to state 77
    FLOAT           shift and go to state 78
    BOOLEAN         shift and go to state 79

    defarray                       shift and go to state 142

state 118

    (95) defarray -> FLOAT COMA . defarray
    (88) defarray -> . NUMBER
    (89) defarray -> . NUMBER COMA defarray
    (90) defarray -> . STRING
    (91) defarray -> . STRING COMA defarray
    (92) defarray -> . INT
    (93) defarray -> . INT COMA defarray
    (94) defarray -> . FLOAT
    (95) defarray -> . FLOAT COMA defarray
    (96) defarray -> . BOOLEAN
    (97) defarray -> . BOOLEAN COMA defarray

    NUMBER          shift and go to state 75
    STRING          shift and go to state 76
    INT             shift and go to state 77
    FLOAT           shift and go to state 78
    BOOLEAN         shift and go to state 79

    defarray                       shift and go to state 143

state 119

    (97) defarray -> BOOLEAN COMA . defarray
    (88) defarray -> . NUMBER
    (89) defarray -> . NUMBER COMA defarray
    (90) defarray -> . STRING
    (91) defarray -> . STRING COMA defarray
    (92) defarray -> . INT
    (93) defarray -> . INT COMA defarray
    (94) defarray -> . FLOAT
    (95) defarray -> . FLOAT COMA defarray
    (96) defarray -> . BOOLEAN
    (97) defarray -> . BOOLEAN COMA defarray

    NUMBER          shift and go to state 75
    STRING          shift and go to state 76
    INT             shift and go to state 77
    FLOAT           shift and go to state 78
    BOOLEAN         shift and go to state 79

    defarray                       shift and go to state 144

state 120

    (2) while -> WHILE logical DO salto code . salto END
    (79) code -> code . code
    (59) salto -> . NEWLINE
    (72) code -> . expr
    (73) code -> . if
    (74) code -> . while
    (75) code -> . expresiones
    (76) code -> . for
    (77) code -> . assign
    (78) code -> . math
    (79) code -> . code code
    (29) expr -> . math
    (30) expr -> . term
    (31) expr -> . variable
    (32) expr -> . assign
    (33) expr -> . array
    (34) expr -> . slice
    (35) expr -> . index
    (60) if -> . IF logical expr END
    (61) if -> . IF logical THEN expr END
    (62) if -> . IF logical
    (63) if -> . IF logical THEN
    (64) if -> . if else
    (65) if -> . if elsif END
    (1) while -> . WHILE logical code END
    (2) while -> . WHILE logical DO salto code salto END
    (3) while -> . WHILE logical DOBLEPOINT salto code salto END
    (4) while -> . BEGIN code END WHILE logical
    (82) expresiones -> . term DOUBLESECUENCEPOINT term
    (83) for -> . FOR iterador IN expresiones code END
    (84) for -> . FOR iterador IN expresiones DO code END
    (85) for -> . FOR iterador IN array code END
    (86) for -> . FOR iterador IN array DO code END
    (5) assign -> . variable ASS expr
    (6) assign -> . variable ASS sexpr
    (7) assign -> . variable ASS array
    (8) math -> . term arith term
    (9) math -> . term arith math
    (10) math -> . variable asig term
    (39) term -> . NUMBER
    (17) variable -> . LOCAL
    (18) variable -> . GLOBAL
    (19) variable -> . CONSTANTS
    (20) variable -> . INSTANCEVAR
    (21) variable -> . CLASSVAR
    (87) array -> . LBRACK defarray RBRACK
    (99) slice -> . variable LBRACK defslice RBRACK
    (98) index -> . variable LBRACK INT RBRACK

    NEWLINE         shift and go to state 82
    IF              shift and go to state 27
    WHILE           shift and go to state 2
    BEGIN           shift and go to state 3
    FOR             shift and go to state 28
    NUMBER          shift and go to state 8
    LOCAL           shift and go to state 9
    GLOBAL          shift and go to state 10
    CONSTANTS       shift and go to state 11
    INSTANCEVAR     shift and go to state 12
    CLASSVAR        shift and go to state 13
    LBRACK          shift and go to state 29

    salto                          shift and go to state 145
    code                           shift and go to state 48
    expr                           shift and go to state 15
    if                             shift and go to state 16
    while                          shift and go to state 17
    expresiones                    shift and go to state 18
    for                            shift and go to state 19
    assign                         shift and go to state 20
    math                           shift and go to state 21
    term                           shift and go to state 22
    variable                       shift and go to state 23
    array                          shift and go to state 24
    slice                          shift and go to state 25
    index                          shift and go to state 26

state 121

    (3) while -> WHILE logical DOBLEPOINT salto code . salto END
    (79) code -> code . code
    (59) salto -> . NEWLINE
    (72) code -> . expr
    (73) code -> . if
    (74) code -> . while
    (75) code -> . expresiones
    (76) code -> . for
    (77) code -> . assign
    (78) code -> . math
    (79) code -> . code code
    (29) expr -> . math
    (30) expr -> . term
    (31) expr -> . variable
    (32) expr -> . assign
    (33) expr -> . array
    (34) expr -> . slice
    (35) expr -> . index
    (60) if -> . IF logical expr END
    (61) if -> . IF logical THEN expr END
    (62) if -> . IF logical
    (63) if -> . IF logical THEN
    (64) if -> . if else
    (65) if -> . if elsif END
    (1) while -> . WHILE logical code END
    (2) while -> . WHILE logical DO salto code salto END
    (3) while -> . WHILE logical DOBLEPOINT salto code salto END
    (4) while -> . BEGIN code END WHILE logical
    (82) expresiones -> . term DOUBLESECUENCEPOINT term
    (83) for -> . FOR iterador IN expresiones code END
    (84) for -> . FOR iterador IN expresiones DO code END
    (85) for -> . FOR iterador IN array code END
    (86) for -> . FOR iterador IN array DO code END
    (5) assign -> . variable ASS expr
    (6) assign -> . variable ASS sexpr
    (7) assign -> . variable ASS array
    (8) math -> . term arith term
    (9) math -> . term arith math
    (10) math -> . variable asig term
    (39) term -> . NUMBER
    (17) variable -> . LOCAL
    (18) variable -> . GLOBAL
    (19) variable -> . CONSTANTS
    (20) variable -> . INSTANCEVAR
    (21) variable -> . CLASSVAR
    (87) array -> . LBRACK defarray RBRACK
    (99) slice -> . variable LBRACK defslice RBRACK
    (98) index -> . variable LBRACK INT RBRACK

    NEWLINE         shift and go to state 82
    IF              shift and go to state 27
    WHILE           shift and go to state 2
    BEGIN           shift and go to state 3
    FOR             shift and go to state 28
    NUMBER          shift and go to state 8
    LOCAL           shift and go to state 9
    GLOBAL          shift and go to state 10
    CONSTANTS       shift and go to state 11
    INSTANCEVAR     shift and go to state 12
    CLASSVAR        shift and go to state 13
    LBRACK          shift and go to state 29

    salto                          shift and go to state 146
    code                           shift and go to state 48
    expr                           shift and go to state 15
    if                             shift and go to state 16
    while                          shift and go to state 17
    expresiones                    shift and go to state 18
    for                            shift and go to state 19
    assign                         shift and go to state 20
    math                           shift and go to state 21
    term                           shift and go to state 22
    variable                       shift and go to state 23
    array                          shift and go to state 24
    slice                          shift and go to state 25
    index                          shift and go to state 26

state 122

    (4) while -> BEGIN code END WHILE logical .
    (15) logical -> logical . logcompare logical
    (53) logcompare -> . ANDLOG
    (54) logcompare -> . ORLOG
    (55) logcompare -> . NOTLOG
    (56) logcompare -> . AND
    (57) logcompare -> . OR
    (58) logcompare -> . NOT

    $end            reduce using rule 4 (while -> BEGIN code END WHILE logical .)
    END             reduce using rule 4 (while -> BEGIN code END WHILE logical .)
    IF              reduce using rule 4 (while -> BEGIN code END WHILE logical .)
    WHILE           reduce using rule 4 (while -> BEGIN code END WHILE logical .)
    BEGIN           reduce using rule 4 (while -> BEGIN code END WHILE logical .)
    FOR             reduce using rule 4 (while -> BEGIN code END WHILE logical .)
    NUMBER          reduce using rule 4 (while -> BEGIN code END WHILE logical .)
    LOCAL           reduce using rule 4 (while -> BEGIN code END WHILE logical .)
    GLOBAL          reduce using rule 4 (while -> BEGIN code END WHILE logical .)
    CONSTANTS       reduce using rule 4 (while -> BEGIN code END WHILE logical .)
    INSTANCEVAR     reduce using rule 4 (while -> BEGIN code END WHILE logical .)
    CLASSVAR        reduce using rule 4 (while -> BEGIN code END WHILE logical .)
    LBRACK          reduce using rule 4 (while -> BEGIN code END WHILE logical .)
    NEWLINE         reduce using rule 4 (while -> BEGIN code END WHILE logical .)
    ANDLOG          shift and go to state 34
    ORLOG           shift and go to state 35
    NOTLOG          shift and go to state 36
    AND             shift and go to state 37
    OR              shift and go to state 38
    NOT             shift and go to state 39

    logcompare                     shift and go to state 33

state 123

    (66) else -> ELSE expr END .

    ELSE            reduce using rule 66 (else -> ELSE expr END .)
    ELSIF           reduce using rule 66 (else -> ELSE expr END .)
    END             reduce using rule 66 (else -> ELSE expr END .)
    IF              reduce using rule 66 (else -> ELSE expr END .)
    WHILE           reduce using rule 66 (else -> ELSE expr END .)
    BEGIN           reduce using rule 66 (else -> ELSE expr END .)
    FOR             reduce using rule 66 (else -> ELSE expr END .)
    NUMBER          reduce using rule 66 (else -> ELSE expr END .)
    LOCAL           reduce using rule 66 (else -> ELSE expr END .)
    GLOBAL          reduce using rule 66 (else -> ELSE expr END .)
    CONSTANTS       reduce using rule 66 (else -> ELSE expr END .)
    INSTANCEVAR     reduce using rule 66 (else -> ELSE expr END .)
    CLASSVAR        reduce using rule 66 (else -> ELSE expr END .)
    LBRACK          reduce using rule 66 (else -> ELSE expr END .)
    NEWLINE         reduce using rule 66 (else -> ELSE expr END .)


state 124

    (67) elsif -> ELSIF logical final .

    END             reduce using rule 67 (elsif -> ELSIF logical final .)


state 125

    (68) final -> expr .
    (70) final -> expr . else
    (71) final -> expr . elsif
    (66) else -> . ELSE expr END
    (67) elsif -> . ELSIF logical final

    END             reduce using rule 68 (final -> expr .)
    ELSE            shift and go to state 52
    ELSIF           shift and go to state 53

    else                           shift and go to state 147
    elsif                          shift and go to state 148

state 126

    (69) final -> THEN . expr
    (29) expr -> . math
    (30) expr -> . term
    (31) expr -> . variable
    (32) expr -> . assign
    (33) expr -> . array
    (34) expr -> . slice
    (35) expr -> . index
    (8) math -> . term arith term
    (9) math -> . term arith math
    (10) math -> . variable asig term
    (39) term -> . NUMBER
    (17) variable -> . LOCAL
    (18) variable -> . GLOBAL
    (19) variable -> . CONSTANTS
    (20) variable -> . INSTANCEVAR
    (21) variable -> . CLASSVAR
    (5) assign -> . variable ASS expr
    (6) assign -> . variable ASS sexpr
    (7) assign -> . variable ASS array
    (87) array -> . LBRACK defarray RBRACK
    (99) slice -> . variable LBRACK defslice RBRACK
    (98) index -> . variable LBRACK INT RBRACK

    NUMBER          shift and go to state 8
    LOCAL           shift and go to state 9
    GLOBAL          shift and go to state 10
    CONSTANTS       shift and go to state 11
    INSTANCEVAR     shift and go to state 12
    CLASSVAR        shift and go to state 13
    LBRACK          shift and go to state 29

    expr                           shift and go to state 149
    math                           shift and go to state 92
    term                           shift and go to state 93
    variable                       shift and go to state 94
    assign                         shift and go to state 95
    array                          shift and go to state 24
    slice                          shift and go to state 25
    index                          shift and go to state 26

state 127

    (22) asig -> ASS .

    NUMBER          reduce using rule 22 (asig -> ASS .)


state 128

    (36) sexpr -> sterm MUL . term
    (39) term -> . NUMBER

    NUMBER          shift and go to state 8

    term                           shift and go to state 150

state 129

    (37) sexpr -> sterm ADD . sexpr
    (36) sexpr -> . sterm MUL term
    (37) sexpr -> . sterm ADD sexpr
    (38) sexpr -> . sterm
    (40) sterm -> . STRING

    STRING          shift and go to state 105

    sterm                          shift and go to state 104
    sexpr                          shift and go to state 151

state 130

    (99) slice -> variable LBRACK defslice RBRACK .

    END             reduce using rule 99 (slice -> variable LBRACK defslice RBRACK .)
    IF              reduce using rule 99 (slice -> variable LBRACK defslice RBRACK .)
    WHILE           reduce using rule 99 (slice -> variable LBRACK defslice RBRACK .)
    BEGIN           reduce using rule 99 (slice -> variable LBRACK defslice RBRACK .)
    FOR             reduce using rule 99 (slice -> variable LBRACK defslice RBRACK .)
    NUMBER          reduce using rule 99 (slice -> variable LBRACK defslice RBRACK .)
    LOCAL           reduce using rule 99 (slice -> variable LBRACK defslice RBRACK .)
    GLOBAL          reduce using rule 99 (slice -> variable LBRACK defslice RBRACK .)
    CONSTANTS       reduce using rule 99 (slice -> variable LBRACK defslice RBRACK .)
    INSTANCEVAR     reduce using rule 99 (slice -> variable LBRACK defslice RBRACK .)
    CLASSVAR        reduce using rule 99 (slice -> variable LBRACK defslice RBRACK .)
    LBRACK          reduce using rule 99 (slice -> variable LBRACK defslice RBRACK .)
    NEWLINE         reduce using rule 99 (slice -> variable LBRACK defslice RBRACK .)
    ELSE            reduce using rule 99 (slice -> variable LBRACK defslice RBRACK .)
    ELSIF           reduce using rule 99 (slice -> variable LBRACK defslice RBRACK .)


state 131

    (98) index -> variable LBRACK INT RBRACK .

    END             reduce using rule 98 (index -> variable LBRACK INT RBRACK .)
    IF              reduce using rule 98 (index -> variable LBRACK INT RBRACK .)
    WHILE           reduce using rule 98 (index -> variable LBRACK INT RBRACK .)
    BEGIN           reduce using rule 98 (index -> variable LBRACK INT RBRACK .)
    FOR             reduce using rule 98 (index -> variable LBRACK INT RBRACK .)
    NUMBER          reduce using rule 98 (index -> variable LBRACK INT RBRACK .)
    LOCAL           reduce using rule 98 (index -> variable LBRACK INT RBRACK .)
    GLOBAL          reduce using rule 98 (index -> variable LBRACK INT RBRACK .)
    CONSTANTS       reduce using rule 98 (index -> variable LBRACK INT RBRACK .)
    INSTANCEVAR     reduce using rule 98 (index -> variable LBRACK INT RBRACK .)
    CLASSVAR        reduce using rule 98 (index -> variable LBRACK INT RBRACK .)
    LBRACK          reduce using rule 98 (index -> variable LBRACK INT RBRACK .)
    NEWLINE         reduce using rule 98 (index -> variable LBRACK INT RBRACK .)
    ELSE            reduce using rule 98 (index -> variable LBRACK INT RBRACK .)
    ELSIF           reduce using rule 98 (index -> variable LBRACK INT RBRACK .)


state 132

    (100) defslice -> INT DOBLEPOINT . INT
    (101) defslice -> INT DOBLEPOINT .

    INT             shift and go to state 152
    RBRACK          reduce using rule 101 (defslice -> INT DOBLEPOINT .)


state 133

    (102) defslice -> DOBLEPOINT INT .

    RBRACK          reduce using rule 102 (defslice -> DOBLEPOINT INT .)


state 134

    (60) if -> IF logical expr END .

    ELSE            reduce using rule 60 (if -> IF logical expr END .)
    ELSIF           reduce using rule 60 (if -> IF logical expr END .)
    END             reduce using rule 60 (if -> IF logical expr END .)
    IF              reduce using rule 60 (if -> IF logical expr END .)
    WHILE           reduce using rule 60 (if -> IF logical expr END .)
    BEGIN           reduce using rule 60 (if -> IF logical expr END .)
    FOR             reduce using rule 60 (if -> IF logical expr END .)
    NUMBER          reduce using rule 60 (if -> IF logical expr END .)
    LOCAL           reduce using rule 60 (if -> IF logical expr END .)
    GLOBAL          reduce using rule 60 (if -> IF logical expr END .)
    CONSTANTS       reduce using rule 60 (if -> IF logical expr END .)
    INSTANCEVAR     reduce using rule 60 (if -> IF logical expr END .)
    CLASSVAR        reduce using rule 60 (if -> IF logical expr END .)
    LBRACK          reduce using rule 60 (if -> IF logical expr END .)
    NEWLINE         reduce using rule 60 (if -> IF logical expr END .)


state 135

    (61) if -> IF logical THEN expr . END

    END             shift and go to state 153


state 136

    (83) for -> FOR iterador IN expresiones . code END
    (84) for -> FOR iterador IN expresiones . DO code END
    (72) code -> . expr
    (73) code -> . if
    (74) code -> . while
    (75) code -> . expresiones
    (76) code -> . for
    (77) code -> . assign
    (78) code -> . math
    (79) code -> . code code
    (29) expr -> . math
    (30) expr -> . term
    (31) expr -> . variable
    (32) expr -> . assign
    (33) expr -> . array
    (34) expr -> . slice
    (35) expr -> . index
    (60) if -> . IF logical expr END
    (61) if -> . IF logical THEN expr END
    (62) if -> . IF logical
    (63) if -> . IF logical THEN
    (64) if -> . if else
    (65) if -> . if elsif END
    (1) while -> . WHILE logical code END
    (2) while -> . WHILE logical DO salto code salto END
    (3) while -> . WHILE logical DOBLEPOINT salto code salto END
    (4) while -> . BEGIN code END WHILE logical
    (82) expresiones -> . term DOUBLESECUENCEPOINT term
    (83) for -> . FOR iterador IN expresiones code END
    (84) for -> . FOR iterador IN expresiones DO code END
    (85) for -> . FOR iterador IN array code END
    (86) for -> . FOR iterador IN array DO code END
    (5) assign -> . variable ASS expr
    (6) assign -> . variable ASS sexpr
    (7) assign -> . variable ASS array
    (8) math -> . term arith term
    (9) math -> . term arith math
    (10) math -> . variable asig term
    (39) term -> . NUMBER
    (17) variable -> . LOCAL
    (18) variable -> . GLOBAL
    (19) variable -> . CONSTANTS
    (20) variable -> . INSTANCEVAR
    (21) variable -> . CLASSVAR
    (87) array -> . LBRACK defarray RBRACK
    (99) slice -> . variable LBRACK defslice RBRACK
    (98) index -> . variable LBRACK INT RBRACK

    DO              shift and go to state 155
    IF              shift and go to state 27
    WHILE           shift and go to state 2
    BEGIN           shift and go to state 3
    FOR             shift and go to state 28
    NUMBER          shift and go to state 8
    LOCAL           shift and go to state 9
    GLOBAL          shift and go to state 10
    CONSTANTS       shift and go to state 11
    INSTANCEVAR     shift and go to state 12
    CLASSVAR        shift and go to state 13
    LBRACK          shift and go to state 29

    expresiones                    shift and go to state 18
    code                           shift and go to state 154
    expr                           shift and go to state 15
    if                             shift and go to state 16
    while                          shift and go to state 17
    for                            shift and go to state 19
    assign                         shift and go to state 20
    math                           shift and go to state 21
    term                           shift and go to state 22
    variable                       shift and go to state 23
    array                          shift and go to state 24
    slice                          shift and go to state 25
    index                          shift and go to state 26

state 137

    (85) for -> FOR iterador IN array . code END
    (86) for -> FOR iterador IN array . DO code END
    (72) code -> . expr
    (73) code -> . if
    (74) code -> . while
    (75) code -> . expresiones
    (76) code -> . for
    (77) code -> . assign
    (78) code -> . math
    (79) code -> . code code
    (29) expr -> . math
    (30) expr -> . term
    (31) expr -> . variable
    (32) expr -> . assign
    (33) expr -> . array
    (34) expr -> . slice
    (35) expr -> . index
    (60) if -> . IF logical expr END
    (61) if -> . IF logical THEN expr END
    (62) if -> . IF logical
    (63) if -> . IF logical THEN
    (64) if -> . if else
    (65) if -> . if elsif END
    (1) while -> . WHILE logical code END
    (2) while -> . WHILE logical DO salto code salto END
    (3) while -> . WHILE logical DOBLEPOINT salto code salto END
    (4) while -> . BEGIN code END WHILE logical
    (82) expresiones -> . term DOUBLESECUENCEPOINT term
    (83) for -> . FOR iterador IN expresiones code END
    (84) for -> . FOR iterador IN expresiones DO code END
    (85) for -> . FOR iterador IN array code END
    (86) for -> . FOR iterador IN array DO code END
    (5) assign -> . variable ASS expr
    (6) assign -> . variable ASS sexpr
    (7) assign -> . variable ASS array
    (8) math -> . term arith term
    (9) math -> . term arith math
    (10) math -> . variable asig term
    (39) term -> . NUMBER
    (17) variable -> . LOCAL
    (18) variable -> . GLOBAL
    (19) variable -> . CONSTANTS
    (20) variable -> . INSTANCEVAR
    (21) variable -> . CLASSVAR
    (87) array -> . LBRACK defarray RBRACK
    (99) slice -> . variable LBRACK defslice RBRACK
    (98) index -> . variable LBRACK INT RBRACK

    DO              shift and go to state 157
    IF              shift and go to state 27
    WHILE           shift and go to state 2
    BEGIN           shift and go to state 3
    FOR             shift and go to state 28
    NUMBER          shift and go to state 8
    LOCAL           shift and go to state 9
    GLOBAL          shift and go to state 10
    CONSTANTS       shift and go to state 11
    INSTANCEVAR     shift and go to state 12
    CLASSVAR        shift and go to state 13
    LBRACK          shift and go to state 29

    array                          shift and go to state 24
    code                           shift and go to state 156
    expr                           shift and go to state 15
    if                             shift and go to state 16
    while                          shift and go to state 17
    expresiones                    shift and go to state 18
    for                            shift and go to state 19
    assign                         shift and go to state 20
    math                           shift and go to state 21
    term                           shift and go to state 22
    variable                       shift and go to state 23
    slice                          shift and go to state 25
    index                          shift and go to state 26

state 138

    (82) expresiones -> term . DOUBLESECUENCEPOINT term

    DOUBLESECUENCEPOINT shift and go to state 54


state 139

    (81) iterador -> variable , variable .

    IN              reduce using rule 81 (iterador -> variable , variable .)


state 140

    (89) defarray -> NUMBER COMA defarray .

    RBRACK          reduce using rule 89 (defarray -> NUMBER COMA defarray .)


state 141

    (91) defarray -> STRING COMA defarray .

    RBRACK          reduce using rule 91 (defarray -> STRING COMA defarray .)


state 142

    (93) defarray -> INT COMA defarray .

    RBRACK          reduce using rule 93 (defarray -> INT COMA defarray .)


state 143

    (95) defarray -> FLOAT COMA defarray .

    RBRACK          reduce using rule 95 (defarray -> FLOAT COMA defarray .)


state 144

    (97) defarray -> BOOLEAN COMA defarray .

    RBRACK          reduce using rule 97 (defarray -> BOOLEAN COMA defarray .)


state 145

    (2) while -> WHILE logical DO salto code salto . END

    END             shift and go to state 158


state 146

    (3) while -> WHILE logical DOBLEPOINT salto code salto . END

    END             shift and go to state 159


state 147

    (70) final -> expr else .

    END             reduce using rule 70 (final -> expr else .)


state 148

    (71) final -> expr elsif .

    END             reduce using rule 71 (final -> expr elsif .)


state 149

    (69) final -> THEN expr .

    END             reduce using rule 69 (final -> THEN expr .)


state 150

    (36) sexpr -> sterm MUL term .

    END             reduce using rule 36 (sexpr -> sterm MUL term .)
    IF              reduce using rule 36 (sexpr -> sterm MUL term .)
    WHILE           reduce using rule 36 (sexpr -> sterm MUL term .)
    BEGIN           reduce using rule 36 (sexpr -> sterm MUL term .)
    FOR             reduce using rule 36 (sexpr -> sterm MUL term .)
    NUMBER          reduce using rule 36 (sexpr -> sterm MUL term .)
    LOCAL           reduce using rule 36 (sexpr -> sterm MUL term .)
    GLOBAL          reduce using rule 36 (sexpr -> sterm MUL term .)
    CONSTANTS       reduce using rule 36 (sexpr -> sterm MUL term .)
    INSTANCEVAR     reduce using rule 36 (sexpr -> sterm MUL term .)
    CLASSVAR        reduce using rule 36 (sexpr -> sterm MUL term .)
    LBRACK          reduce using rule 36 (sexpr -> sterm MUL term .)
    NEWLINE         reduce using rule 36 (sexpr -> sterm MUL term .)
    ELSE            reduce using rule 36 (sexpr -> sterm MUL term .)
    ELSIF           reduce using rule 36 (sexpr -> sterm MUL term .)


state 151

    (37) sexpr -> sterm ADD sexpr .

    END             reduce using rule 37 (sexpr -> sterm ADD sexpr .)
    IF              reduce using rule 37 (sexpr -> sterm ADD sexpr .)
    WHILE           reduce using rule 37 (sexpr -> sterm ADD sexpr .)
    BEGIN           reduce using rule 37 (sexpr -> sterm ADD sexpr .)
    FOR             reduce using rule 37 (sexpr -> sterm ADD sexpr .)
    NUMBER          reduce using rule 37 (sexpr -> sterm ADD sexpr .)
    LOCAL           reduce using rule 37 (sexpr -> sterm ADD sexpr .)
    GLOBAL          reduce using rule 37 (sexpr -> sterm ADD sexpr .)
    CONSTANTS       reduce using rule 37 (sexpr -> sterm ADD sexpr .)
    INSTANCEVAR     reduce using rule 37 (sexpr -> sterm ADD sexpr .)
    CLASSVAR        reduce using rule 37 (sexpr -> sterm ADD sexpr .)
    LBRACK          reduce using rule 37 (sexpr -> sterm ADD sexpr .)
    NEWLINE         reduce using rule 37 (sexpr -> sterm ADD sexpr .)
    ELSE            reduce using rule 37 (sexpr -> sterm ADD sexpr .)
    ELSIF           reduce using rule 37 (sexpr -> sterm ADD sexpr .)


state 152

    (100) defslice -> INT DOBLEPOINT INT .

    RBRACK          reduce using rule 100 (defslice -> INT DOBLEPOINT INT .)


state 153

    (61) if -> IF logical THEN expr END .

    ELSE            reduce using rule 61 (if -> IF logical THEN expr END .)
    ELSIF           reduce using rule 61 (if -> IF logical THEN expr END .)
    END             reduce using rule 61 (if -> IF logical THEN expr END .)
    IF              reduce using rule 61 (if -> IF logical THEN expr END .)
    WHILE           reduce using rule 61 (if -> IF logical THEN expr END .)
    BEGIN           reduce using rule 61 (if -> IF logical THEN expr END .)
    FOR             reduce using rule 61 (if -> IF logical THEN expr END .)
    NUMBER          reduce using rule 61 (if -> IF logical THEN expr END .)
    LOCAL           reduce using rule 61 (if -> IF logical THEN expr END .)
    GLOBAL          reduce using rule 61 (if -> IF logical THEN expr END .)
    CONSTANTS       reduce using rule 61 (if -> IF logical THEN expr END .)
    INSTANCEVAR     reduce using rule 61 (if -> IF logical THEN expr END .)
    CLASSVAR        reduce using rule 61 (if -> IF logical THEN expr END .)
    LBRACK          reduce using rule 61 (if -> IF logical THEN expr END .)
    NEWLINE         reduce using rule 61 (if -> IF logical THEN expr END .)


state 154

    (83) for -> FOR iterador IN expresiones code . END
    (79) code -> code . code
    (72) code -> . expr
    (73) code -> . if
    (74) code -> . while
    (75) code -> . expresiones
    (76) code -> . for
    (77) code -> . assign
    (78) code -> . math
    (79) code -> . code code
    (29) expr -> . math
    (30) expr -> . term
    (31) expr -> . variable
    (32) expr -> . assign
    (33) expr -> . array
    (34) expr -> . slice
    (35) expr -> . index
    (60) if -> . IF logical expr END
    (61) if -> . IF logical THEN expr END
    (62) if -> . IF logical
    (63) if -> . IF logical THEN
    (64) if -> . if else
    (65) if -> . if elsif END
    (1) while -> . WHILE logical code END
    (2) while -> . WHILE logical DO salto code salto END
    (3) while -> . WHILE logical DOBLEPOINT salto code salto END
    (4) while -> . BEGIN code END WHILE logical
    (82) expresiones -> . term DOUBLESECUENCEPOINT term
    (83) for -> . FOR iterador IN expresiones code END
    (84) for -> . FOR iterador IN expresiones DO code END
    (85) for -> . FOR iterador IN array code END
    (86) for -> . FOR iterador IN array DO code END
    (5) assign -> . variable ASS expr
    (6) assign -> . variable ASS sexpr
    (7) assign -> . variable ASS array
    (8) math -> . term arith term
    (9) math -> . term arith math
    (10) math -> . variable asig term
    (39) term -> . NUMBER
    (17) variable -> . LOCAL
    (18) variable -> . GLOBAL
    (19) variable -> . CONSTANTS
    (20) variable -> . INSTANCEVAR
    (21) variable -> . CLASSVAR
    (87) array -> . LBRACK defarray RBRACK
    (99) slice -> . variable LBRACK defslice RBRACK
    (98) index -> . variable LBRACK INT RBRACK

    END             shift and go to state 160
    IF              shift and go to state 27
    WHILE           shift and go to state 2
    BEGIN           shift and go to state 3
    FOR             shift and go to state 28
    NUMBER          shift and go to state 8
    LOCAL           shift and go to state 9
    GLOBAL          shift and go to state 10
    CONSTANTS       shift and go to state 11
    INSTANCEVAR     shift and go to state 12
    CLASSVAR        shift and go to state 13
    LBRACK          shift and go to state 29

    expresiones                    shift and go to state 18
    code                           shift and go to state 48
    expr                           shift and go to state 15
    if                             shift and go to state 16
    while                          shift and go to state 17
    for                            shift and go to state 19
    assign                         shift and go to state 20
    math                           shift and go to state 21
    term                           shift and go to state 22
    variable                       shift and go to state 23
    array                          shift and go to state 24
    slice                          shift and go to state 25
    index                          shift and go to state 26

state 155

    (84) for -> FOR iterador IN expresiones DO . code END
    (72) code -> . expr
    (73) code -> . if
    (74) code -> . while
    (75) code -> . expresiones
    (76) code -> . for
    (77) code -> . assign
    (78) code -> . math
    (79) code -> . code code
    (29) expr -> . math
    (30) expr -> . term
    (31) expr -> . variable
    (32) expr -> . assign
    (33) expr -> . array
    (34) expr -> . slice
    (35) expr -> . index
    (60) if -> . IF logical expr END
    (61) if -> . IF logical THEN expr END
    (62) if -> . IF logical
    (63) if -> . IF logical THEN
    (64) if -> . if else
    (65) if -> . if elsif END
    (1) while -> . WHILE logical code END
    (2) while -> . WHILE logical DO salto code salto END
    (3) while -> . WHILE logical DOBLEPOINT salto code salto END
    (4) while -> . BEGIN code END WHILE logical
    (82) expresiones -> . term DOUBLESECUENCEPOINT term
    (83) for -> . FOR iterador IN expresiones code END
    (84) for -> . FOR iterador IN expresiones DO code END
    (85) for -> . FOR iterador IN array code END
    (86) for -> . FOR iterador IN array DO code END
    (5) assign -> . variable ASS expr
    (6) assign -> . variable ASS sexpr
    (7) assign -> . variable ASS array
    (8) math -> . term arith term
    (9) math -> . term arith math
    (10) math -> . variable asig term
    (39) term -> . NUMBER
    (17) variable -> . LOCAL
    (18) variable -> . GLOBAL
    (19) variable -> . CONSTANTS
    (20) variable -> . INSTANCEVAR
    (21) variable -> . CLASSVAR
    (87) array -> . LBRACK defarray RBRACK
    (99) slice -> . variable LBRACK defslice RBRACK
    (98) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 27
    WHILE           shift and go to state 2
    BEGIN           shift and go to state 3
    FOR             shift and go to state 28
    NUMBER          shift and go to state 8
    LOCAL           shift and go to state 9
    GLOBAL          shift and go to state 10
    CONSTANTS       shift and go to state 11
    INSTANCEVAR     shift and go to state 12
    CLASSVAR        shift and go to state 13
    LBRACK          shift and go to state 29

    expresiones                    shift and go to state 18
    code                           shift and go to state 161
    expr                           shift and go to state 15
    if                             shift and go to state 16
    while                          shift and go to state 17
    for                            shift and go to state 19
    assign                         shift and go to state 20
    math                           shift and go to state 21
    term                           shift and go to state 22
    variable                       shift and go to state 23
    array                          shift and go to state 24
    slice                          shift and go to state 25
    index                          shift and go to state 26

state 156

    (85) for -> FOR iterador IN array code . END
    (79) code -> code . code
    (72) code -> . expr
    (73) code -> . if
    (74) code -> . while
    (75) code -> . expresiones
    (76) code -> . for
    (77) code -> . assign
    (78) code -> . math
    (79) code -> . code code
    (29) expr -> . math
    (30) expr -> . term
    (31) expr -> . variable
    (32) expr -> . assign
    (33) expr -> . array
    (34) expr -> . slice
    (35) expr -> . index
    (60) if -> . IF logical expr END
    (61) if -> . IF logical THEN expr END
    (62) if -> . IF logical
    (63) if -> . IF logical THEN
    (64) if -> . if else
    (65) if -> . if elsif END
    (1) while -> . WHILE logical code END
    (2) while -> . WHILE logical DO salto code salto END
    (3) while -> . WHILE logical DOBLEPOINT salto code salto END
    (4) while -> . BEGIN code END WHILE logical
    (82) expresiones -> . term DOUBLESECUENCEPOINT term
    (83) for -> . FOR iterador IN expresiones code END
    (84) for -> . FOR iterador IN expresiones DO code END
    (85) for -> . FOR iterador IN array code END
    (86) for -> . FOR iterador IN array DO code END
    (5) assign -> . variable ASS expr
    (6) assign -> . variable ASS sexpr
    (7) assign -> . variable ASS array
    (8) math -> . term arith term
    (9) math -> . term arith math
    (10) math -> . variable asig term
    (39) term -> . NUMBER
    (17) variable -> . LOCAL
    (18) variable -> . GLOBAL
    (19) variable -> . CONSTANTS
    (20) variable -> . INSTANCEVAR
    (21) variable -> . CLASSVAR
    (87) array -> . LBRACK defarray RBRACK
    (99) slice -> . variable LBRACK defslice RBRACK
    (98) index -> . variable LBRACK INT RBRACK

    END             shift and go to state 162
    IF              shift and go to state 27
    WHILE           shift and go to state 2
    BEGIN           shift and go to state 3
    FOR             shift and go to state 28
    NUMBER          shift and go to state 8
    LOCAL           shift and go to state 9
    GLOBAL          shift and go to state 10
    CONSTANTS       shift and go to state 11
    INSTANCEVAR     shift and go to state 12
    CLASSVAR        shift and go to state 13
    LBRACK          shift and go to state 29

    array                          shift and go to state 24
    code                           shift and go to state 48
    expr                           shift and go to state 15
    if                             shift and go to state 16
    while                          shift and go to state 17
    expresiones                    shift and go to state 18
    for                            shift and go to state 19
    assign                         shift and go to state 20
    math                           shift and go to state 21
    term                           shift and go to state 22
    variable                       shift and go to state 23
    slice                          shift and go to state 25
    index                          shift and go to state 26

state 157

    (86) for -> FOR iterador IN array DO . code END
    (72) code -> . expr
    (73) code -> . if
    (74) code -> . while
    (75) code -> . expresiones
    (76) code -> . for
    (77) code -> . assign
    (78) code -> . math
    (79) code -> . code code
    (29) expr -> . math
    (30) expr -> . term
    (31) expr -> . variable
    (32) expr -> . assign
    (33) expr -> . array
    (34) expr -> . slice
    (35) expr -> . index
    (60) if -> . IF logical expr END
    (61) if -> . IF logical THEN expr END
    (62) if -> . IF logical
    (63) if -> . IF logical THEN
    (64) if -> . if else
    (65) if -> . if elsif END
    (1) while -> . WHILE logical code END
    (2) while -> . WHILE logical DO salto code salto END
    (3) while -> . WHILE logical DOBLEPOINT salto code salto END
    (4) while -> . BEGIN code END WHILE logical
    (82) expresiones -> . term DOUBLESECUENCEPOINT term
    (83) for -> . FOR iterador IN expresiones code END
    (84) for -> . FOR iterador IN expresiones DO code END
    (85) for -> . FOR iterador IN array code END
    (86) for -> . FOR iterador IN array DO code END
    (5) assign -> . variable ASS expr
    (6) assign -> . variable ASS sexpr
    (7) assign -> . variable ASS array
    (8) math -> . term arith term
    (9) math -> . term arith math
    (10) math -> . variable asig term
    (39) term -> . NUMBER
    (17) variable -> . LOCAL
    (18) variable -> . GLOBAL
    (19) variable -> . CONSTANTS
    (20) variable -> . INSTANCEVAR
    (21) variable -> . CLASSVAR
    (87) array -> . LBRACK defarray RBRACK
    (99) slice -> . variable LBRACK defslice RBRACK
    (98) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 27
    WHILE           shift and go to state 2
    BEGIN           shift and go to state 3
    FOR             shift and go to state 28
    NUMBER          shift and go to state 8
    LOCAL           shift and go to state 9
    GLOBAL          shift and go to state 10
    CONSTANTS       shift and go to state 11
    INSTANCEVAR     shift and go to state 12
    CLASSVAR        shift and go to state 13
    LBRACK          shift and go to state 29

    array                          shift and go to state 24
    code                           shift and go to state 163
    expr                           shift and go to state 15
    if                             shift and go to state 16
    while                          shift and go to state 17
    expresiones                    shift and go to state 18
    for                            shift and go to state 19
    assign                         shift and go to state 20
    math                           shift and go to state 21
    term                           shift and go to state 22
    variable                       shift and go to state 23
    slice                          shift and go to state 25
    index                          shift and go to state 26

state 158

    (2) while -> WHILE logical DO salto code salto END .

    $end            reduce using rule 2 (while -> WHILE logical DO salto code salto END .)
    END             reduce using rule 2 (while -> WHILE logical DO salto code salto END .)
    IF              reduce using rule 2 (while -> WHILE logical DO salto code salto END .)
    WHILE           reduce using rule 2 (while -> WHILE logical DO salto code salto END .)
    BEGIN           reduce using rule 2 (while -> WHILE logical DO salto code salto END .)
    FOR             reduce using rule 2 (while -> WHILE logical DO salto code salto END .)
    NUMBER          reduce using rule 2 (while -> WHILE logical DO salto code salto END .)
    LOCAL           reduce using rule 2 (while -> WHILE logical DO salto code salto END .)
    GLOBAL          reduce using rule 2 (while -> WHILE logical DO salto code salto END .)
    CONSTANTS       reduce using rule 2 (while -> WHILE logical DO salto code salto END .)
    INSTANCEVAR     reduce using rule 2 (while -> WHILE logical DO salto code salto END .)
    CLASSVAR        reduce using rule 2 (while -> WHILE logical DO salto code salto END .)
    LBRACK          reduce using rule 2 (while -> WHILE logical DO salto code salto END .)
    NEWLINE         reduce using rule 2 (while -> WHILE logical DO salto code salto END .)


state 159

    (3) while -> WHILE logical DOBLEPOINT salto code salto END .

    $end            reduce using rule 3 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    END             reduce using rule 3 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    IF              reduce using rule 3 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    WHILE           reduce using rule 3 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    BEGIN           reduce using rule 3 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    FOR             reduce using rule 3 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    NUMBER          reduce using rule 3 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    LOCAL           reduce using rule 3 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    GLOBAL          reduce using rule 3 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    CONSTANTS       reduce using rule 3 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    INSTANCEVAR     reduce using rule 3 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    CLASSVAR        reduce using rule 3 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    LBRACK          reduce using rule 3 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    NEWLINE         reduce using rule 3 (while -> WHILE logical DOBLEPOINT salto code salto END .)


state 160

    (83) for -> FOR iterador IN expresiones code END .

    END             reduce using rule 83 (for -> FOR iterador IN expresiones code END .)
    IF              reduce using rule 83 (for -> FOR iterador IN expresiones code END .)
    WHILE           reduce using rule 83 (for -> FOR iterador IN expresiones code END .)
    BEGIN           reduce using rule 83 (for -> FOR iterador IN expresiones code END .)
    FOR             reduce using rule 83 (for -> FOR iterador IN expresiones code END .)
    NUMBER          reduce using rule 83 (for -> FOR iterador IN expresiones code END .)
    LOCAL           reduce using rule 83 (for -> FOR iterador IN expresiones code END .)
    GLOBAL          reduce using rule 83 (for -> FOR iterador IN expresiones code END .)
    CONSTANTS       reduce using rule 83 (for -> FOR iterador IN expresiones code END .)
    INSTANCEVAR     reduce using rule 83 (for -> FOR iterador IN expresiones code END .)
    CLASSVAR        reduce using rule 83 (for -> FOR iterador IN expresiones code END .)
    LBRACK          reduce using rule 83 (for -> FOR iterador IN expresiones code END .)
    NEWLINE         reduce using rule 83 (for -> FOR iterador IN expresiones code END .)


state 161

    (84) for -> FOR iterador IN expresiones DO code . END
    (79) code -> code . code
    (72) code -> . expr
    (73) code -> . if
    (74) code -> . while
    (75) code -> . expresiones
    (76) code -> . for
    (77) code -> . assign
    (78) code -> . math
    (79) code -> . code code
    (29) expr -> . math
    (30) expr -> . term
    (31) expr -> . variable
    (32) expr -> . assign
    (33) expr -> . array
    (34) expr -> . slice
    (35) expr -> . index
    (60) if -> . IF logical expr END
    (61) if -> . IF logical THEN expr END
    (62) if -> . IF logical
    (63) if -> . IF logical THEN
    (64) if -> . if else
    (65) if -> . if elsif END
    (1) while -> . WHILE logical code END
    (2) while -> . WHILE logical DO salto code salto END
    (3) while -> . WHILE logical DOBLEPOINT salto code salto END
    (4) while -> . BEGIN code END WHILE logical
    (82) expresiones -> . term DOUBLESECUENCEPOINT term
    (83) for -> . FOR iterador IN expresiones code END
    (84) for -> . FOR iterador IN expresiones DO code END
    (85) for -> . FOR iterador IN array code END
    (86) for -> . FOR iterador IN array DO code END
    (5) assign -> . variable ASS expr
    (6) assign -> . variable ASS sexpr
    (7) assign -> . variable ASS array
    (8) math -> . term arith term
    (9) math -> . term arith math
    (10) math -> . variable asig term
    (39) term -> . NUMBER
    (17) variable -> . LOCAL
    (18) variable -> . GLOBAL
    (19) variable -> . CONSTANTS
    (20) variable -> . INSTANCEVAR
    (21) variable -> . CLASSVAR
    (87) array -> . LBRACK defarray RBRACK
    (99) slice -> . variable LBRACK defslice RBRACK
    (98) index -> . variable LBRACK INT RBRACK

    END             shift and go to state 164
    IF              shift and go to state 27
    WHILE           shift and go to state 2
    BEGIN           shift and go to state 3
    FOR             shift and go to state 28
    NUMBER          shift and go to state 8
    LOCAL           shift and go to state 9
    GLOBAL          shift and go to state 10
    CONSTANTS       shift and go to state 11
    INSTANCEVAR     shift and go to state 12
    CLASSVAR        shift and go to state 13
    LBRACK          shift and go to state 29

    expresiones                    shift and go to state 18
    code                           shift and go to state 48
    expr                           shift and go to state 15
    if                             shift and go to state 16
    while                          shift and go to state 17
    for                            shift and go to state 19
    assign                         shift and go to state 20
    math                           shift and go to state 21
    term                           shift and go to state 22
    variable                       shift and go to state 23
    array                          shift and go to state 24
    slice                          shift and go to state 25
    index                          shift and go to state 26

state 162

    (85) for -> FOR iterador IN array code END .

    END             reduce using rule 85 (for -> FOR iterador IN array code END .)
    IF              reduce using rule 85 (for -> FOR iterador IN array code END .)
    WHILE           reduce using rule 85 (for -> FOR iterador IN array code END .)
    BEGIN           reduce using rule 85 (for -> FOR iterador IN array code END .)
    FOR             reduce using rule 85 (for -> FOR iterador IN array code END .)
    NUMBER          reduce using rule 85 (for -> FOR iterador IN array code END .)
    LOCAL           reduce using rule 85 (for -> FOR iterador IN array code END .)
    GLOBAL          reduce using rule 85 (for -> FOR iterador IN array code END .)
    CONSTANTS       reduce using rule 85 (for -> FOR iterador IN array code END .)
    INSTANCEVAR     reduce using rule 85 (for -> FOR iterador IN array code END .)
    CLASSVAR        reduce using rule 85 (for -> FOR iterador IN array code END .)
    LBRACK          reduce using rule 85 (for -> FOR iterador IN array code END .)
    NEWLINE         reduce using rule 85 (for -> FOR iterador IN array code END .)


state 163

    (86) for -> FOR iterador IN array DO code . END
    (79) code -> code . code
    (72) code -> . expr
    (73) code -> . if
    (74) code -> . while
    (75) code -> . expresiones
    (76) code -> . for
    (77) code -> . assign
    (78) code -> . math
    (79) code -> . code code
    (29) expr -> . math
    (30) expr -> . term
    (31) expr -> . variable
    (32) expr -> . assign
    (33) expr -> . array
    (34) expr -> . slice
    (35) expr -> . index
    (60) if -> . IF logical expr END
    (61) if -> . IF logical THEN expr END
    (62) if -> . IF logical
    (63) if -> . IF logical THEN
    (64) if -> . if else
    (65) if -> . if elsif END
    (1) while -> . WHILE logical code END
    (2) while -> . WHILE logical DO salto code salto END
    (3) while -> . WHILE logical DOBLEPOINT salto code salto END
    (4) while -> . BEGIN code END WHILE logical
    (82) expresiones -> . term DOUBLESECUENCEPOINT term
    (83) for -> . FOR iterador IN expresiones code END
    (84) for -> . FOR iterador IN expresiones DO code END
    (85) for -> . FOR iterador IN array code END
    (86) for -> . FOR iterador IN array DO code END
    (5) assign -> . variable ASS expr
    (6) assign -> . variable ASS sexpr
    (7) assign -> . variable ASS array
    (8) math -> . term arith term
    (9) math -> . term arith math
    (10) math -> . variable asig term
    (39) term -> . NUMBER
    (17) variable -> . LOCAL
    (18) variable -> . GLOBAL
    (19) variable -> . CONSTANTS
    (20) variable -> . INSTANCEVAR
    (21) variable -> . CLASSVAR
    (87) array -> . LBRACK defarray RBRACK
    (99) slice -> . variable LBRACK defslice RBRACK
    (98) index -> . variable LBRACK INT RBRACK

    END             shift and go to state 165
    IF              shift and go to state 27
    WHILE           shift and go to state 2
    BEGIN           shift and go to state 3
    FOR             shift and go to state 28
    NUMBER          shift and go to state 8
    LOCAL           shift and go to state 9
    GLOBAL          shift and go to state 10
    CONSTANTS       shift and go to state 11
    INSTANCEVAR     shift and go to state 12
    CLASSVAR        shift and go to state 13
    LBRACK          shift and go to state 29

    array                          shift and go to state 24
    code                           shift and go to state 48
    expr                           shift and go to state 15
    if                             shift and go to state 16
    while                          shift and go to state 17
    expresiones                    shift and go to state 18
    for                            shift and go to state 19
    assign                         shift and go to state 20
    math                           shift and go to state 21
    term                           shift and go to state 22
    variable                       shift and go to state 23
    slice                          shift and go to state 25
    index                          shift and go to state 26

state 164

    (84) for -> FOR iterador IN expresiones DO code END .

    END             reduce using rule 84 (for -> FOR iterador IN expresiones DO code END .)
    IF              reduce using rule 84 (for -> FOR iterador IN expresiones DO code END .)
    WHILE           reduce using rule 84 (for -> FOR iterador IN expresiones DO code END .)
    BEGIN           reduce using rule 84 (for -> FOR iterador IN expresiones DO code END .)
    FOR             reduce using rule 84 (for -> FOR iterador IN expresiones DO code END .)
    NUMBER          reduce using rule 84 (for -> FOR iterador IN expresiones DO code END .)
    LOCAL           reduce using rule 84 (for -> FOR iterador IN expresiones DO code END .)
    GLOBAL          reduce using rule 84 (for -> FOR iterador IN expresiones DO code END .)
    CONSTANTS       reduce using rule 84 (for -> FOR iterador IN expresiones DO code END .)
    INSTANCEVAR     reduce using rule 84 (for -> FOR iterador IN expresiones DO code END .)
    CLASSVAR        reduce using rule 84 (for -> FOR iterador IN expresiones DO code END .)
    LBRACK          reduce using rule 84 (for -> FOR iterador IN expresiones DO code END .)
    NEWLINE         reduce using rule 84 (for -> FOR iterador IN expresiones DO code END .)


state 165

    (86) for -> FOR iterador IN array DO code END .

    END             reduce using rule 86 (for -> FOR iterador IN array DO code END .)
    IF              reduce using rule 86 (for -> FOR iterador IN array DO code END .)
    WHILE           reduce using rule 86 (for -> FOR iterador IN array DO code END .)
    BEGIN           reduce using rule 86 (for -> FOR iterador IN array DO code END .)
    FOR             reduce using rule 86 (for -> FOR iterador IN array DO code END .)
    NUMBER          reduce using rule 86 (for -> FOR iterador IN array DO code END .)
    LOCAL           reduce using rule 86 (for -> FOR iterador IN array DO code END .)
    GLOBAL          reduce using rule 86 (for -> FOR iterador IN array DO code END .)
    CONSTANTS       reduce using rule 86 (for -> FOR iterador IN array DO code END .)
    INSTANCEVAR     reduce using rule 86 (for -> FOR iterador IN array DO code END .)
    CLASSVAR        reduce using rule 86 (for -> FOR iterador IN array DO code END .)
    LBRACK          reduce using rule 86 (for -> FOR iterador IN array DO code END .)
    NEWLINE         reduce using rule 86 (for -> FOR iterador IN array DO code END .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LBRACK in state 23 resolved as shift
WARNING: shift/reduce conflict for IF in state 48 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 48 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 48 resolved as shift
WARNING: shift/reduce conflict for FOR in state 48 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 48 resolved as shift
WARNING: shift/reduce conflict for LOCAL in state 48 resolved as shift
WARNING: shift/reduce conflict for GLOBAL in state 48 resolved as shift
WARNING: shift/reduce conflict for CONSTANTS in state 48 resolved as shift
WARNING: shift/reduce conflict for INSTANCEVAR in state 48 resolved as shift
WARNING: shift/reduce conflict for CLASSVAR in state 48 resolved as shift
WARNING: shift/reduce conflict for LBRACK in state 48 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 62 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 71 resolved as shift
WARNING: shift/reduce conflict for LOCAL in state 71 resolved as shift
WARNING: shift/reduce conflict for GLOBAL in state 71 resolved as shift
WARNING: shift/reduce conflict for CONSTANTS in state 71 resolved as shift
WARNING: shift/reduce conflict for INSTANCEVAR in state 71 resolved as shift
WARNING: shift/reduce conflict for CLASSVAR in state 71 resolved as shift
WARNING: shift/reduce conflict for LBRACK in state 71 resolved as shift
WARNING: shift/reduce conflict for ANDLOG in state 84 resolved as shift
WARNING: shift/reduce conflict for ORLOG in state 84 resolved as shift
WARNING: shift/reduce conflict for NOTLOG in state 84 resolved as shift
WARNING: shift/reduce conflict for AND in state 84 resolved as shift
WARNING: shift/reduce conflict for OR in state 84 resolved as shift
WARNING: shift/reduce conflict for NOT in state 84 resolved as shift
WARNING: shift/reduce conflict for ANDLOG in state 86 resolved as shift
WARNING: shift/reduce conflict for ORLOG in state 86 resolved as shift
WARNING: shift/reduce conflict for NOTLOG in state 86 resolved as shift
WARNING: shift/reduce conflict for AND in state 86 resolved as shift
WARNING: shift/reduce conflict for OR in state 86 resolved as shift
WARNING: shift/reduce conflict for NOT in state 86 resolved as shift
WARNING: shift/reduce conflict for LBRACK in state 94 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 111 resolved as shift
WARNING: shift/reduce conflict for LOCAL in state 111 resolved as shift
WARNING: shift/reduce conflict for GLOBAL in state 111 resolved as shift
WARNING: shift/reduce conflict for CONSTANTS in state 111 resolved as shift
WARNING: shift/reduce conflict for INSTANCEVAR in state 111 resolved as shift
WARNING: shift/reduce conflict for CLASSVAR in state 111 resolved as shift
WARNING: shift/reduce conflict for LBRACK in state 111 resolved as shift
WARNING: reduce/reduce conflict in state 20 resolved using rule (expr -> assign)
WARNING: rejected rule (code -> assign) in state 20
WARNING: reduce/reduce conflict in state 21 resolved using rule (expr -> math)
WARNING: rejected rule (code -> math) in state 21
WARNING: reduce/reduce conflict in state 103 resolved using rule (assign -> variable ASS array)
WARNING: rejected rule (expr -> array) in state 103
WARNING: Rule (code -> assign) is never reduced
WARNING: Rule (code -> math) is never reduced
