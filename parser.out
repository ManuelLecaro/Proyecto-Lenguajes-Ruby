Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ALIAS
    BREAK
    CASE
    CLASS
    DEF
    DEFINED
    DO
    ELSE
    ELSIF
    END
    ENSURE
    ERROR
    FILE
    FOR
    IF
    IN
    LINE
    MODULE
    NEXT
    NIL
    PSEUDO
    REDO
    RESCUE
    RETRY
    RETURN
    SELF
    SUPER
    THEN
    UNDEF
    UNLESS
    UNTIL
    WHEN
    WHILE
    YIELD

Grammar

Rule 0     S' -> assign
Rule 1     assign -> variable ASS expr
Rule 2     assign -> variable ASS sexpr
Rule 3     math -> term arith term
Rule 4     math -> term arith math
Rule 5     math -> variable asig term
Rule 6     variable -> LOCAL
Rule 7     variable -> GLOBAL
Rule 8     variable -> CONSTANTS
Rule 9     variable -> INSTANCEVAR
Rule 10    variable -> CLASSVAR
Rule 11    asig -> ASS
Rule 12    asig -> ADDASS
Rule 13    asig -> SUBASS
Rule 14    asig -> MULASS
Rule 15    asig -> DIVASS
Rule 16    asig -> MODASS
Rule 17    asig -> EXPASS
Rule 18    expr -> expr arith term
Rule 19    expr -> term
Rule 20    expr -> variable
Rule 21    sexpr -> sterm MUL term
Rule 22    sexpr -> sterm ADD sexpr
Rule 23    sexpr -> sterm
Rule 24    term -> NUMBER
Rule 25    sterm -> STRING
Rule 26    arith -> EXP
Rule 27    arith -> MUL
Rule 28    arith -> DIV
Rule 29    arith -> MOD
Rule 30    arith -> ADD
Rule 31    arith -> SUB
Rule 32    logic -> variable comparison variable
Rule 33    logic -> variable EQUAL FALSE
Rule 34    logic -> variable EQUAL TRUE
Rule 35    logic -> variable comparison term
Rule 36    logic -> variable comparison sterm
Rule 37    logic -> logic logcompare logic
Rule 38    comparison -> EQUAL
Rule 39    comparison -> NOTEQ
Rule 40    comparison -> GREATHER
Rule 41    comparison -> LOWER
Rule 42    comparison -> GREATHEREQ
Rule 43    comparison -> LOWEREQ
Rule 44    logcompare -> ANDLOG
Rule 45    logcompare -> ORLOG
Rule 46    logcompare -> NOTLOG
Rule 47    logcompare -> AND
Rule 48    logcompare -> OR
Rule 49    logcompare -> NOT

Terminals, with rules where they appear

ADD                  : 22 30
ADDASS               : 12
ALIAS                : 
AND                  : 47
ANDLOG               : 44
ASS                  : 1 2 11
BREAK                : 
CASE                 : 
CLASS                : 
CLASSVAR             : 10
CONSTANTS            : 8
DEF                  : 
DEFINED              : 
DIV                  : 28
DIVASS               : 15
DO                   : 
ELSE                 : 
ELSIF                : 
END                  : 
ENSURE               : 
EQUAL                : 33 34 38
ERROR                : 
EXP                  : 26
EXPASS               : 17
FALSE                : 33
FILE                 : 
FOR                  : 
GLOBAL               : 7
GREATHER             : 40
GREATHEREQ           : 42
IF                   : 
IN                   : 
INSTANCEVAR          : 9
LINE                 : 
LOCAL                : 6
LOWER                : 41
LOWEREQ              : 43
MOD                  : 29
MODASS               : 16
MODULE               : 
MUL                  : 21 27
MULASS               : 14
NEXT                 : 
NIL                  : 
NOT                  : 49
NOTEQ                : 39
NOTLOG               : 46
NUMBER               : 24
OR                   : 48
ORLOG                : 45
PSEUDO               : 
REDO                 : 
RESCUE               : 
RETRY                : 
RETURN               : 
SELF                 : 
STRING               : 25
SUB                  : 31
SUBASS               : 13
SUPER                : 
THEN                 : 
TRUE                 : 34
UNDEF                : 
UNLESS               : 
UNTIL                : 
WHEN                 : 
WHILE                : 
YIELD                : 
error                : 

Nonterminals, with rules where they appear

arith                : 3 4 18
asig                 : 5
assign               : 0
comparison           : 32 35 36
expr                 : 1 18
logcompare           : 37
logic                : 37 37
math                 : 4
sexpr                : 2 22
sterm                : 21 22 23 36
term                 : 3 3 4 5 18 19 21 35
variable             : 1 2 5 20 32 32 33 34 35 36

Parsing method: LALR

state 0

    (0) S' -> . assign
    (1) assign -> . variable ASS expr
    (2) assign -> . variable ASS sexpr
    (6) variable -> . LOCAL
    (7) variable -> . GLOBAL
    (8) variable -> . CONSTANTS
    (9) variable -> . INSTANCEVAR
    (10) variable -> . CLASSVAR

    LOCAL           shift and go to state 3
    GLOBAL          shift and go to state 4
    CONSTANTS       shift and go to state 5
    INSTANCEVAR     shift and go to state 6
    CLASSVAR        shift and go to state 7

    assign                         shift and go to state 1
    variable                       shift and go to state 2

state 1

    (0) S' -> assign .



state 2

    (1) assign -> variable . ASS expr
    (2) assign -> variable . ASS sexpr

    ASS             shift and go to state 8


state 3

    (6) variable -> LOCAL .

    ASS             reduce using rule 6 (variable -> LOCAL .)
    EXP             reduce using rule 6 (variable -> LOCAL .)
    MUL             reduce using rule 6 (variable -> LOCAL .)
    DIV             reduce using rule 6 (variable -> LOCAL .)
    MOD             reduce using rule 6 (variable -> LOCAL .)
    ADD             reduce using rule 6 (variable -> LOCAL .)
    SUB             reduce using rule 6 (variable -> LOCAL .)
    $end            reduce using rule 6 (variable -> LOCAL .)


state 4

    (7) variable -> GLOBAL .

    ASS             reduce using rule 7 (variable -> GLOBAL .)
    EXP             reduce using rule 7 (variable -> GLOBAL .)
    MUL             reduce using rule 7 (variable -> GLOBAL .)
    DIV             reduce using rule 7 (variable -> GLOBAL .)
    MOD             reduce using rule 7 (variable -> GLOBAL .)
    ADD             reduce using rule 7 (variable -> GLOBAL .)
    SUB             reduce using rule 7 (variable -> GLOBAL .)
    $end            reduce using rule 7 (variable -> GLOBAL .)


state 5

    (8) variable -> CONSTANTS .

    ASS             reduce using rule 8 (variable -> CONSTANTS .)
    EXP             reduce using rule 8 (variable -> CONSTANTS .)
    MUL             reduce using rule 8 (variable -> CONSTANTS .)
    DIV             reduce using rule 8 (variable -> CONSTANTS .)
    MOD             reduce using rule 8 (variable -> CONSTANTS .)
    ADD             reduce using rule 8 (variable -> CONSTANTS .)
    SUB             reduce using rule 8 (variable -> CONSTANTS .)
    $end            reduce using rule 8 (variable -> CONSTANTS .)


state 6

    (9) variable -> INSTANCEVAR .

    ASS             reduce using rule 9 (variable -> INSTANCEVAR .)
    EXP             reduce using rule 9 (variable -> INSTANCEVAR .)
    MUL             reduce using rule 9 (variable -> INSTANCEVAR .)
    DIV             reduce using rule 9 (variable -> INSTANCEVAR .)
    MOD             reduce using rule 9 (variable -> INSTANCEVAR .)
    ADD             reduce using rule 9 (variable -> INSTANCEVAR .)
    SUB             reduce using rule 9 (variable -> INSTANCEVAR .)
    $end            reduce using rule 9 (variable -> INSTANCEVAR .)


state 7

    (10) variable -> CLASSVAR .

    ASS             reduce using rule 10 (variable -> CLASSVAR .)
    EXP             reduce using rule 10 (variable -> CLASSVAR .)
    MUL             reduce using rule 10 (variable -> CLASSVAR .)
    DIV             reduce using rule 10 (variable -> CLASSVAR .)
    MOD             reduce using rule 10 (variable -> CLASSVAR .)
    ADD             reduce using rule 10 (variable -> CLASSVAR .)
    SUB             reduce using rule 10 (variable -> CLASSVAR .)
    $end            reduce using rule 10 (variable -> CLASSVAR .)


state 8

    (1) assign -> variable ASS . expr
    (2) assign -> variable ASS . sexpr
    (18) expr -> . expr arith term
    (19) expr -> . term
    (20) expr -> . variable
    (21) sexpr -> . sterm MUL term
    (22) sexpr -> . sterm ADD sexpr
    (23) sexpr -> . sterm
    (24) term -> . NUMBER
    (6) variable -> . LOCAL
    (7) variable -> . GLOBAL
    (8) variable -> . CONSTANTS
    (9) variable -> . INSTANCEVAR
    (10) variable -> . CLASSVAR
    (25) sterm -> . STRING

    NUMBER          shift and go to state 14
    LOCAL           shift and go to state 3
    GLOBAL          shift and go to state 4
    CONSTANTS       shift and go to state 5
    INSTANCEVAR     shift and go to state 6
    CLASSVAR        shift and go to state 7
    STRING          shift and go to state 15

    variable                       shift and go to state 9
    expr                           shift and go to state 10
    sexpr                          shift and go to state 11
    term                           shift and go to state 12
    sterm                          shift and go to state 13

state 9

    (20) expr -> variable .

    EXP             reduce using rule 20 (expr -> variable .)
    MUL             reduce using rule 20 (expr -> variable .)
    DIV             reduce using rule 20 (expr -> variable .)
    MOD             reduce using rule 20 (expr -> variable .)
    ADD             reduce using rule 20 (expr -> variable .)
    SUB             reduce using rule 20 (expr -> variable .)
    $end            reduce using rule 20 (expr -> variable .)


state 10

    (1) assign -> variable ASS expr .
    (18) expr -> expr . arith term
    (26) arith -> . EXP
    (27) arith -> . MUL
    (28) arith -> . DIV
    (29) arith -> . MOD
    (30) arith -> . ADD
    (31) arith -> . SUB

    $end            reduce using rule 1 (assign -> variable ASS expr .)
    EXP             shift and go to state 17
    MUL             shift and go to state 18
    DIV             shift and go to state 19
    MOD             shift and go to state 20
    ADD             shift and go to state 21
    SUB             shift and go to state 22

    arith                          shift and go to state 16

state 11

    (2) assign -> variable ASS sexpr .

    $end            reduce using rule 2 (assign -> variable ASS sexpr .)


state 12

    (19) expr -> term .

    EXP             reduce using rule 19 (expr -> term .)
    MUL             reduce using rule 19 (expr -> term .)
    DIV             reduce using rule 19 (expr -> term .)
    MOD             reduce using rule 19 (expr -> term .)
    ADD             reduce using rule 19 (expr -> term .)
    SUB             reduce using rule 19 (expr -> term .)
    $end            reduce using rule 19 (expr -> term .)


state 13

    (21) sexpr -> sterm . MUL term
    (22) sexpr -> sterm . ADD sexpr
    (23) sexpr -> sterm .

    MUL             shift and go to state 23
    ADD             shift and go to state 24
    $end            reduce using rule 23 (sexpr -> sterm .)


state 14

    (24) term -> NUMBER .

    EXP             reduce using rule 24 (term -> NUMBER .)
    MUL             reduce using rule 24 (term -> NUMBER .)
    DIV             reduce using rule 24 (term -> NUMBER .)
    MOD             reduce using rule 24 (term -> NUMBER .)
    ADD             reduce using rule 24 (term -> NUMBER .)
    SUB             reduce using rule 24 (term -> NUMBER .)
    $end            reduce using rule 24 (term -> NUMBER .)


state 15

    (25) sterm -> STRING .

    MUL             reduce using rule 25 (sterm -> STRING .)
    ADD             reduce using rule 25 (sterm -> STRING .)
    $end            reduce using rule 25 (sterm -> STRING .)


state 16

    (18) expr -> expr arith . term
    (24) term -> . NUMBER

    NUMBER          shift and go to state 14

    term                           shift and go to state 25

state 17

    (26) arith -> EXP .

    NUMBER          reduce using rule 26 (arith -> EXP .)


state 18

    (27) arith -> MUL .

    NUMBER          reduce using rule 27 (arith -> MUL .)


state 19

    (28) arith -> DIV .

    NUMBER          reduce using rule 28 (arith -> DIV .)


state 20

    (29) arith -> MOD .

    NUMBER          reduce using rule 29 (arith -> MOD .)


state 21

    (30) arith -> ADD .

    NUMBER          reduce using rule 30 (arith -> ADD .)


state 22

    (31) arith -> SUB .

    NUMBER          reduce using rule 31 (arith -> SUB .)


state 23

    (21) sexpr -> sterm MUL . term
    (24) term -> . NUMBER

    NUMBER          shift and go to state 14

    term                           shift and go to state 26

state 24

    (22) sexpr -> sterm ADD . sexpr
    (21) sexpr -> . sterm MUL term
    (22) sexpr -> . sterm ADD sexpr
    (23) sexpr -> . sterm
    (25) sterm -> . STRING

    STRING          shift and go to state 15

    sterm                          shift and go to state 13
    sexpr                          shift and go to state 27

state 25

    (18) expr -> expr arith term .

    EXP             reduce using rule 18 (expr -> expr arith term .)
    MUL             reduce using rule 18 (expr -> expr arith term .)
    DIV             reduce using rule 18 (expr -> expr arith term .)
    MOD             reduce using rule 18 (expr -> expr arith term .)
    ADD             reduce using rule 18 (expr -> expr arith term .)
    SUB             reduce using rule 18 (expr -> expr arith term .)
    $end            reduce using rule 18 (expr -> expr arith term .)


state 26

    (21) sexpr -> sterm MUL term .

    $end            reduce using rule 21 (sexpr -> sterm MUL term .)


state 27

    (22) sexpr -> sterm ADD sexpr .

    $end            reduce using rule 22 (sexpr -> sterm ADD sexpr .)

