Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ALIAS
    BREAK
    CASE
    CLASS
    DEF
    DEFINED
    ENSURE
    ERROR
    FALSE
    FILE
    LINE
    MODULE
    NEXT
    NIL
    PSEUDO
    REDO
    RESCUE
    RETRY
    RETURN
    SELF
    SUPER
    TRUE
    UNDEF
    UNLESS
    UNTIL
    WHEN
    YIELD

Grammar

Rule 0     S' -> assign
Rule 1     assign -> variable ASS expr
Rule 2     assign -> variable ASS sexpr
Rule 3     math -> term arith term
Rule 4     math -> term arith math
Rule 5     math -> variable asig term
Rule 6     logic -> logic_term comparison BOOLEAN
Rule 7     logic -> logic_term comparison logic_term
Rule 8     logic -> logic_term comparison logic
Rule 9     logic_term -> variable
Rule 10    logic_term -> term
Rule 11    logic_term -> sterm
Rule 12    variable -> LOCAL
Rule 13    variable -> GLOBAL
Rule 14    variable -> CONSTANTS
Rule 15    variable -> INSTANCEVAR
Rule 16    variable -> CLASSVAR
Rule 17    asig -> ASS
Rule 18    asig -> ADDASS
Rule 19    asig -> SUBASS
Rule 20    asig -> MULASS
Rule 21    asig -> DIVASS
Rule 22    asig -> MODASS
Rule 23    asig -> EXPASS
Rule 24    expr -> math
Rule 25    expr -> term
Rule 26    expr -> variable
Rule 27    expr -> assign
Rule 28    sexpr -> sterm MUL term
Rule 29    sexpr -> sterm ADD sexpr
Rule 30    sexpr -> sterm
Rule 31    term -> NUMBER
Rule 32    sterm -> STRING
Rule 33    arith -> EXP
Rule 34    arith -> MUL
Rule 35    arith -> DIV
Rule 36    arith -> MOD
Rule 37    arith -> ADD
Rule 38    arith -> SUB
Rule 39    comparison -> EQUAL
Rule 40    comparison -> NOTEQ
Rule 41    comparison -> GREATHER
Rule 42    comparison -> LOWER
Rule 43    comparison -> GREATHEREQ
Rule 44    comparison -> LOWEREQ
Rule 45    logcompare -> ANDLOG
Rule 46    logcompare -> ORLOG
Rule 47    logcompare -> NOTLOG
Rule 48    logcompare -> AND
Rule 49    logcompare -> OR
Rule 50    logcompare -> NOT
Rule 51    salto -> NEWLINE
Rule 52    if -> IF logic expr END
Rule 53    if -> IF logic THEN expr END
Rule 54    if -> IF logic
Rule 55    if -> IF logic THEN
Rule 56    if -> if else
Rule 57    if -> if elsif END
Rule 58    else -> ELSE expr END
Rule 59    elsif -> ELSIF logic expr
Rule 60    elsif -> ELSIF logic THEN expr
Rule 61    elsif -> ELSIF logic expr else
Rule 62    elsif -> ELSIF logic expr elsif
Rule 63    code -> expr
Rule 64    code -> if
Rule 65    while -> WHILE logic code END
Rule 66    while -> WHILE logic DO salto code END
Rule 67    while -> WHILE logic DOBLEPOINT code END
Rule 68    while -> BEGIN code END WHILE logic
Rule 69    iterador -> variable
Rule 70    iterador -> variable , variable
Rule 71    expresiones -> term DOUBLESECUENCEPOINT term
Rule 72    for -> FOR iterador IN expresiones code END
Rule 73    for -> FOR iterador IN expresiones DO code END
Rule 74    for -> FOR iterador IN array code END
Rule 75    for -> FOR iterador IN array DO code END
Rule 76    assarray -> variable ASS array
Rule 77    assarray -> array
Rule 78    array -> LBRACK defarray RBRACK
Rule 79    defarray -> NUMBER
Rule 80    defarray -> NUMBER COMA defarray
Rule 81    defarray -> STRING
Rule 82    defarray -> STRING COMA defarray
Rule 83    defarray -> INT
Rule 84    defarray -> INT COMA defarray
Rule 85    defarray -> FLOAT
Rule 86    defarray -> FLOAT COMA defarray
Rule 87    defarray -> BOOLEAN
Rule 88    defarray -> BOOLEAN COMA defarray
Rule 89    index -> variable LBRACK INT RBRACK
Rule 90    slice -> variable LBRACK defslice RBRACK
Rule 91    defslice -> INT DOBLEPOINT INT
Rule 92    defslice -> INT DOBLEPOINT
Rule 93    defslice -> DOBLEPOINT INT

Terminals, with rules where they appear

,                    : 70
ADD                  : 29 37
ADDASS               : 18
ALIAS                : 
AND                  : 48
ANDLOG               : 45
ASS                  : 1 2 17 76
BEGIN                : 68
BOOLEAN              : 6 87 88
BREAK                : 
CASE                 : 
CLASS                : 
CLASSVAR             : 16
COMA                 : 80 82 84 86 88
CONSTANTS            : 14
DEF                  : 
DEFINED              : 
DIV                  : 35
DIVASS               : 21
DO                   : 66 73 75
DOBLEPOINT           : 67 91 92 93
DOUBLESECUENCEPOINT  : 71
ELSE                 : 58
ELSIF                : 59 60 61 62
END                  : 52 53 57 58 65 66 67 68 72 73 74 75
ENSURE               : 
EQUAL                : 39
ERROR                : 
EXP                  : 33
EXPASS               : 23
FALSE                : 
FILE                 : 
FLOAT                : 85 86
FOR                  : 72 73 74 75
GLOBAL               : 13
GREATHER             : 41
GREATHEREQ           : 43
IF                   : 52 53 54 55
IN                   : 72 73 74 75
INSTANCEVAR          : 15
INT                  : 83 84 89 91 91 92 93
LBRACK               : 78 89 90
LINE                 : 
LOCAL                : 12
LOWER                : 42
LOWEREQ              : 44
MOD                  : 36
MODASS               : 22
MODULE               : 
MUL                  : 28 34
MULASS               : 20
NEWLINE              : 51
NEXT                 : 
NIL                  : 
NOT                  : 50
NOTEQ                : 40
NOTLOG               : 47
NUMBER               : 31 79 80
OR                   : 49
ORLOG                : 46
PSEUDO               : 
RBRACK               : 78 89 90
REDO                 : 
RESCUE               : 
RETRY                : 
RETURN               : 
SELF                 : 
STRING               : 32 81 82
SUB                  : 38
SUBASS               : 19
SUPER                : 
THEN                 : 53 55 60
TRUE                 : 
UNDEF                : 
UNLESS               : 
UNTIL                : 
WHEN                 : 
WHILE                : 65 66 67 68
YIELD                : 
error                : 

Nonterminals, with rules where they appear

arith                : 3 4
array                : 74 75 76 77
asig                 : 5
assarray             : 
assign               : 27 0
code                 : 65 66 67 68 72 73 74 75
comparison           : 6 7 8
defarray             : 78 80 82 84 86 88
defslice             : 90
else                 : 56 61
elsif                : 57 62
expr                 : 1 52 53 58 59 60 61 62 63
expresiones          : 72 73
for                  : 
if                   : 56 57 64
index                : 
iterador             : 72 73 74 75
logcompare           : 
logic                : 8 52 53 54 55 59 60 61 62 65 66 67 68
logic_term           : 6 7 7 8
math                 : 4 24
salto                : 66
sexpr                : 2 29
slice                : 
sterm                : 11 28 29 30
term                 : 3 3 4 5 10 25 28 71 71
variable             : 1 2 5 9 26 69 70 70 76 89 90
while                : 

Parsing method: LALR

state 0

    (0) S' -> . assign
    (1) assign -> . variable ASS expr
    (2) assign -> . variable ASS sexpr
    (12) variable -> . LOCAL
    (13) variable -> . GLOBAL
    (14) variable -> . CONSTANTS
    (15) variable -> . INSTANCEVAR
    (16) variable -> . CLASSVAR

    LOCAL           shift and go to state 3
    GLOBAL          shift and go to state 4
    CONSTANTS       shift and go to state 5
    INSTANCEVAR     shift and go to state 6
    CLASSVAR        shift and go to state 7

    assign                         shift and go to state 1
    variable                       shift and go to state 2

state 1

    (0) S' -> assign .



state 2

    (1) assign -> variable . ASS expr
    (2) assign -> variable . ASS sexpr

    ASS             shift and go to state 8


state 3

    (12) variable -> LOCAL .

    ASS             reduce using rule 12 (variable -> LOCAL .)
    ADDASS          reduce using rule 12 (variable -> LOCAL .)
    SUBASS          reduce using rule 12 (variable -> LOCAL .)
    MULASS          reduce using rule 12 (variable -> LOCAL .)
    DIVASS          reduce using rule 12 (variable -> LOCAL .)
    MODASS          reduce using rule 12 (variable -> LOCAL .)
    EXPASS          reduce using rule 12 (variable -> LOCAL .)
    $end            reduce using rule 12 (variable -> LOCAL .)


state 4

    (13) variable -> GLOBAL .

    ASS             reduce using rule 13 (variable -> GLOBAL .)
    ADDASS          reduce using rule 13 (variable -> GLOBAL .)
    SUBASS          reduce using rule 13 (variable -> GLOBAL .)
    MULASS          reduce using rule 13 (variable -> GLOBAL .)
    DIVASS          reduce using rule 13 (variable -> GLOBAL .)
    MODASS          reduce using rule 13 (variable -> GLOBAL .)
    EXPASS          reduce using rule 13 (variable -> GLOBAL .)
    $end            reduce using rule 13 (variable -> GLOBAL .)


state 5

    (14) variable -> CONSTANTS .

    ASS             reduce using rule 14 (variable -> CONSTANTS .)
    ADDASS          reduce using rule 14 (variable -> CONSTANTS .)
    SUBASS          reduce using rule 14 (variable -> CONSTANTS .)
    MULASS          reduce using rule 14 (variable -> CONSTANTS .)
    DIVASS          reduce using rule 14 (variable -> CONSTANTS .)
    MODASS          reduce using rule 14 (variable -> CONSTANTS .)
    EXPASS          reduce using rule 14 (variable -> CONSTANTS .)
    $end            reduce using rule 14 (variable -> CONSTANTS .)


state 6

    (15) variable -> INSTANCEVAR .

    ASS             reduce using rule 15 (variable -> INSTANCEVAR .)
    ADDASS          reduce using rule 15 (variable -> INSTANCEVAR .)
    SUBASS          reduce using rule 15 (variable -> INSTANCEVAR .)
    MULASS          reduce using rule 15 (variable -> INSTANCEVAR .)
    DIVASS          reduce using rule 15 (variable -> INSTANCEVAR .)
    MODASS          reduce using rule 15 (variable -> INSTANCEVAR .)
    EXPASS          reduce using rule 15 (variable -> INSTANCEVAR .)
    $end            reduce using rule 15 (variable -> INSTANCEVAR .)


state 7

    (16) variable -> CLASSVAR .

    ASS             reduce using rule 16 (variable -> CLASSVAR .)
    ADDASS          reduce using rule 16 (variable -> CLASSVAR .)
    SUBASS          reduce using rule 16 (variable -> CLASSVAR .)
    MULASS          reduce using rule 16 (variable -> CLASSVAR .)
    DIVASS          reduce using rule 16 (variable -> CLASSVAR .)
    MODASS          reduce using rule 16 (variable -> CLASSVAR .)
    EXPASS          reduce using rule 16 (variable -> CLASSVAR .)
    $end            reduce using rule 16 (variable -> CLASSVAR .)


state 8

    (1) assign -> variable ASS . expr
    (2) assign -> variable ASS . sexpr
    (24) expr -> . math
    (25) expr -> . term
    (26) expr -> . variable
    (27) expr -> . assign
    (28) sexpr -> . sterm MUL term
    (29) sexpr -> . sterm ADD sexpr
    (30) sexpr -> . sterm
    (3) math -> . term arith term
    (4) math -> . term arith math
    (5) math -> . variable asig term
    (31) term -> . NUMBER
    (12) variable -> . LOCAL
    (13) variable -> . GLOBAL
    (14) variable -> . CONSTANTS
    (15) variable -> . INSTANCEVAR
    (16) variable -> . CLASSVAR
    (1) assign -> . variable ASS expr
    (2) assign -> . variable ASS sexpr
    (32) sterm -> . STRING

    NUMBER          shift and go to state 16
    LOCAL           shift and go to state 3
    GLOBAL          shift and go to state 4
    CONSTANTS       shift and go to state 5
    INSTANCEVAR     shift and go to state 6
    CLASSVAR        shift and go to state 7
    STRING          shift and go to state 17

    variable                       shift and go to state 9
    expr                           shift and go to state 10
    sexpr                          shift and go to state 11
    math                           shift and go to state 12
    term                           shift and go to state 13
    assign                         shift and go to state 14
    sterm                          shift and go to state 15

state 9

    (26) expr -> variable .
    (5) math -> variable . asig term
    (1) assign -> variable . ASS expr
    (2) assign -> variable . ASS sexpr
    (17) asig -> . ASS
    (18) asig -> . ADDASS
    (19) asig -> . SUBASS
    (20) asig -> . MULASS
    (21) asig -> . DIVASS
    (22) asig -> . MODASS
    (23) asig -> . EXPASS

    $end            reduce using rule 26 (expr -> variable .)
    ASS             shift and go to state 19
    ADDASS          shift and go to state 20
    SUBASS          shift and go to state 21
    MULASS          shift and go to state 22
    DIVASS          shift and go to state 23
    MODASS          shift and go to state 24
    EXPASS          shift and go to state 25

    asig                           shift and go to state 18

state 10

    (1) assign -> variable ASS expr .

    $end            reduce using rule 1 (assign -> variable ASS expr .)


state 11

    (2) assign -> variable ASS sexpr .

    $end            reduce using rule 2 (assign -> variable ASS sexpr .)


state 12

    (24) expr -> math .

    $end            reduce using rule 24 (expr -> math .)


state 13

    (25) expr -> term .
    (3) math -> term . arith term
    (4) math -> term . arith math
    (33) arith -> . EXP
    (34) arith -> . MUL
    (35) arith -> . DIV
    (36) arith -> . MOD
    (37) arith -> . ADD
    (38) arith -> . SUB

    $end            reduce using rule 25 (expr -> term .)
    EXP             shift and go to state 27
    MUL             shift and go to state 28
    DIV             shift and go to state 29
    MOD             shift and go to state 30
    ADD             shift and go to state 31
    SUB             shift and go to state 32

    arith                          shift and go to state 26

state 14

    (27) expr -> assign .

    $end            reduce using rule 27 (expr -> assign .)


state 15

    (28) sexpr -> sterm . MUL term
    (29) sexpr -> sterm . ADD sexpr
    (30) sexpr -> sterm .

    MUL             shift and go to state 33
    ADD             shift and go to state 34
    $end            reduce using rule 30 (sexpr -> sterm .)


state 16

    (31) term -> NUMBER .

    EXP             reduce using rule 31 (term -> NUMBER .)
    MUL             reduce using rule 31 (term -> NUMBER .)
    DIV             reduce using rule 31 (term -> NUMBER .)
    MOD             reduce using rule 31 (term -> NUMBER .)
    ADD             reduce using rule 31 (term -> NUMBER .)
    SUB             reduce using rule 31 (term -> NUMBER .)
    $end            reduce using rule 31 (term -> NUMBER .)


state 17

    (32) sterm -> STRING .

    MUL             reduce using rule 32 (sterm -> STRING .)
    ADD             reduce using rule 32 (sterm -> STRING .)
    $end            reduce using rule 32 (sterm -> STRING .)


state 18

    (5) math -> variable asig . term
    (31) term -> . NUMBER

    NUMBER          shift and go to state 16

    term                           shift and go to state 35

state 19

    (1) assign -> variable ASS . expr
    (2) assign -> variable ASS . sexpr
    (17) asig -> ASS .
    (24) expr -> . math
    (25) expr -> . term
    (26) expr -> . variable
    (27) expr -> . assign
    (28) sexpr -> . sterm MUL term
    (29) sexpr -> . sterm ADD sexpr
    (30) sexpr -> . sterm
    (3) math -> . term arith term
    (4) math -> . term arith math
    (5) math -> . variable asig term
    (31) term -> . NUMBER
    (12) variable -> . LOCAL
    (13) variable -> . GLOBAL
    (14) variable -> . CONSTANTS
    (15) variable -> . INSTANCEVAR
    (16) variable -> . CLASSVAR
    (1) assign -> . variable ASS expr
    (2) assign -> . variable ASS sexpr
    (32) sterm -> . STRING

  ! shift/reduce conflict for NUMBER resolved as shift
    NUMBER          shift and go to state 16
    LOCAL           shift and go to state 3
    GLOBAL          shift and go to state 4
    CONSTANTS       shift and go to state 5
    INSTANCEVAR     shift and go to state 6
    CLASSVAR        shift and go to state 7
    STRING          shift and go to state 17

  ! NUMBER          [ reduce using rule 17 (asig -> ASS .) ]

    variable                       shift and go to state 9
    expr                           shift and go to state 10
    sexpr                          shift and go to state 11
    math                           shift and go to state 12
    term                           shift and go to state 13
    assign                         shift and go to state 14
    sterm                          shift and go to state 15

state 20

    (18) asig -> ADDASS .

    NUMBER          reduce using rule 18 (asig -> ADDASS .)


state 21

    (19) asig -> SUBASS .

    NUMBER          reduce using rule 19 (asig -> SUBASS .)


state 22

    (20) asig -> MULASS .

    NUMBER          reduce using rule 20 (asig -> MULASS .)


state 23

    (21) asig -> DIVASS .

    NUMBER          reduce using rule 21 (asig -> DIVASS .)


state 24

    (22) asig -> MODASS .

    NUMBER          reduce using rule 22 (asig -> MODASS .)


state 25

    (23) asig -> EXPASS .

    NUMBER          reduce using rule 23 (asig -> EXPASS .)


state 26

    (3) math -> term arith . term
    (4) math -> term arith . math
    (31) term -> . NUMBER
    (3) math -> . term arith term
    (4) math -> . term arith math
    (5) math -> . variable asig term
    (12) variable -> . LOCAL
    (13) variable -> . GLOBAL
    (14) variable -> . CONSTANTS
    (15) variable -> . INSTANCEVAR
    (16) variable -> . CLASSVAR

    NUMBER          shift and go to state 16
    LOCAL           shift and go to state 3
    GLOBAL          shift and go to state 4
    CONSTANTS       shift and go to state 5
    INSTANCEVAR     shift and go to state 6
    CLASSVAR        shift and go to state 7

    term                           shift and go to state 36
    math                           shift and go to state 37
    variable                       shift and go to state 38

state 27

    (33) arith -> EXP .

    NUMBER          reduce using rule 33 (arith -> EXP .)
    LOCAL           reduce using rule 33 (arith -> EXP .)
    GLOBAL          reduce using rule 33 (arith -> EXP .)
    CONSTANTS       reduce using rule 33 (arith -> EXP .)
    INSTANCEVAR     reduce using rule 33 (arith -> EXP .)
    CLASSVAR        reduce using rule 33 (arith -> EXP .)


state 28

    (34) arith -> MUL .

    NUMBER          reduce using rule 34 (arith -> MUL .)
    LOCAL           reduce using rule 34 (arith -> MUL .)
    GLOBAL          reduce using rule 34 (arith -> MUL .)
    CONSTANTS       reduce using rule 34 (arith -> MUL .)
    INSTANCEVAR     reduce using rule 34 (arith -> MUL .)
    CLASSVAR        reduce using rule 34 (arith -> MUL .)


state 29

    (35) arith -> DIV .

    NUMBER          reduce using rule 35 (arith -> DIV .)
    LOCAL           reduce using rule 35 (arith -> DIV .)
    GLOBAL          reduce using rule 35 (arith -> DIV .)
    CONSTANTS       reduce using rule 35 (arith -> DIV .)
    INSTANCEVAR     reduce using rule 35 (arith -> DIV .)
    CLASSVAR        reduce using rule 35 (arith -> DIV .)


state 30

    (36) arith -> MOD .

    NUMBER          reduce using rule 36 (arith -> MOD .)
    LOCAL           reduce using rule 36 (arith -> MOD .)
    GLOBAL          reduce using rule 36 (arith -> MOD .)
    CONSTANTS       reduce using rule 36 (arith -> MOD .)
    INSTANCEVAR     reduce using rule 36 (arith -> MOD .)
    CLASSVAR        reduce using rule 36 (arith -> MOD .)


state 31

    (37) arith -> ADD .

    NUMBER          reduce using rule 37 (arith -> ADD .)
    LOCAL           reduce using rule 37 (arith -> ADD .)
    GLOBAL          reduce using rule 37 (arith -> ADD .)
    CONSTANTS       reduce using rule 37 (arith -> ADD .)
    INSTANCEVAR     reduce using rule 37 (arith -> ADD .)
    CLASSVAR        reduce using rule 37 (arith -> ADD .)


state 32

    (38) arith -> SUB .

    NUMBER          reduce using rule 38 (arith -> SUB .)
    LOCAL           reduce using rule 38 (arith -> SUB .)
    GLOBAL          reduce using rule 38 (arith -> SUB .)
    CONSTANTS       reduce using rule 38 (arith -> SUB .)
    INSTANCEVAR     reduce using rule 38 (arith -> SUB .)
    CLASSVAR        reduce using rule 38 (arith -> SUB .)


state 33

    (28) sexpr -> sterm MUL . term
    (31) term -> . NUMBER

    NUMBER          shift and go to state 16

    term                           shift and go to state 39

state 34

    (29) sexpr -> sterm ADD . sexpr
    (28) sexpr -> . sterm MUL term
    (29) sexpr -> . sterm ADD sexpr
    (30) sexpr -> . sterm
    (32) sterm -> . STRING

    STRING          shift and go to state 17

    sterm                          shift and go to state 15
    sexpr                          shift and go to state 40

state 35

    (5) math -> variable asig term .

    $end            reduce using rule 5 (math -> variable asig term .)


state 36

    (3) math -> term arith term .
    (3) math -> term . arith term
    (4) math -> term . arith math
    (33) arith -> . EXP
    (34) arith -> . MUL
    (35) arith -> . DIV
    (36) arith -> . MOD
    (37) arith -> . ADD
    (38) arith -> . SUB

    $end            reduce using rule 3 (math -> term arith term .)
    EXP             shift and go to state 27
    MUL             shift and go to state 28
    DIV             shift and go to state 29
    MOD             shift and go to state 30
    ADD             shift and go to state 31
    SUB             shift and go to state 32

    arith                          shift and go to state 26

state 37

    (4) math -> term arith math .

    $end            reduce using rule 4 (math -> term arith math .)


state 38

    (5) math -> variable . asig term
    (17) asig -> . ASS
    (18) asig -> . ADDASS
    (19) asig -> . SUBASS
    (20) asig -> . MULASS
    (21) asig -> . DIVASS
    (22) asig -> . MODASS
    (23) asig -> . EXPASS

    ASS             shift and go to state 41
    ADDASS          shift and go to state 20
    SUBASS          shift and go to state 21
    MULASS          shift and go to state 22
    DIVASS          shift and go to state 23
    MODASS          shift and go to state 24
    EXPASS          shift and go to state 25

    asig                           shift and go to state 18

state 39

    (28) sexpr -> sterm MUL term .

    $end            reduce using rule 28 (sexpr -> sterm MUL term .)


state 40

    (29) sexpr -> sterm ADD sexpr .

    $end            reduce using rule 29 (sexpr -> sterm ADD sexpr .)


state 41

    (17) asig -> ASS .

    NUMBER          reduce using rule 17 (asig -> ASS .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for NUMBER in state 19 resolved as shift
