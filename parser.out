Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    UNTIL
    CASE
    DEFINED
    ENSURE
    RETURN
    UNDEF
    MODULE
    DEF
    SUPER
    PSEUDO
    SELF
    UNLESS
    FILE
    REDO
    WHEN
    NIL
    ERROR
    BREAK
    CLASS
    NEXT
    RESCUE
    RETRY
    ALIAS
    LINE
    YIELD

Grammar

Rule 0     S' -> code
Rule 1     code -> expr
Rule 2     code -> if
Rule 3     code -> while
Rule 4     code -> expresiones
Rule 5     code -> for
Rule 6     code -> assign
Rule 7     code -> code code
Rule 8     while -> WHILE logical code END
Rule 9     while -> WHILE logical DO salto code salto END
Rule 10    while -> WHILE logical DOBLEPOINT salto code salto END
Rule 11    while -> BEGIN code END WHILE logical
Rule 12    logical -> term comparison term
Rule 13    logical -> term comparison logical
Rule 14    logical -> variable comparison term
Rule 15    logical -> variable comparison boolean
Rule 16    logical -> logical logcompare logical
Rule 17    logical -> boolean
Rule 18    comparison -> EQUAL
Rule 19    comparison -> NOTEQ
Rule 20    comparison -> GREATHER
Rule 21    comparison -> LOWER
Rule 22    comparison -> GREATHEREQ
Rule 23    comparison -> LOWEREQ
Rule 24    logcompare -> ANDLOG
Rule 25    logcompare -> ORLOG
Rule 26    logcompare -> NOTLOG
Rule 27    logcompare -> AND
Rule 28    logcompare -> OR
Rule 29    logcompare -> NOT
Rule 30    assign -> variable ASS expr
Rule 31    assign -> variable ASS sexpr
Rule 32    assign -> variable ASS array
Rule 33    math -> term arith term
Rule 34    math -> term arith math
Rule 35    math -> variable asig term
Rule 36    variable -> LOCAL
Rule 37    variable -> GLOBAL
Rule 38    variable -> CONSTANTS
Rule 39    variable -> INSTANCEVAR
Rule 40    variable -> CLASSVAR
Rule 41    asig -> ASS
Rule 42    asig -> ADDASS
Rule 43    asig -> SUBASS
Rule 44    asig -> MULASS
Rule 45    asig -> DIVASS
Rule 46    asig -> MODASS
Rule 47    asig -> EXPASS
Rule 48    expr -> math
Rule 49    expr -> term
Rule 50    expr -> sterm
Rule 51    expr -> variable
Rule 52    expr -> slice
Rule 53    expr -> index
Rule 54    sexpr -> sterm MUL term
Rule 55    sexpr -> sterm ADD sexpr
Rule 56    term -> NUMBER
Rule 57    term -> FLOAT
Rule 58    sterm -> STRING
Rule 59    arith -> EXP
Rule 60    arith -> MUL
Rule 61    arith -> DIV
Rule 62    arith -> MOD
Rule 63    arith -> ADD
Rule 64    arith -> SUB
Rule 65    for -> FOR iterador IN expresiones code END
Rule 66    for -> FOR iterador IN expresiones DO code END
Rule 67    for -> FOR iterador IN array code END
Rule 68    for -> FOR iterador IN array DO code END
Rule 69    salto -> NEWLINE
Rule 70    if -> IF logical expr END
Rule 71    if -> IF logical THEN expr END
Rule 72    if -> IF logical
Rule 73    if -> IF logical THEN
Rule 74    if -> if else
Rule 75    if -> if elsif END
Rule 76    else -> ELSE code END
Rule 77    elsif -> ELSIF logical final
Rule 78    final -> code
Rule 79    final -> THEN code
Rule 80    final -> code else
Rule 81    final -> code elsif
Rule 82    iterador -> variable
Rule 83    iterador -> variable COMA variable
Rule 84    expresiones -> term DOUBLESECUENCEPOINT term
Rule 85    array -> LBRACK defarray RBRACK
Rule 86    defarray -> NUMBER
Rule 87    defarray -> NUMBER COMA defarray
Rule 88    defarray -> STRING
Rule 89    defarray -> STRING COMA defarray
Rule 90    defarray -> INT
Rule 91    defarray -> INT COMA defarray
Rule 92    defarray -> FLOAT
Rule 93    defarray -> FLOAT COMA defarray
Rule 94    defarray -> boolean
Rule 95    defarray -> boolean COMA defarray
Rule 96    index -> variable LBRACK INT RBRACK
Rule 97    slice -> variable LBRACK defslice RBRACK
Rule 98    defslice -> INT DOBLEPOINT INT
Rule 99    defslice -> INT DOBLEPOINT
Rule 100   defslice -> DOBLEPOINT INT
Rule 101   boolean -> TRUE
Rule 102   boolean -> FALSE

Terminals, with rules where they appear

ADD                  : 55 63
ADDASS               : 42
ALIAS                : 
AND                  : 27
ANDLOG               : 24
ASS                  : 30 31 32 41
BEGIN                : 11
BREAK                : 
CASE                 : 
CLASS                : 
CLASSVAR             : 40
COMA                 : 83 87 89 91 93 95
CONSTANTS            : 38
DEF                  : 
DEFINED              : 
DIV                  : 61
DIVASS               : 45
DO                   : 9 66 68
DOBLEPOINT           : 10 98 99 100
DOUBLESECUENCEPOINT  : 84
ELSE                 : 76
ELSIF                : 77
END                  : 8 9 10 11 65 66 67 68 70 71 75 76
ENSURE               : 
EQUAL                : 18
ERROR                : 
EXP                  : 59
EXPASS               : 47
FALSE                : 102
FILE                 : 
FLOAT                : 57 92 93
FOR                  : 65 66 67 68
GLOBAL               : 37
GREATHER             : 20
GREATHEREQ           : 22
IF                   : 70 71 72 73
IN                   : 65 66 67 68
INSTANCEVAR          : 39
INT                  : 90 91 96 98 98 99 100
LBRACK               : 85 96 97
LINE                 : 
LOCAL                : 36
LOWER                : 21
LOWEREQ              : 23
MOD                  : 62
MODASS               : 46
MODULE               : 
MUL                  : 54 60
MULASS               : 44
NEWLINE              : 69
NEXT                 : 
NIL                  : 
NOT                  : 29
NOTEQ                : 19
NOTLOG               : 26
NUMBER               : 56 86 87
OR                   : 28
ORLOG                : 25
PSEUDO               : 
RBRACK               : 85 96 97
REDO                 : 
RESCUE               : 
RETRY                : 
RETURN               : 
SELF                 : 
STRING               : 58 88 89
SUB                  : 64
SUBASS               : 43
SUPER                : 
THEN                 : 71 73 79
TRUE                 : 101
UNDEF                : 
UNLESS               : 
UNTIL                : 
WHEN                 : 
WHILE                : 8 9 10 11
YIELD                : 
error                : 

Nonterminals, with rules where they appear

arith                : 33 34
array                : 32 67 68
asig                 : 35
assign               : 6
boolean              : 15 17 94 95
code                 : 7 7 8 9 10 11 65 66 67 68 76 78 79 80 81 0
comparison           : 12 13 14 15
defarray             : 85 87 89 91 93 95
defslice             : 97
else                 : 74 80
elsif                : 75 81
expr                 : 1 30 70 71
expresiones          : 4 65 66
final                : 77
for                  : 5
if                   : 2 74 75
index                : 53
iterador             : 65 66 67 68
logcompare           : 16
logical              : 8 9 10 11 13 16 16 70 71 72 73 77
math                 : 34 48
salto                : 9 9 10 10
sexpr                : 31 55
slice                : 52
sterm                : 50 54 55
term                 : 12 12 13 14 33 33 34 35 49 54 84 84
variable             : 14 15 30 31 32 35 51 82 83 83 96 97
while                : 3

Parsing method: LALR

state 0

    (0) S' -> . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (70) if -> . IF logical expr END
    (71) if -> . IF logical THEN expr END
    (72) if -> . IF logical
    (73) if -> . IF logical THEN
    (74) if -> . if else
    (75) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (84) expresiones -> . term DOUBLESECUENCEPOINT term
    (65) for -> . FOR iterador IN expresiones code END
    (66) for -> . FOR iterador IN expresiones DO code END
    (67) for -> . FOR iterador IN array code END
    (68) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (58) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (97) slice -> . variable LBRACK defslice RBRACK
    (96) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 6
    WHILE           shift and go to state 8
    BEGIN           shift and go to state 7
    FOR             shift and go to state 11
    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    STRING          shift and go to state 18
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21

    expr                           shift and go to state 1
    slice                          shift and go to state 13
    if                             shift and go to state 2
    expresiones                    shift and go to state 15
    sterm                          shift and go to state 3
    for                            shift and go to state 16
    term                           shift and go to state 17
    code                           shift and go to state 4
    assign                         shift and go to state 23
    math                           shift and go to state 22
    while                          shift and go to state 9
    index                          shift and go to state 10
    variable                       shift and go to state 25

state 1

    (1) code -> expr .

    IF              reduce using rule 1 (code -> expr .)
    WHILE           reduce using rule 1 (code -> expr .)
    BEGIN           reduce using rule 1 (code -> expr .)
    FOR             reduce using rule 1 (code -> expr .)
    NUMBER          reduce using rule 1 (code -> expr .)
    FLOAT           reduce using rule 1 (code -> expr .)
    STRING          reduce using rule 1 (code -> expr .)
    LOCAL           reduce using rule 1 (code -> expr .)
    GLOBAL          reduce using rule 1 (code -> expr .)
    CONSTANTS       reduce using rule 1 (code -> expr .)
    INSTANCEVAR     reduce using rule 1 (code -> expr .)
    CLASSVAR        reduce using rule 1 (code -> expr .)
    END             reduce using rule 1 (code -> expr .)
    NEWLINE         reduce using rule 1 (code -> expr .)
    $end            reduce using rule 1 (code -> expr .)
    ELSE            reduce using rule 1 (code -> expr .)
    ELSIF           reduce using rule 1 (code -> expr .)


state 2

    (2) code -> if .
    (74) if -> if . else
    (75) if -> if . elsif END
    (76) else -> . ELSE code END
    (77) elsif -> . ELSIF logical final

  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
    IF              reduce using rule 2 (code -> if .)
    WHILE           reduce using rule 2 (code -> if .)
    BEGIN           reduce using rule 2 (code -> if .)
    FOR             reduce using rule 2 (code -> if .)
    NUMBER          reduce using rule 2 (code -> if .)
    FLOAT           reduce using rule 2 (code -> if .)
    STRING          reduce using rule 2 (code -> if .)
    LOCAL           reduce using rule 2 (code -> if .)
    GLOBAL          reduce using rule 2 (code -> if .)
    CONSTANTS       reduce using rule 2 (code -> if .)
    INSTANCEVAR     reduce using rule 2 (code -> if .)
    CLASSVAR        reduce using rule 2 (code -> if .)
    END             reduce using rule 2 (code -> if .)
    NEWLINE         reduce using rule 2 (code -> if .)
    $end            reduce using rule 2 (code -> if .)
    ELSE            shift and go to state 29
    ELSIF           shift and go to state 26

  ! ELSE            [ reduce using rule 2 (code -> if .) ]
  ! ELSIF           [ reduce using rule 2 (code -> if .) ]

    elsif                          shift and go to state 27
    else                           shift and go to state 28

state 3

    (50) expr -> sterm .

    END             reduce using rule 50 (expr -> sterm .)
    IF              reduce using rule 50 (expr -> sterm .)
    WHILE           reduce using rule 50 (expr -> sterm .)
    BEGIN           reduce using rule 50 (expr -> sterm .)
    FOR             reduce using rule 50 (expr -> sterm .)
    NUMBER          reduce using rule 50 (expr -> sterm .)
    FLOAT           reduce using rule 50 (expr -> sterm .)
    STRING          reduce using rule 50 (expr -> sterm .)
    LOCAL           reduce using rule 50 (expr -> sterm .)
    GLOBAL          reduce using rule 50 (expr -> sterm .)
    CONSTANTS       reduce using rule 50 (expr -> sterm .)
    INSTANCEVAR     reduce using rule 50 (expr -> sterm .)
    CLASSVAR        reduce using rule 50 (expr -> sterm .)
    $end            reduce using rule 50 (expr -> sterm .)
    NEWLINE         reduce using rule 50 (expr -> sterm .)
    ELSE            reduce using rule 50 (expr -> sterm .)
    ELSIF           reduce using rule 50 (expr -> sterm .)


state 4

    (0) S' -> code .
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (70) if -> . IF logical expr END
    (71) if -> . IF logical THEN expr END
    (72) if -> . IF logical
    (73) if -> . IF logical THEN
    (74) if -> . if else
    (75) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (84) expresiones -> . term DOUBLESECUENCEPOINT term
    (65) for -> . FOR iterador IN expresiones code END
    (66) for -> . FOR iterador IN expresiones DO code END
    (67) for -> . FOR iterador IN array code END
    (68) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (58) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (97) slice -> . variable LBRACK defslice RBRACK
    (96) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 6
    WHILE           shift and go to state 8
    BEGIN           shift and go to state 7
    FOR             shift and go to state 11
    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    STRING          shift and go to state 18
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21

    expr                           shift and go to state 1
    slice                          shift and go to state 13
    if                             shift and go to state 2
    expresiones                    shift and go to state 15
    sterm                          shift and go to state 3
    for                            shift and go to state 16
    term                           shift and go to state 17
    code                           shift and go to state 30
    assign                         shift and go to state 23
    math                           shift and go to state 22
    while                          shift and go to state 9
    index                          shift and go to state 10
    variable                       shift and go to state 25

state 5

    (56) term -> NUMBER .

    THEN            reduce using rule 56 (term -> NUMBER .)
    ANDLOG          reduce using rule 56 (term -> NUMBER .)
    ORLOG           reduce using rule 56 (term -> NUMBER .)
    NOTLOG          reduce using rule 56 (term -> NUMBER .)
    AND             reduce using rule 56 (term -> NUMBER .)
    OR              reduce using rule 56 (term -> NUMBER .)
    NOT             reduce using rule 56 (term -> NUMBER .)
    NUMBER          reduce using rule 56 (term -> NUMBER .)
    FLOAT           reduce using rule 56 (term -> NUMBER .)
    STRING          reduce using rule 56 (term -> NUMBER .)
    LOCAL           reduce using rule 56 (term -> NUMBER .)
    GLOBAL          reduce using rule 56 (term -> NUMBER .)
    CONSTANTS       reduce using rule 56 (term -> NUMBER .)
    INSTANCEVAR     reduce using rule 56 (term -> NUMBER .)
    CLASSVAR        reduce using rule 56 (term -> NUMBER .)
    ELSE            reduce using rule 56 (term -> NUMBER .)
    ELSIF           reduce using rule 56 (term -> NUMBER .)
    IF              reduce using rule 56 (term -> NUMBER .)
    WHILE           reduce using rule 56 (term -> NUMBER .)
    BEGIN           reduce using rule 56 (term -> NUMBER .)
    FOR             reduce using rule 56 (term -> NUMBER .)
    $end            reduce using rule 56 (term -> NUMBER .)
    END             reduce using rule 56 (term -> NUMBER .)
    NEWLINE         reduce using rule 56 (term -> NUMBER .)
    DO              reduce using rule 56 (term -> NUMBER .)
    DOBLEPOINT      reduce using rule 56 (term -> NUMBER .)
    EXP             reduce using rule 56 (term -> NUMBER .)
    MUL             reduce using rule 56 (term -> NUMBER .)
    DIV             reduce using rule 56 (term -> NUMBER .)
    MOD             reduce using rule 56 (term -> NUMBER .)
    ADD             reduce using rule 56 (term -> NUMBER .)
    SUB             reduce using rule 56 (term -> NUMBER .)
    DOUBLESECUENCEPOINT reduce using rule 56 (term -> NUMBER .)
    EQUAL           reduce using rule 56 (term -> NUMBER .)
    NOTEQ           reduce using rule 56 (term -> NUMBER .)
    GREATHER        reduce using rule 56 (term -> NUMBER .)
    LOWER           reduce using rule 56 (term -> NUMBER .)
    GREATHEREQ      reduce using rule 56 (term -> NUMBER .)
    LOWEREQ         reduce using rule 56 (term -> NUMBER .)


state 6

    (70) if -> IF . logical expr END
    (71) if -> IF . logical THEN expr END
    (72) if -> IF . logical
    (73) if -> IF . logical THEN
    (12) logical -> . term comparison term
    (13) logical -> . term comparison logical
    (14) logical -> . variable comparison term
    (15) logical -> . variable comparison boolean
    (16) logical -> . logical logcompare logical
    (17) logical -> . boolean
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (101) boolean -> . TRUE
    (102) boolean -> . FALSE

    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21
    TRUE            shift and go to state 35
    FALSE           shift and go to state 31

    term                           shift and go to state 32
    logical                        shift and go to state 33
    variable                       shift and go to state 34
    boolean                        shift and go to state 36

state 7

    (11) while -> BEGIN . code END WHILE logical
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (70) if -> . IF logical expr END
    (71) if -> . IF logical THEN expr END
    (72) if -> . IF logical
    (73) if -> . IF logical THEN
    (74) if -> . if else
    (75) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (84) expresiones -> . term DOUBLESECUENCEPOINT term
    (65) for -> . FOR iterador IN expresiones code END
    (66) for -> . FOR iterador IN expresiones DO code END
    (67) for -> . FOR iterador IN array code END
    (68) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (58) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (97) slice -> . variable LBRACK defslice RBRACK
    (96) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 6
    WHILE           shift and go to state 8
    BEGIN           shift and go to state 7
    FOR             shift and go to state 11
    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    STRING          shift and go to state 18
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21

    expr                           shift and go to state 1
    slice                          shift and go to state 13
    if                             shift and go to state 2
    expresiones                    shift and go to state 15
    sterm                          shift and go to state 3
    for                            shift and go to state 16
    term                           shift and go to state 17
    code                           shift and go to state 37
    assign                         shift and go to state 23
    math                           shift and go to state 22
    while                          shift and go to state 9
    index                          shift and go to state 10
    variable                       shift and go to state 25

state 8

    (8) while -> WHILE . logical code END
    (9) while -> WHILE . logical DO salto code salto END
    (10) while -> WHILE . logical DOBLEPOINT salto code salto END
    (12) logical -> . term comparison term
    (13) logical -> . term comparison logical
    (14) logical -> . variable comparison term
    (15) logical -> . variable comparison boolean
    (16) logical -> . logical logcompare logical
    (17) logical -> . boolean
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (101) boolean -> . TRUE
    (102) boolean -> . FALSE

    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21
    TRUE            shift and go to state 35
    FALSE           shift and go to state 31

    term                           shift and go to state 32
    logical                        shift and go to state 38
    variable                       shift and go to state 34
    boolean                        shift and go to state 36

state 9

    (3) code -> while .

    IF              reduce using rule 3 (code -> while .)
    WHILE           reduce using rule 3 (code -> while .)
    BEGIN           reduce using rule 3 (code -> while .)
    FOR             reduce using rule 3 (code -> while .)
    NUMBER          reduce using rule 3 (code -> while .)
    FLOAT           reduce using rule 3 (code -> while .)
    STRING          reduce using rule 3 (code -> while .)
    LOCAL           reduce using rule 3 (code -> while .)
    GLOBAL          reduce using rule 3 (code -> while .)
    CONSTANTS       reduce using rule 3 (code -> while .)
    INSTANCEVAR     reduce using rule 3 (code -> while .)
    CLASSVAR        reduce using rule 3 (code -> while .)
    END             reduce using rule 3 (code -> while .)
    NEWLINE         reduce using rule 3 (code -> while .)
    $end            reduce using rule 3 (code -> while .)
    ELSE            reduce using rule 3 (code -> while .)
    ELSIF           reduce using rule 3 (code -> while .)


state 10

    (53) expr -> index .

    END             reduce using rule 53 (expr -> index .)
    IF              reduce using rule 53 (expr -> index .)
    WHILE           reduce using rule 53 (expr -> index .)
    BEGIN           reduce using rule 53 (expr -> index .)
    FOR             reduce using rule 53 (expr -> index .)
    NUMBER          reduce using rule 53 (expr -> index .)
    FLOAT           reduce using rule 53 (expr -> index .)
    STRING          reduce using rule 53 (expr -> index .)
    LOCAL           reduce using rule 53 (expr -> index .)
    GLOBAL          reduce using rule 53 (expr -> index .)
    CONSTANTS       reduce using rule 53 (expr -> index .)
    INSTANCEVAR     reduce using rule 53 (expr -> index .)
    CLASSVAR        reduce using rule 53 (expr -> index .)
    $end            reduce using rule 53 (expr -> index .)
    NEWLINE         reduce using rule 53 (expr -> index .)
    ELSE            reduce using rule 53 (expr -> index .)
    ELSIF           reduce using rule 53 (expr -> index .)


state 11

    (65) for -> FOR . iterador IN expresiones code END
    (66) for -> FOR . iterador IN expresiones DO code END
    (67) for -> FOR . iterador IN array code END
    (68) for -> FOR . iterador IN array DO code END
    (82) iterador -> . variable
    (83) iterador -> . variable COMA variable
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR

    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21

    variable                       shift and go to state 40
    iterador                       shift and go to state 39

state 12

    (36) variable -> LOCAL .

    ASS             reduce using rule 36 (variable -> LOCAL .)
    LBRACK          reduce using rule 36 (variable -> LOCAL .)
    ADDASS          reduce using rule 36 (variable -> LOCAL .)
    SUBASS          reduce using rule 36 (variable -> LOCAL .)
    MULASS          reduce using rule 36 (variable -> LOCAL .)
    DIVASS          reduce using rule 36 (variable -> LOCAL .)
    MODASS          reduce using rule 36 (variable -> LOCAL .)
    EXPASS          reduce using rule 36 (variable -> LOCAL .)
    IF              reduce using rule 36 (variable -> LOCAL .)
    WHILE           reduce using rule 36 (variable -> LOCAL .)
    BEGIN           reduce using rule 36 (variable -> LOCAL .)
    FOR             reduce using rule 36 (variable -> LOCAL .)
    NUMBER          reduce using rule 36 (variable -> LOCAL .)
    FLOAT           reduce using rule 36 (variable -> LOCAL .)
    STRING          reduce using rule 36 (variable -> LOCAL .)
    LOCAL           reduce using rule 36 (variable -> LOCAL .)
    GLOBAL          reduce using rule 36 (variable -> LOCAL .)
    CONSTANTS       reduce using rule 36 (variable -> LOCAL .)
    INSTANCEVAR     reduce using rule 36 (variable -> LOCAL .)
    CLASSVAR        reduce using rule 36 (variable -> LOCAL .)
    $end            reduce using rule 36 (variable -> LOCAL .)
    END             reduce using rule 36 (variable -> LOCAL .)
    NEWLINE         reduce using rule 36 (variable -> LOCAL .)
    ELSE            reduce using rule 36 (variable -> LOCAL .)
    ELSIF           reduce using rule 36 (variable -> LOCAL .)
    COMA            reduce using rule 36 (variable -> LOCAL .)
    IN              reduce using rule 36 (variable -> LOCAL .)
    EQUAL           reduce using rule 36 (variable -> LOCAL .)
    NOTEQ           reduce using rule 36 (variable -> LOCAL .)
    GREATHER        reduce using rule 36 (variable -> LOCAL .)
    LOWER           reduce using rule 36 (variable -> LOCAL .)
    GREATHEREQ      reduce using rule 36 (variable -> LOCAL .)
    LOWEREQ         reduce using rule 36 (variable -> LOCAL .)


state 13

    (52) expr -> slice .

    END             reduce using rule 52 (expr -> slice .)
    IF              reduce using rule 52 (expr -> slice .)
    WHILE           reduce using rule 52 (expr -> slice .)
    BEGIN           reduce using rule 52 (expr -> slice .)
    FOR             reduce using rule 52 (expr -> slice .)
    NUMBER          reduce using rule 52 (expr -> slice .)
    FLOAT           reduce using rule 52 (expr -> slice .)
    STRING          reduce using rule 52 (expr -> slice .)
    LOCAL           reduce using rule 52 (expr -> slice .)
    GLOBAL          reduce using rule 52 (expr -> slice .)
    CONSTANTS       reduce using rule 52 (expr -> slice .)
    INSTANCEVAR     reduce using rule 52 (expr -> slice .)
    CLASSVAR        reduce using rule 52 (expr -> slice .)
    $end            reduce using rule 52 (expr -> slice .)
    NEWLINE         reduce using rule 52 (expr -> slice .)
    ELSE            reduce using rule 52 (expr -> slice .)
    ELSIF           reduce using rule 52 (expr -> slice .)


state 14

    (57) term -> FLOAT .

    THEN            reduce using rule 57 (term -> FLOAT .)
    ANDLOG          reduce using rule 57 (term -> FLOAT .)
    ORLOG           reduce using rule 57 (term -> FLOAT .)
    NOTLOG          reduce using rule 57 (term -> FLOAT .)
    AND             reduce using rule 57 (term -> FLOAT .)
    OR              reduce using rule 57 (term -> FLOAT .)
    NOT             reduce using rule 57 (term -> FLOAT .)
    NUMBER          reduce using rule 57 (term -> FLOAT .)
    FLOAT           reduce using rule 57 (term -> FLOAT .)
    STRING          reduce using rule 57 (term -> FLOAT .)
    LOCAL           reduce using rule 57 (term -> FLOAT .)
    GLOBAL          reduce using rule 57 (term -> FLOAT .)
    CONSTANTS       reduce using rule 57 (term -> FLOAT .)
    INSTANCEVAR     reduce using rule 57 (term -> FLOAT .)
    CLASSVAR        reduce using rule 57 (term -> FLOAT .)
    ELSE            reduce using rule 57 (term -> FLOAT .)
    ELSIF           reduce using rule 57 (term -> FLOAT .)
    IF              reduce using rule 57 (term -> FLOAT .)
    WHILE           reduce using rule 57 (term -> FLOAT .)
    BEGIN           reduce using rule 57 (term -> FLOAT .)
    FOR             reduce using rule 57 (term -> FLOAT .)
    $end            reduce using rule 57 (term -> FLOAT .)
    END             reduce using rule 57 (term -> FLOAT .)
    NEWLINE         reduce using rule 57 (term -> FLOAT .)
    DO              reduce using rule 57 (term -> FLOAT .)
    DOBLEPOINT      reduce using rule 57 (term -> FLOAT .)
    EXP             reduce using rule 57 (term -> FLOAT .)
    MUL             reduce using rule 57 (term -> FLOAT .)
    DIV             reduce using rule 57 (term -> FLOAT .)
    MOD             reduce using rule 57 (term -> FLOAT .)
    ADD             reduce using rule 57 (term -> FLOAT .)
    SUB             reduce using rule 57 (term -> FLOAT .)
    DOUBLESECUENCEPOINT reduce using rule 57 (term -> FLOAT .)
    EQUAL           reduce using rule 57 (term -> FLOAT .)
    NOTEQ           reduce using rule 57 (term -> FLOAT .)
    GREATHER        reduce using rule 57 (term -> FLOAT .)
    LOWER           reduce using rule 57 (term -> FLOAT .)
    GREATHEREQ      reduce using rule 57 (term -> FLOAT .)
    LOWEREQ         reduce using rule 57 (term -> FLOAT .)


state 15

    (4) code -> expresiones .

    IF              reduce using rule 4 (code -> expresiones .)
    WHILE           reduce using rule 4 (code -> expresiones .)
    BEGIN           reduce using rule 4 (code -> expresiones .)
    FOR             reduce using rule 4 (code -> expresiones .)
    NUMBER          reduce using rule 4 (code -> expresiones .)
    FLOAT           reduce using rule 4 (code -> expresiones .)
    STRING          reduce using rule 4 (code -> expresiones .)
    LOCAL           reduce using rule 4 (code -> expresiones .)
    GLOBAL          reduce using rule 4 (code -> expresiones .)
    CONSTANTS       reduce using rule 4 (code -> expresiones .)
    INSTANCEVAR     reduce using rule 4 (code -> expresiones .)
    CLASSVAR        reduce using rule 4 (code -> expresiones .)
    END             reduce using rule 4 (code -> expresiones .)
    NEWLINE         reduce using rule 4 (code -> expresiones .)
    $end            reduce using rule 4 (code -> expresiones .)
    ELSE            reduce using rule 4 (code -> expresiones .)
    ELSIF           reduce using rule 4 (code -> expresiones .)


state 16

    (5) code -> for .

    IF              reduce using rule 5 (code -> for .)
    WHILE           reduce using rule 5 (code -> for .)
    BEGIN           reduce using rule 5 (code -> for .)
    FOR             reduce using rule 5 (code -> for .)
    NUMBER          reduce using rule 5 (code -> for .)
    FLOAT           reduce using rule 5 (code -> for .)
    STRING          reduce using rule 5 (code -> for .)
    LOCAL           reduce using rule 5 (code -> for .)
    GLOBAL          reduce using rule 5 (code -> for .)
    CONSTANTS       reduce using rule 5 (code -> for .)
    INSTANCEVAR     reduce using rule 5 (code -> for .)
    CLASSVAR        reduce using rule 5 (code -> for .)
    END             reduce using rule 5 (code -> for .)
    NEWLINE         reduce using rule 5 (code -> for .)
    $end            reduce using rule 5 (code -> for .)
    ELSE            reduce using rule 5 (code -> for .)
    ELSIF           reduce using rule 5 (code -> for .)


state 17

    (49) expr -> term .
    (84) expresiones -> term . DOUBLESECUENCEPOINT term
    (33) math -> term . arith term
    (34) math -> term . arith math
    (59) arith -> . EXP
    (60) arith -> . MUL
    (61) arith -> . DIV
    (62) arith -> . MOD
    (63) arith -> . ADD
    (64) arith -> . SUB

    END             reduce using rule 49 (expr -> term .)
    IF              reduce using rule 49 (expr -> term .)
    WHILE           reduce using rule 49 (expr -> term .)
    BEGIN           reduce using rule 49 (expr -> term .)
    FOR             reduce using rule 49 (expr -> term .)
    NUMBER          reduce using rule 49 (expr -> term .)
    FLOAT           reduce using rule 49 (expr -> term .)
    STRING          reduce using rule 49 (expr -> term .)
    LOCAL           reduce using rule 49 (expr -> term .)
    GLOBAL          reduce using rule 49 (expr -> term .)
    CONSTANTS       reduce using rule 49 (expr -> term .)
    INSTANCEVAR     reduce using rule 49 (expr -> term .)
    CLASSVAR        reduce using rule 49 (expr -> term .)
    $end            reduce using rule 49 (expr -> term .)
    NEWLINE         reduce using rule 49 (expr -> term .)
    ELSE            reduce using rule 49 (expr -> term .)
    ELSIF           reduce using rule 49 (expr -> term .)
    DOUBLESECUENCEPOINT shift and go to state 41
    EXP             shift and go to state 42
    MUL             shift and go to state 47
    DIV             shift and go to state 44
    MOD             shift and go to state 46
    ADD             shift and go to state 43
    SUB             shift and go to state 45

    arith                          shift and go to state 48

state 18

    (58) sterm -> STRING .

    IF              reduce using rule 58 (sterm -> STRING .)
    WHILE           reduce using rule 58 (sterm -> STRING .)
    BEGIN           reduce using rule 58 (sterm -> STRING .)
    FOR             reduce using rule 58 (sterm -> STRING .)
    NUMBER          reduce using rule 58 (sterm -> STRING .)
    FLOAT           reduce using rule 58 (sterm -> STRING .)
    STRING          reduce using rule 58 (sterm -> STRING .)
    LOCAL           reduce using rule 58 (sterm -> STRING .)
    GLOBAL          reduce using rule 58 (sterm -> STRING .)
    CONSTANTS       reduce using rule 58 (sterm -> STRING .)
    INSTANCEVAR     reduce using rule 58 (sterm -> STRING .)
    CLASSVAR        reduce using rule 58 (sterm -> STRING .)
    END             reduce using rule 58 (sterm -> STRING .)
    $end            reduce using rule 58 (sterm -> STRING .)
    MUL             reduce using rule 58 (sterm -> STRING .)
    ADD             reduce using rule 58 (sterm -> STRING .)
    ELSE            reduce using rule 58 (sterm -> STRING .)
    ELSIF           reduce using rule 58 (sterm -> STRING .)
    NEWLINE         reduce using rule 58 (sterm -> STRING .)


state 19

    (38) variable -> CONSTANTS .

    ASS             reduce using rule 38 (variable -> CONSTANTS .)
    LBRACK          reduce using rule 38 (variable -> CONSTANTS .)
    ADDASS          reduce using rule 38 (variable -> CONSTANTS .)
    SUBASS          reduce using rule 38 (variable -> CONSTANTS .)
    MULASS          reduce using rule 38 (variable -> CONSTANTS .)
    DIVASS          reduce using rule 38 (variable -> CONSTANTS .)
    MODASS          reduce using rule 38 (variable -> CONSTANTS .)
    EXPASS          reduce using rule 38 (variable -> CONSTANTS .)
    IF              reduce using rule 38 (variable -> CONSTANTS .)
    WHILE           reduce using rule 38 (variable -> CONSTANTS .)
    BEGIN           reduce using rule 38 (variable -> CONSTANTS .)
    FOR             reduce using rule 38 (variable -> CONSTANTS .)
    NUMBER          reduce using rule 38 (variable -> CONSTANTS .)
    FLOAT           reduce using rule 38 (variable -> CONSTANTS .)
    STRING          reduce using rule 38 (variable -> CONSTANTS .)
    LOCAL           reduce using rule 38 (variable -> CONSTANTS .)
    GLOBAL          reduce using rule 38 (variable -> CONSTANTS .)
    CONSTANTS       reduce using rule 38 (variable -> CONSTANTS .)
    INSTANCEVAR     reduce using rule 38 (variable -> CONSTANTS .)
    CLASSVAR        reduce using rule 38 (variable -> CONSTANTS .)
    $end            reduce using rule 38 (variable -> CONSTANTS .)
    END             reduce using rule 38 (variable -> CONSTANTS .)
    NEWLINE         reduce using rule 38 (variable -> CONSTANTS .)
    ELSE            reduce using rule 38 (variable -> CONSTANTS .)
    ELSIF           reduce using rule 38 (variable -> CONSTANTS .)
    COMA            reduce using rule 38 (variable -> CONSTANTS .)
    IN              reduce using rule 38 (variable -> CONSTANTS .)
    EQUAL           reduce using rule 38 (variable -> CONSTANTS .)
    NOTEQ           reduce using rule 38 (variable -> CONSTANTS .)
    GREATHER        reduce using rule 38 (variable -> CONSTANTS .)
    LOWER           reduce using rule 38 (variable -> CONSTANTS .)
    GREATHEREQ      reduce using rule 38 (variable -> CONSTANTS .)
    LOWEREQ         reduce using rule 38 (variable -> CONSTANTS .)


state 20

    (39) variable -> INSTANCEVAR .

    ASS             reduce using rule 39 (variable -> INSTANCEVAR .)
    LBRACK          reduce using rule 39 (variable -> INSTANCEVAR .)
    ADDASS          reduce using rule 39 (variable -> INSTANCEVAR .)
    SUBASS          reduce using rule 39 (variable -> INSTANCEVAR .)
    MULASS          reduce using rule 39 (variable -> INSTANCEVAR .)
    DIVASS          reduce using rule 39 (variable -> INSTANCEVAR .)
    MODASS          reduce using rule 39 (variable -> INSTANCEVAR .)
    EXPASS          reduce using rule 39 (variable -> INSTANCEVAR .)
    IF              reduce using rule 39 (variable -> INSTANCEVAR .)
    WHILE           reduce using rule 39 (variable -> INSTANCEVAR .)
    BEGIN           reduce using rule 39 (variable -> INSTANCEVAR .)
    FOR             reduce using rule 39 (variable -> INSTANCEVAR .)
    NUMBER          reduce using rule 39 (variable -> INSTANCEVAR .)
    FLOAT           reduce using rule 39 (variable -> INSTANCEVAR .)
    STRING          reduce using rule 39 (variable -> INSTANCEVAR .)
    LOCAL           reduce using rule 39 (variable -> INSTANCEVAR .)
    GLOBAL          reduce using rule 39 (variable -> INSTANCEVAR .)
    CONSTANTS       reduce using rule 39 (variable -> INSTANCEVAR .)
    INSTANCEVAR     reduce using rule 39 (variable -> INSTANCEVAR .)
    CLASSVAR        reduce using rule 39 (variable -> INSTANCEVAR .)
    $end            reduce using rule 39 (variable -> INSTANCEVAR .)
    END             reduce using rule 39 (variable -> INSTANCEVAR .)
    NEWLINE         reduce using rule 39 (variable -> INSTANCEVAR .)
    ELSE            reduce using rule 39 (variable -> INSTANCEVAR .)
    ELSIF           reduce using rule 39 (variable -> INSTANCEVAR .)
    COMA            reduce using rule 39 (variable -> INSTANCEVAR .)
    IN              reduce using rule 39 (variable -> INSTANCEVAR .)
    EQUAL           reduce using rule 39 (variable -> INSTANCEVAR .)
    NOTEQ           reduce using rule 39 (variable -> INSTANCEVAR .)
    GREATHER        reduce using rule 39 (variable -> INSTANCEVAR .)
    LOWER           reduce using rule 39 (variable -> INSTANCEVAR .)
    GREATHEREQ      reduce using rule 39 (variable -> INSTANCEVAR .)
    LOWEREQ         reduce using rule 39 (variable -> INSTANCEVAR .)


state 21

    (40) variable -> CLASSVAR .

    ASS             reduce using rule 40 (variable -> CLASSVAR .)
    LBRACK          reduce using rule 40 (variable -> CLASSVAR .)
    ADDASS          reduce using rule 40 (variable -> CLASSVAR .)
    SUBASS          reduce using rule 40 (variable -> CLASSVAR .)
    MULASS          reduce using rule 40 (variable -> CLASSVAR .)
    DIVASS          reduce using rule 40 (variable -> CLASSVAR .)
    MODASS          reduce using rule 40 (variable -> CLASSVAR .)
    EXPASS          reduce using rule 40 (variable -> CLASSVAR .)
    IF              reduce using rule 40 (variable -> CLASSVAR .)
    WHILE           reduce using rule 40 (variable -> CLASSVAR .)
    BEGIN           reduce using rule 40 (variable -> CLASSVAR .)
    FOR             reduce using rule 40 (variable -> CLASSVAR .)
    NUMBER          reduce using rule 40 (variable -> CLASSVAR .)
    FLOAT           reduce using rule 40 (variable -> CLASSVAR .)
    STRING          reduce using rule 40 (variable -> CLASSVAR .)
    LOCAL           reduce using rule 40 (variable -> CLASSVAR .)
    GLOBAL          reduce using rule 40 (variable -> CLASSVAR .)
    CONSTANTS       reduce using rule 40 (variable -> CLASSVAR .)
    INSTANCEVAR     reduce using rule 40 (variable -> CLASSVAR .)
    CLASSVAR        reduce using rule 40 (variable -> CLASSVAR .)
    $end            reduce using rule 40 (variable -> CLASSVAR .)
    END             reduce using rule 40 (variable -> CLASSVAR .)
    NEWLINE         reduce using rule 40 (variable -> CLASSVAR .)
    ELSE            reduce using rule 40 (variable -> CLASSVAR .)
    ELSIF           reduce using rule 40 (variable -> CLASSVAR .)
    COMA            reduce using rule 40 (variable -> CLASSVAR .)
    IN              reduce using rule 40 (variable -> CLASSVAR .)
    EQUAL           reduce using rule 40 (variable -> CLASSVAR .)
    NOTEQ           reduce using rule 40 (variable -> CLASSVAR .)
    GREATHER        reduce using rule 40 (variable -> CLASSVAR .)
    LOWER           reduce using rule 40 (variable -> CLASSVAR .)
    GREATHEREQ      reduce using rule 40 (variable -> CLASSVAR .)
    LOWEREQ         reduce using rule 40 (variable -> CLASSVAR .)


state 22

    (48) expr -> math .

    END             reduce using rule 48 (expr -> math .)
    IF              reduce using rule 48 (expr -> math .)
    WHILE           reduce using rule 48 (expr -> math .)
    BEGIN           reduce using rule 48 (expr -> math .)
    FOR             reduce using rule 48 (expr -> math .)
    NUMBER          reduce using rule 48 (expr -> math .)
    FLOAT           reduce using rule 48 (expr -> math .)
    STRING          reduce using rule 48 (expr -> math .)
    LOCAL           reduce using rule 48 (expr -> math .)
    GLOBAL          reduce using rule 48 (expr -> math .)
    CONSTANTS       reduce using rule 48 (expr -> math .)
    INSTANCEVAR     reduce using rule 48 (expr -> math .)
    CLASSVAR        reduce using rule 48 (expr -> math .)
    $end            reduce using rule 48 (expr -> math .)
    NEWLINE         reduce using rule 48 (expr -> math .)
    ELSE            reduce using rule 48 (expr -> math .)
    ELSIF           reduce using rule 48 (expr -> math .)


state 23

    (6) code -> assign .

    IF              reduce using rule 6 (code -> assign .)
    WHILE           reduce using rule 6 (code -> assign .)
    BEGIN           reduce using rule 6 (code -> assign .)
    FOR             reduce using rule 6 (code -> assign .)
    NUMBER          reduce using rule 6 (code -> assign .)
    FLOAT           reduce using rule 6 (code -> assign .)
    STRING          reduce using rule 6 (code -> assign .)
    LOCAL           reduce using rule 6 (code -> assign .)
    GLOBAL          reduce using rule 6 (code -> assign .)
    CONSTANTS       reduce using rule 6 (code -> assign .)
    INSTANCEVAR     reduce using rule 6 (code -> assign .)
    CLASSVAR        reduce using rule 6 (code -> assign .)
    END             reduce using rule 6 (code -> assign .)
    NEWLINE         reduce using rule 6 (code -> assign .)
    $end            reduce using rule 6 (code -> assign .)
    ELSE            reduce using rule 6 (code -> assign .)
    ELSIF           reduce using rule 6 (code -> assign .)


state 24

    (37) variable -> GLOBAL .

    ASS             reduce using rule 37 (variable -> GLOBAL .)
    LBRACK          reduce using rule 37 (variable -> GLOBAL .)
    ADDASS          reduce using rule 37 (variable -> GLOBAL .)
    SUBASS          reduce using rule 37 (variable -> GLOBAL .)
    MULASS          reduce using rule 37 (variable -> GLOBAL .)
    DIVASS          reduce using rule 37 (variable -> GLOBAL .)
    MODASS          reduce using rule 37 (variable -> GLOBAL .)
    EXPASS          reduce using rule 37 (variable -> GLOBAL .)
    IF              reduce using rule 37 (variable -> GLOBAL .)
    WHILE           reduce using rule 37 (variable -> GLOBAL .)
    BEGIN           reduce using rule 37 (variable -> GLOBAL .)
    FOR             reduce using rule 37 (variable -> GLOBAL .)
    NUMBER          reduce using rule 37 (variable -> GLOBAL .)
    FLOAT           reduce using rule 37 (variable -> GLOBAL .)
    STRING          reduce using rule 37 (variable -> GLOBAL .)
    LOCAL           reduce using rule 37 (variable -> GLOBAL .)
    GLOBAL          reduce using rule 37 (variable -> GLOBAL .)
    CONSTANTS       reduce using rule 37 (variable -> GLOBAL .)
    INSTANCEVAR     reduce using rule 37 (variable -> GLOBAL .)
    CLASSVAR        reduce using rule 37 (variable -> GLOBAL .)
    $end            reduce using rule 37 (variable -> GLOBAL .)
    END             reduce using rule 37 (variable -> GLOBAL .)
    NEWLINE         reduce using rule 37 (variable -> GLOBAL .)
    ELSE            reduce using rule 37 (variable -> GLOBAL .)
    ELSIF           reduce using rule 37 (variable -> GLOBAL .)
    COMA            reduce using rule 37 (variable -> GLOBAL .)
    IN              reduce using rule 37 (variable -> GLOBAL .)
    EQUAL           reduce using rule 37 (variable -> GLOBAL .)
    NOTEQ           reduce using rule 37 (variable -> GLOBAL .)
    GREATHER        reduce using rule 37 (variable -> GLOBAL .)
    LOWER           reduce using rule 37 (variable -> GLOBAL .)
    GREATHEREQ      reduce using rule 37 (variable -> GLOBAL .)
    LOWEREQ         reduce using rule 37 (variable -> GLOBAL .)


state 25

    (51) expr -> variable .
    (30) assign -> variable . ASS expr
    (31) assign -> variable . ASS sexpr
    (32) assign -> variable . ASS array
    (35) math -> variable . asig term
    (97) slice -> variable . LBRACK defslice RBRACK
    (96) index -> variable . LBRACK INT RBRACK
    (41) asig -> . ASS
    (42) asig -> . ADDASS
    (43) asig -> . SUBASS
    (44) asig -> . MULASS
    (45) asig -> . DIVASS
    (46) asig -> . MODASS
    (47) asig -> . EXPASS

    END             reduce using rule 51 (expr -> variable .)
    IF              reduce using rule 51 (expr -> variable .)
    WHILE           reduce using rule 51 (expr -> variable .)
    BEGIN           reduce using rule 51 (expr -> variable .)
    FOR             reduce using rule 51 (expr -> variable .)
    NUMBER          reduce using rule 51 (expr -> variable .)
    FLOAT           reduce using rule 51 (expr -> variable .)
    STRING          reduce using rule 51 (expr -> variable .)
    LOCAL           reduce using rule 51 (expr -> variable .)
    GLOBAL          reduce using rule 51 (expr -> variable .)
    CONSTANTS       reduce using rule 51 (expr -> variable .)
    INSTANCEVAR     reduce using rule 51 (expr -> variable .)
    CLASSVAR        reduce using rule 51 (expr -> variable .)
    $end            reduce using rule 51 (expr -> variable .)
    NEWLINE         reduce using rule 51 (expr -> variable .)
    ELSE            reduce using rule 51 (expr -> variable .)
    ELSIF           reduce using rule 51 (expr -> variable .)
    ASS             shift and go to state 49
    LBRACK          shift and go to state 56
    ADDASS          shift and go to state 52
    SUBASS          shift and go to state 57
    MULASS          shift and go to state 53
    DIVASS          shift and go to state 55
    MODASS          shift and go to state 54
    EXPASS          shift and go to state 51

    asig                           shift and go to state 50

state 26

    (77) elsif -> ELSIF . logical final
    (12) logical -> . term comparison term
    (13) logical -> . term comparison logical
    (14) logical -> . variable comparison term
    (15) logical -> . variable comparison boolean
    (16) logical -> . logical logcompare logical
    (17) logical -> . boolean
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (101) boolean -> . TRUE
    (102) boolean -> . FALSE

    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21
    TRUE            shift and go to state 35
    FALSE           shift and go to state 31

    term                           shift and go to state 32
    boolean                        shift and go to state 36
    logical                        shift and go to state 58
    variable                       shift and go to state 34

state 27

    (75) if -> if elsif . END

    END             shift and go to state 59


state 28

    (74) if -> if else .

    ELSE            reduce using rule 74 (if -> if else .)
    ELSIF           reduce using rule 74 (if -> if else .)
    END             reduce using rule 74 (if -> if else .)
    IF              reduce using rule 74 (if -> if else .)
    WHILE           reduce using rule 74 (if -> if else .)
    BEGIN           reduce using rule 74 (if -> if else .)
    FOR             reduce using rule 74 (if -> if else .)
    NUMBER          reduce using rule 74 (if -> if else .)
    FLOAT           reduce using rule 74 (if -> if else .)
    STRING          reduce using rule 74 (if -> if else .)
    LOCAL           reduce using rule 74 (if -> if else .)
    GLOBAL          reduce using rule 74 (if -> if else .)
    CONSTANTS       reduce using rule 74 (if -> if else .)
    INSTANCEVAR     reduce using rule 74 (if -> if else .)
    CLASSVAR        reduce using rule 74 (if -> if else .)
    $end            reduce using rule 74 (if -> if else .)
    NEWLINE         reduce using rule 74 (if -> if else .)


state 29

    (76) else -> ELSE . code END
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (70) if -> . IF logical expr END
    (71) if -> . IF logical THEN expr END
    (72) if -> . IF logical
    (73) if -> . IF logical THEN
    (74) if -> . if else
    (75) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (84) expresiones -> . term DOUBLESECUENCEPOINT term
    (65) for -> . FOR iterador IN expresiones code END
    (66) for -> . FOR iterador IN expresiones DO code END
    (67) for -> . FOR iterador IN array code END
    (68) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (58) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (97) slice -> . variable LBRACK defslice RBRACK
    (96) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 6
    WHILE           shift and go to state 8
    BEGIN           shift and go to state 7
    FOR             shift and go to state 11
    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    STRING          shift and go to state 18
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21

    expr                           shift and go to state 1
    slice                          shift and go to state 13
    if                             shift and go to state 2
    expresiones                    shift and go to state 15
    sterm                          shift and go to state 3
    for                            shift and go to state 16
    term                           shift and go to state 17
    code                           shift and go to state 60
    assign                         shift and go to state 23
    math                           shift and go to state 22
    while                          shift and go to state 9
    index                          shift and go to state 10
    variable                       shift and go to state 25

state 30

    (7) code -> code code .
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (70) if -> . IF logical expr END
    (71) if -> . IF logical THEN expr END
    (72) if -> . IF logical
    (73) if -> . IF logical THEN
    (74) if -> . if else
    (75) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (84) expresiones -> . term DOUBLESECUENCEPOINT term
    (65) for -> . FOR iterador IN expresiones code END
    (66) for -> . FOR iterador IN expresiones DO code END
    (67) for -> . FOR iterador IN array code END
    (68) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (58) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (97) slice -> . variable LBRACK defslice RBRACK
    (96) index -> . variable LBRACK INT RBRACK

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for LOCAL resolved as shift
  ! shift/reduce conflict for GLOBAL resolved as shift
  ! shift/reduce conflict for CONSTANTS resolved as shift
  ! shift/reduce conflict for INSTANCEVAR resolved as shift
  ! shift/reduce conflict for CLASSVAR resolved as shift
    END             reduce using rule 7 (code -> code code .)
    NEWLINE         reduce using rule 7 (code -> code code .)
    $end            reduce using rule 7 (code -> code code .)
    ELSE            reduce using rule 7 (code -> code code .)
    ELSIF           reduce using rule 7 (code -> code code .)
    IF              shift and go to state 6
    WHILE           shift and go to state 8
    BEGIN           shift and go to state 7
    FOR             shift and go to state 11
    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    STRING          shift and go to state 18
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21

  ! IF              [ reduce using rule 7 (code -> code code .) ]
  ! WHILE           [ reduce using rule 7 (code -> code code .) ]
  ! BEGIN           [ reduce using rule 7 (code -> code code .) ]
  ! FOR             [ reduce using rule 7 (code -> code code .) ]
  ! NUMBER          [ reduce using rule 7 (code -> code code .) ]
  ! FLOAT           [ reduce using rule 7 (code -> code code .) ]
  ! STRING          [ reduce using rule 7 (code -> code code .) ]
  ! LOCAL           [ reduce using rule 7 (code -> code code .) ]
  ! GLOBAL          [ reduce using rule 7 (code -> code code .) ]
  ! CONSTANTS       [ reduce using rule 7 (code -> code code .) ]
  ! INSTANCEVAR     [ reduce using rule 7 (code -> code code .) ]
  ! CLASSVAR        [ reduce using rule 7 (code -> code code .) ]

    expr                           shift and go to state 1
    slice                          shift and go to state 13
    if                             shift and go to state 2
    expresiones                    shift and go to state 15
    sterm                          shift and go to state 3
    for                            shift and go to state 16
    term                           shift and go to state 17
    code                           shift and go to state 30
    assign                         shift and go to state 23
    math                           shift and go to state 22
    while                          shift and go to state 9
    index                          shift and go to state 10
    variable                       shift and go to state 25

state 31

    (102) boolean -> FALSE .

    ANDLOG          reduce using rule 102 (boolean -> FALSE .)
    ORLOG           reduce using rule 102 (boolean -> FALSE .)
    NOTLOG          reduce using rule 102 (boolean -> FALSE .)
    AND             reduce using rule 102 (boolean -> FALSE .)
    OR              reduce using rule 102 (boolean -> FALSE .)
    NOT             reduce using rule 102 (boolean -> FALSE .)
    THEN            reduce using rule 102 (boolean -> FALSE .)
    NUMBER          reduce using rule 102 (boolean -> FALSE .)
    FLOAT           reduce using rule 102 (boolean -> FALSE .)
    STRING          reduce using rule 102 (boolean -> FALSE .)
    LOCAL           reduce using rule 102 (boolean -> FALSE .)
    GLOBAL          reduce using rule 102 (boolean -> FALSE .)
    CONSTANTS       reduce using rule 102 (boolean -> FALSE .)
    INSTANCEVAR     reduce using rule 102 (boolean -> FALSE .)
    CLASSVAR        reduce using rule 102 (boolean -> FALSE .)
    ELSE            reduce using rule 102 (boolean -> FALSE .)
    ELSIF           reduce using rule 102 (boolean -> FALSE .)
    IF              reduce using rule 102 (boolean -> FALSE .)
    WHILE           reduce using rule 102 (boolean -> FALSE .)
    BEGIN           reduce using rule 102 (boolean -> FALSE .)
    FOR             reduce using rule 102 (boolean -> FALSE .)
    $end            reduce using rule 102 (boolean -> FALSE .)
    END             reduce using rule 102 (boolean -> FALSE .)
    NEWLINE         reduce using rule 102 (boolean -> FALSE .)
    DO              reduce using rule 102 (boolean -> FALSE .)
    DOBLEPOINT      reduce using rule 102 (boolean -> FALSE .)
    COMA            reduce using rule 102 (boolean -> FALSE .)
    RBRACK          reduce using rule 102 (boolean -> FALSE .)


state 32

    (12) logical -> term . comparison term
    (13) logical -> term . comparison logical
    (18) comparison -> . EQUAL
    (19) comparison -> . NOTEQ
    (20) comparison -> . GREATHER
    (21) comparison -> . LOWER
    (22) comparison -> . GREATHEREQ
    (23) comparison -> . LOWEREQ

    EQUAL           shift and go to state 63
    NOTEQ           shift and go to state 64
    GREATHER        shift and go to state 65
    LOWER           shift and go to state 66
    GREATHEREQ      shift and go to state 61
    LOWEREQ         shift and go to state 62

    comparison                     shift and go to state 67

state 33

    (70) if -> IF logical . expr END
    (71) if -> IF logical . THEN expr END
    (72) if -> IF logical .
    (73) if -> IF logical . THEN
    (16) logical -> logical . logcompare logical
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (24) logcompare -> . ANDLOG
    (25) logcompare -> . ORLOG
    (26) logcompare -> . NOTLOG
    (27) logcompare -> . AND
    (28) logcompare -> . OR
    (29) logcompare -> . NOT
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (58) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (97) slice -> . variable LBRACK defslice RBRACK
    (96) index -> . variable LBRACK INT RBRACK

  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for LOCAL resolved as shift
  ! shift/reduce conflict for GLOBAL resolved as shift
  ! shift/reduce conflict for CONSTANTS resolved as shift
  ! shift/reduce conflict for INSTANCEVAR resolved as shift
  ! shift/reduce conflict for CLASSVAR resolved as shift
    THEN            shift and go to state 74
    ELSE            reduce using rule 72 (if -> IF logical .)
    ELSIF           reduce using rule 72 (if -> IF logical .)
    END             reduce using rule 72 (if -> IF logical .)
    IF              reduce using rule 72 (if -> IF logical .)
    WHILE           reduce using rule 72 (if -> IF logical .)
    BEGIN           reduce using rule 72 (if -> IF logical .)
    FOR             reduce using rule 72 (if -> IF logical .)
    $end            reduce using rule 72 (if -> IF logical .)
    NEWLINE         reduce using rule 72 (if -> IF logical .)
    ANDLOG          shift and go to state 76
    ORLOG           shift and go to state 73
    NOTLOG          shift and go to state 70
    AND             shift and go to state 78
    OR              shift and go to state 75
    NOT             shift and go to state 72
    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    STRING          shift and go to state 18
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21

  ! NUMBER          [ reduce using rule 72 (if -> IF logical .) ]
  ! FLOAT           [ reduce using rule 72 (if -> IF logical .) ]
  ! STRING          [ reduce using rule 72 (if -> IF logical .) ]
  ! LOCAL           [ reduce using rule 72 (if -> IF logical .) ]
  ! GLOBAL          [ reduce using rule 72 (if -> IF logical .) ]
  ! CONSTANTS       [ reduce using rule 72 (if -> IF logical .) ]
  ! INSTANCEVAR     [ reduce using rule 72 (if -> IF logical .) ]
  ! CLASSVAR        [ reduce using rule 72 (if -> IF logical .) ]

    expr                           shift and go to state 68
    slice                          shift and go to state 13
    math                           shift and go to state 22
    logcompare                     shift and go to state 69
    sterm                          shift and go to state 3
    term                           shift and go to state 71
    index                          shift and go to state 10
    variable                       shift and go to state 77

state 34

    (14) logical -> variable . comparison term
    (15) logical -> variable . comparison boolean
    (18) comparison -> . EQUAL
    (19) comparison -> . NOTEQ
    (20) comparison -> . GREATHER
    (21) comparison -> . LOWER
    (22) comparison -> . GREATHEREQ
    (23) comparison -> . LOWEREQ

    EQUAL           shift and go to state 63
    NOTEQ           shift and go to state 64
    GREATHER        shift and go to state 65
    LOWER           shift and go to state 66
    GREATHEREQ      shift and go to state 61
    LOWEREQ         shift and go to state 62

    comparison                     shift and go to state 79

state 35

    (101) boolean -> TRUE .

    ANDLOG          reduce using rule 101 (boolean -> TRUE .)
    ORLOG           reduce using rule 101 (boolean -> TRUE .)
    NOTLOG          reduce using rule 101 (boolean -> TRUE .)
    AND             reduce using rule 101 (boolean -> TRUE .)
    OR              reduce using rule 101 (boolean -> TRUE .)
    NOT             reduce using rule 101 (boolean -> TRUE .)
    THEN            reduce using rule 101 (boolean -> TRUE .)
    NUMBER          reduce using rule 101 (boolean -> TRUE .)
    FLOAT           reduce using rule 101 (boolean -> TRUE .)
    STRING          reduce using rule 101 (boolean -> TRUE .)
    LOCAL           reduce using rule 101 (boolean -> TRUE .)
    GLOBAL          reduce using rule 101 (boolean -> TRUE .)
    CONSTANTS       reduce using rule 101 (boolean -> TRUE .)
    INSTANCEVAR     reduce using rule 101 (boolean -> TRUE .)
    CLASSVAR        reduce using rule 101 (boolean -> TRUE .)
    ELSE            reduce using rule 101 (boolean -> TRUE .)
    ELSIF           reduce using rule 101 (boolean -> TRUE .)
    IF              reduce using rule 101 (boolean -> TRUE .)
    WHILE           reduce using rule 101 (boolean -> TRUE .)
    BEGIN           reduce using rule 101 (boolean -> TRUE .)
    FOR             reduce using rule 101 (boolean -> TRUE .)
    $end            reduce using rule 101 (boolean -> TRUE .)
    END             reduce using rule 101 (boolean -> TRUE .)
    NEWLINE         reduce using rule 101 (boolean -> TRUE .)
    DO              reduce using rule 101 (boolean -> TRUE .)
    DOBLEPOINT      reduce using rule 101 (boolean -> TRUE .)
    COMA            reduce using rule 101 (boolean -> TRUE .)
    RBRACK          reduce using rule 101 (boolean -> TRUE .)


state 36

    (17) logical -> boolean .

    THEN            reduce using rule 17 (logical -> boolean .)
    ANDLOG          reduce using rule 17 (logical -> boolean .)
    ORLOG           reduce using rule 17 (logical -> boolean .)
    NOTLOG          reduce using rule 17 (logical -> boolean .)
    AND             reduce using rule 17 (logical -> boolean .)
    OR              reduce using rule 17 (logical -> boolean .)
    NOT             reduce using rule 17 (logical -> boolean .)
    NUMBER          reduce using rule 17 (logical -> boolean .)
    FLOAT           reduce using rule 17 (logical -> boolean .)
    STRING          reduce using rule 17 (logical -> boolean .)
    LOCAL           reduce using rule 17 (logical -> boolean .)
    GLOBAL          reduce using rule 17 (logical -> boolean .)
    CONSTANTS       reduce using rule 17 (logical -> boolean .)
    INSTANCEVAR     reduce using rule 17 (logical -> boolean .)
    CLASSVAR        reduce using rule 17 (logical -> boolean .)
    ELSE            reduce using rule 17 (logical -> boolean .)
    ELSIF           reduce using rule 17 (logical -> boolean .)
    IF              reduce using rule 17 (logical -> boolean .)
    WHILE           reduce using rule 17 (logical -> boolean .)
    BEGIN           reduce using rule 17 (logical -> boolean .)
    FOR             reduce using rule 17 (logical -> boolean .)
    $end            reduce using rule 17 (logical -> boolean .)
    END             reduce using rule 17 (logical -> boolean .)
    NEWLINE         reduce using rule 17 (logical -> boolean .)
    DO              reduce using rule 17 (logical -> boolean .)
    DOBLEPOINT      reduce using rule 17 (logical -> boolean .)


state 37

    (11) while -> BEGIN code . END WHILE logical
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (70) if -> . IF logical expr END
    (71) if -> . IF logical THEN expr END
    (72) if -> . IF logical
    (73) if -> . IF logical THEN
    (74) if -> . if else
    (75) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (84) expresiones -> . term DOUBLESECUENCEPOINT term
    (65) for -> . FOR iterador IN expresiones code END
    (66) for -> . FOR iterador IN expresiones DO code END
    (67) for -> . FOR iterador IN array code END
    (68) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (58) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (97) slice -> . variable LBRACK defslice RBRACK
    (96) index -> . variable LBRACK INT RBRACK

    END             shift and go to state 80
    IF              shift and go to state 6
    WHILE           shift and go to state 8
    BEGIN           shift and go to state 7
    FOR             shift and go to state 11
    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    STRING          shift and go to state 18
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21

    expr                           shift and go to state 1
    slice                          shift and go to state 13
    if                             shift and go to state 2
    expresiones                    shift and go to state 15
    sterm                          shift and go to state 3
    for                            shift and go to state 16
    term                           shift and go to state 17
    code                           shift and go to state 30
    assign                         shift and go to state 23
    math                           shift and go to state 22
    while                          shift and go to state 9
    index                          shift and go to state 10
    variable                       shift and go to state 25

state 38

    (8) while -> WHILE logical . code END
    (9) while -> WHILE logical . DO salto code salto END
    (10) while -> WHILE logical . DOBLEPOINT salto code salto END
    (16) logical -> logical . logcompare logical
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (24) logcompare -> . ANDLOG
    (25) logcompare -> . ORLOG
    (26) logcompare -> . NOTLOG
    (27) logcompare -> . AND
    (28) logcompare -> . OR
    (29) logcompare -> . NOT
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (70) if -> . IF logical expr END
    (71) if -> . IF logical THEN expr END
    (72) if -> . IF logical
    (73) if -> . IF logical THEN
    (74) if -> . if else
    (75) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (84) expresiones -> . term DOUBLESECUENCEPOINT term
    (65) for -> . FOR iterador IN expresiones code END
    (66) for -> . FOR iterador IN expresiones DO code END
    (67) for -> . FOR iterador IN array code END
    (68) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (58) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (97) slice -> . variable LBRACK defslice RBRACK
    (96) index -> . variable LBRACK INT RBRACK

    DO              shift and go to state 82
    DOBLEPOINT      shift and go to state 83
    ANDLOG          shift and go to state 76
    ORLOG           shift and go to state 73
    NOTLOG          shift and go to state 70
    AND             shift and go to state 78
    OR              shift and go to state 75
    NOT             shift and go to state 72
    IF              shift and go to state 6
    WHILE           shift and go to state 8
    BEGIN           shift and go to state 7
    FOR             shift and go to state 11
    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    STRING          shift and go to state 18
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21

    expr                           shift and go to state 1
    slice                          shift and go to state 13
    if                             shift and go to state 2
    expresiones                    shift and go to state 15
    logcompare                     shift and go to state 69
    sterm                          shift and go to state 3
    for                            shift and go to state 16
    term                           shift and go to state 17
    code                           shift and go to state 81
    assign                         shift and go to state 23
    math                           shift and go to state 22
    while                          shift and go to state 9
    index                          shift and go to state 10
    variable                       shift and go to state 25

state 39

    (65) for -> FOR iterador . IN expresiones code END
    (66) for -> FOR iterador . IN expresiones DO code END
    (67) for -> FOR iterador . IN array code END
    (68) for -> FOR iterador . IN array DO code END

    IN              shift and go to state 84


state 40

    (82) iterador -> variable .
    (83) iterador -> variable . COMA variable

    IN              reduce using rule 82 (iterador -> variable .)
    COMA            shift and go to state 85


state 41

    (84) expresiones -> term DOUBLESECUENCEPOINT . term
    (56) term -> . NUMBER
    (57) term -> . FLOAT

    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14

    term                           shift and go to state 86

state 42

    (59) arith -> EXP .

    NUMBER          reduce using rule 59 (arith -> EXP .)
    FLOAT           reduce using rule 59 (arith -> EXP .)
    LOCAL           reduce using rule 59 (arith -> EXP .)
    GLOBAL          reduce using rule 59 (arith -> EXP .)
    CONSTANTS       reduce using rule 59 (arith -> EXP .)
    INSTANCEVAR     reduce using rule 59 (arith -> EXP .)
    CLASSVAR        reduce using rule 59 (arith -> EXP .)


state 43

    (63) arith -> ADD .

    NUMBER          reduce using rule 63 (arith -> ADD .)
    FLOAT           reduce using rule 63 (arith -> ADD .)
    LOCAL           reduce using rule 63 (arith -> ADD .)
    GLOBAL          reduce using rule 63 (arith -> ADD .)
    CONSTANTS       reduce using rule 63 (arith -> ADD .)
    INSTANCEVAR     reduce using rule 63 (arith -> ADD .)
    CLASSVAR        reduce using rule 63 (arith -> ADD .)


state 44

    (61) arith -> DIV .

    NUMBER          reduce using rule 61 (arith -> DIV .)
    FLOAT           reduce using rule 61 (arith -> DIV .)
    LOCAL           reduce using rule 61 (arith -> DIV .)
    GLOBAL          reduce using rule 61 (arith -> DIV .)
    CONSTANTS       reduce using rule 61 (arith -> DIV .)
    INSTANCEVAR     reduce using rule 61 (arith -> DIV .)
    CLASSVAR        reduce using rule 61 (arith -> DIV .)


state 45

    (64) arith -> SUB .

    NUMBER          reduce using rule 64 (arith -> SUB .)
    FLOAT           reduce using rule 64 (arith -> SUB .)
    LOCAL           reduce using rule 64 (arith -> SUB .)
    GLOBAL          reduce using rule 64 (arith -> SUB .)
    CONSTANTS       reduce using rule 64 (arith -> SUB .)
    INSTANCEVAR     reduce using rule 64 (arith -> SUB .)
    CLASSVAR        reduce using rule 64 (arith -> SUB .)


state 46

    (62) arith -> MOD .

    NUMBER          reduce using rule 62 (arith -> MOD .)
    FLOAT           reduce using rule 62 (arith -> MOD .)
    LOCAL           reduce using rule 62 (arith -> MOD .)
    GLOBAL          reduce using rule 62 (arith -> MOD .)
    CONSTANTS       reduce using rule 62 (arith -> MOD .)
    INSTANCEVAR     reduce using rule 62 (arith -> MOD .)
    CLASSVAR        reduce using rule 62 (arith -> MOD .)


state 47

    (60) arith -> MUL .

    NUMBER          reduce using rule 60 (arith -> MUL .)
    FLOAT           reduce using rule 60 (arith -> MUL .)
    LOCAL           reduce using rule 60 (arith -> MUL .)
    GLOBAL          reduce using rule 60 (arith -> MUL .)
    CONSTANTS       reduce using rule 60 (arith -> MUL .)
    INSTANCEVAR     reduce using rule 60 (arith -> MUL .)
    CLASSVAR        reduce using rule 60 (arith -> MUL .)


state 48

    (33) math -> term arith . term
    (34) math -> term arith . math
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR

    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21

    math                           shift and go to state 88
    variable                       shift and go to state 89
    term                           shift and go to state 87

state 49

    (30) assign -> variable ASS . expr
    (31) assign -> variable ASS . sexpr
    (32) assign -> variable ASS . array
    (41) asig -> ASS .
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (54) sexpr -> . sterm MUL term
    (55) sexpr -> . sterm ADD sexpr
    (85) array -> . LBRACK defarray RBRACK
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (58) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (97) slice -> . variable LBRACK defslice RBRACK
    (96) index -> . variable LBRACK INT RBRACK

  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    LBRACK          shift and go to state 94
    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    STRING          shift and go to state 18
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21

  ! NUMBER          [ reduce using rule 41 (asig -> ASS .) ]
  ! FLOAT           [ reduce using rule 41 (asig -> ASS .) ]

    expr                           shift and go to state 90
    slice                          shift and go to state 13
    math                           shift and go to state 22
    sterm                          shift and go to state 91
    array                          shift and go to state 93
    term                           shift and go to state 71
    index                          shift and go to state 10
    sexpr                          shift and go to state 92
    variable                       shift and go to state 77

state 50

    (35) math -> variable asig . term
    (56) term -> . NUMBER
    (57) term -> . FLOAT

    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14

    term                           shift and go to state 95

state 51

    (47) asig -> EXPASS .

    NUMBER          reduce using rule 47 (asig -> EXPASS .)
    FLOAT           reduce using rule 47 (asig -> EXPASS .)


state 52

    (42) asig -> ADDASS .

    NUMBER          reduce using rule 42 (asig -> ADDASS .)
    FLOAT           reduce using rule 42 (asig -> ADDASS .)


state 53

    (44) asig -> MULASS .

    NUMBER          reduce using rule 44 (asig -> MULASS .)
    FLOAT           reduce using rule 44 (asig -> MULASS .)


state 54

    (46) asig -> MODASS .

    NUMBER          reduce using rule 46 (asig -> MODASS .)
    FLOAT           reduce using rule 46 (asig -> MODASS .)


state 55

    (45) asig -> DIVASS .

    NUMBER          reduce using rule 45 (asig -> DIVASS .)
    FLOAT           reduce using rule 45 (asig -> DIVASS .)


state 56

    (97) slice -> variable LBRACK . defslice RBRACK
    (96) index -> variable LBRACK . INT RBRACK
    (98) defslice -> . INT DOBLEPOINT INT
    (99) defslice -> . INT DOBLEPOINT
    (100) defslice -> . DOBLEPOINT INT

    INT             shift and go to state 96
    DOBLEPOINT      shift and go to state 97

    defslice                       shift and go to state 98

state 57

    (43) asig -> SUBASS .

    NUMBER          reduce using rule 43 (asig -> SUBASS .)
    FLOAT           reduce using rule 43 (asig -> SUBASS .)


state 58

    (77) elsif -> ELSIF logical . final
    (16) logical -> logical . logcompare logical
    (78) final -> . code
    (79) final -> . THEN code
    (80) final -> . code else
    (81) final -> . code elsif
    (24) logcompare -> . ANDLOG
    (25) logcompare -> . ORLOG
    (26) logcompare -> . NOTLOG
    (27) logcompare -> . AND
    (28) logcompare -> . OR
    (29) logcompare -> . NOT
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (70) if -> . IF logical expr END
    (71) if -> . IF logical THEN expr END
    (72) if -> . IF logical
    (73) if -> . IF logical THEN
    (74) if -> . if else
    (75) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (84) expresiones -> . term DOUBLESECUENCEPOINT term
    (65) for -> . FOR iterador IN expresiones code END
    (66) for -> . FOR iterador IN expresiones DO code END
    (67) for -> . FOR iterador IN array code END
    (68) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (58) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (97) slice -> . variable LBRACK defslice RBRACK
    (96) index -> . variable LBRACK INT RBRACK

    THEN            shift and go to state 100
    ANDLOG          shift and go to state 76
    ORLOG           shift and go to state 73
    NOTLOG          shift and go to state 70
    AND             shift and go to state 78
    OR              shift and go to state 75
    NOT             shift and go to state 72
    IF              shift and go to state 6
    WHILE           shift and go to state 8
    BEGIN           shift and go to state 7
    FOR             shift and go to state 11
    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    STRING          shift and go to state 18
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21

    expr                           shift and go to state 1
    if                             shift and go to state 2
    expresiones                    shift and go to state 15
    logcompare                     shift and go to state 69
    sterm                          shift and go to state 3
    for                            shift and go to state 16
    term                           shift and go to state 17
    code                           shift and go to state 99
    slice                          shift and go to state 13
    assign                         shift and go to state 23
    math                           shift and go to state 22
    while                          shift and go to state 9
    index                          shift and go to state 10
    variable                       shift and go to state 25
    final                          shift and go to state 101

state 59

    (75) if -> if elsif END .

    ELSE            reduce using rule 75 (if -> if elsif END .)
    ELSIF           reduce using rule 75 (if -> if elsif END .)
    END             reduce using rule 75 (if -> if elsif END .)
    IF              reduce using rule 75 (if -> if elsif END .)
    WHILE           reduce using rule 75 (if -> if elsif END .)
    BEGIN           reduce using rule 75 (if -> if elsif END .)
    FOR             reduce using rule 75 (if -> if elsif END .)
    NUMBER          reduce using rule 75 (if -> if elsif END .)
    FLOAT           reduce using rule 75 (if -> if elsif END .)
    STRING          reduce using rule 75 (if -> if elsif END .)
    LOCAL           reduce using rule 75 (if -> if elsif END .)
    GLOBAL          reduce using rule 75 (if -> if elsif END .)
    CONSTANTS       reduce using rule 75 (if -> if elsif END .)
    INSTANCEVAR     reduce using rule 75 (if -> if elsif END .)
    CLASSVAR        reduce using rule 75 (if -> if elsif END .)
    $end            reduce using rule 75 (if -> if elsif END .)
    NEWLINE         reduce using rule 75 (if -> if elsif END .)


state 60

    (76) else -> ELSE code . END
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (70) if -> . IF logical expr END
    (71) if -> . IF logical THEN expr END
    (72) if -> . IF logical
    (73) if -> . IF logical THEN
    (74) if -> . if else
    (75) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (84) expresiones -> . term DOUBLESECUENCEPOINT term
    (65) for -> . FOR iterador IN expresiones code END
    (66) for -> . FOR iterador IN expresiones DO code END
    (67) for -> . FOR iterador IN array code END
    (68) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (58) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (97) slice -> . variable LBRACK defslice RBRACK
    (96) index -> . variable LBRACK INT RBRACK

    END             shift and go to state 102
    IF              shift and go to state 6
    WHILE           shift and go to state 8
    BEGIN           shift and go to state 7
    FOR             shift and go to state 11
    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    STRING          shift and go to state 18
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21

    expr                           shift and go to state 1
    slice                          shift and go to state 13
    if                             shift and go to state 2
    expresiones                    shift and go to state 15
    sterm                          shift and go to state 3
    for                            shift and go to state 16
    term                           shift and go to state 17
    code                           shift and go to state 30
    assign                         shift and go to state 23
    math                           shift and go to state 22
    while                          shift and go to state 9
    index                          shift and go to state 10
    variable                       shift and go to state 25

state 61

    (22) comparison -> GREATHEREQ .

    NUMBER          reduce using rule 22 (comparison -> GREATHEREQ .)
    FLOAT           reduce using rule 22 (comparison -> GREATHEREQ .)
    LOCAL           reduce using rule 22 (comparison -> GREATHEREQ .)
    GLOBAL          reduce using rule 22 (comparison -> GREATHEREQ .)
    CONSTANTS       reduce using rule 22 (comparison -> GREATHEREQ .)
    INSTANCEVAR     reduce using rule 22 (comparison -> GREATHEREQ .)
    CLASSVAR        reduce using rule 22 (comparison -> GREATHEREQ .)
    TRUE            reduce using rule 22 (comparison -> GREATHEREQ .)
    FALSE           reduce using rule 22 (comparison -> GREATHEREQ .)


state 62

    (23) comparison -> LOWEREQ .

    NUMBER          reduce using rule 23 (comparison -> LOWEREQ .)
    FLOAT           reduce using rule 23 (comparison -> LOWEREQ .)
    LOCAL           reduce using rule 23 (comparison -> LOWEREQ .)
    GLOBAL          reduce using rule 23 (comparison -> LOWEREQ .)
    CONSTANTS       reduce using rule 23 (comparison -> LOWEREQ .)
    INSTANCEVAR     reduce using rule 23 (comparison -> LOWEREQ .)
    CLASSVAR        reduce using rule 23 (comparison -> LOWEREQ .)
    TRUE            reduce using rule 23 (comparison -> LOWEREQ .)
    FALSE           reduce using rule 23 (comparison -> LOWEREQ .)


state 63

    (18) comparison -> EQUAL .

    NUMBER          reduce using rule 18 (comparison -> EQUAL .)
    FLOAT           reduce using rule 18 (comparison -> EQUAL .)
    LOCAL           reduce using rule 18 (comparison -> EQUAL .)
    GLOBAL          reduce using rule 18 (comparison -> EQUAL .)
    CONSTANTS       reduce using rule 18 (comparison -> EQUAL .)
    INSTANCEVAR     reduce using rule 18 (comparison -> EQUAL .)
    CLASSVAR        reduce using rule 18 (comparison -> EQUAL .)
    TRUE            reduce using rule 18 (comparison -> EQUAL .)
    FALSE           reduce using rule 18 (comparison -> EQUAL .)


state 64

    (19) comparison -> NOTEQ .

    NUMBER          reduce using rule 19 (comparison -> NOTEQ .)
    FLOAT           reduce using rule 19 (comparison -> NOTEQ .)
    LOCAL           reduce using rule 19 (comparison -> NOTEQ .)
    GLOBAL          reduce using rule 19 (comparison -> NOTEQ .)
    CONSTANTS       reduce using rule 19 (comparison -> NOTEQ .)
    INSTANCEVAR     reduce using rule 19 (comparison -> NOTEQ .)
    CLASSVAR        reduce using rule 19 (comparison -> NOTEQ .)
    TRUE            reduce using rule 19 (comparison -> NOTEQ .)
    FALSE           reduce using rule 19 (comparison -> NOTEQ .)


state 65

    (20) comparison -> GREATHER .

    NUMBER          reduce using rule 20 (comparison -> GREATHER .)
    FLOAT           reduce using rule 20 (comparison -> GREATHER .)
    LOCAL           reduce using rule 20 (comparison -> GREATHER .)
    GLOBAL          reduce using rule 20 (comparison -> GREATHER .)
    CONSTANTS       reduce using rule 20 (comparison -> GREATHER .)
    INSTANCEVAR     reduce using rule 20 (comparison -> GREATHER .)
    CLASSVAR        reduce using rule 20 (comparison -> GREATHER .)
    TRUE            reduce using rule 20 (comparison -> GREATHER .)
    FALSE           reduce using rule 20 (comparison -> GREATHER .)


state 66

    (21) comparison -> LOWER .

    NUMBER          reduce using rule 21 (comparison -> LOWER .)
    FLOAT           reduce using rule 21 (comparison -> LOWER .)
    LOCAL           reduce using rule 21 (comparison -> LOWER .)
    GLOBAL          reduce using rule 21 (comparison -> LOWER .)
    CONSTANTS       reduce using rule 21 (comparison -> LOWER .)
    INSTANCEVAR     reduce using rule 21 (comparison -> LOWER .)
    CLASSVAR        reduce using rule 21 (comparison -> LOWER .)
    TRUE            reduce using rule 21 (comparison -> LOWER .)
    FALSE           reduce using rule 21 (comparison -> LOWER .)


state 67

    (12) logical -> term comparison . term
    (13) logical -> term comparison . logical
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (12) logical -> . term comparison term
    (13) logical -> . term comparison logical
    (14) logical -> . variable comparison term
    (15) logical -> . variable comparison boolean
    (16) logical -> . logical logcompare logical
    (17) logical -> . boolean
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (101) boolean -> . TRUE
    (102) boolean -> . FALSE

    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21
    TRUE            shift and go to state 35
    FALSE           shift and go to state 31

    term                           shift and go to state 103
    logical                        shift and go to state 104
    variable                       shift and go to state 34
    boolean                        shift and go to state 36

state 68

    (70) if -> IF logical expr . END

    END             shift and go to state 105


state 69

    (16) logical -> logical logcompare . logical
    (12) logical -> . term comparison term
    (13) logical -> . term comparison logical
    (14) logical -> . variable comparison term
    (15) logical -> . variable comparison boolean
    (16) logical -> . logical logcompare logical
    (17) logical -> . boolean
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (101) boolean -> . TRUE
    (102) boolean -> . FALSE

    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21
    TRUE            shift and go to state 35
    FALSE           shift and go to state 31

    term                           shift and go to state 32
    logical                        shift and go to state 106
    variable                       shift and go to state 34
    boolean                        shift and go to state 36

state 70

    (26) logcompare -> NOTLOG .

    NUMBER          reduce using rule 26 (logcompare -> NOTLOG .)
    FLOAT           reduce using rule 26 (logcompare -> NOTLOG .)
    LOCAL           reduce using rule 26 (logcompare -> NOTLOG .)
    GLOBAL          reduce using rule 26 (logcompare -> NOTLOG .)
    CONSTANTS       reduce using rule 26 (logcompare -> NOTLOG .)
    INSTANCEVAR     reduce using rule 26 (logcompare -> NOTLOG .)
    CLASSVAR        reduce using rule 26 (logcompare -> NOTLOG .)
    TRUE            reduce using rule 26 (logcompare -> NOTLOG .)
    FALSE           reduce using rule 26 (logcompare -> NOTLOG .)


state 71

    (49) expr -> term .
    (33) math -> term . arith term
    (34) math -> term . arith math
    (59) arith -> . EXP
    (60) arith -> . MUL
    (61) arith -> . DIV
    (62) arith -> . MOD
    (63) arith -> . ADD
    (64) arith -> . SUB

    END             reduce using rule 49 (expr -> term .)
    IF              reduce using rule 49 (expr -> term .)
    WHILE           reduce using rule 49 (expr -> term .)
    BEGIN           reduce using rule 49 (expr -> term .)
    FOR             reduce using rule 49 (expr -> term .)
    NUMBER          reduce using rule 49 (expr -> term .)
    FLOAT           reduce using rule 49 (expr -> term .)
    STRING          reduce using rule 49 (expr -> term .)
    LOCAL           reduce using rule 49 (expr -> term .)
    GLOBAL          reduce using rule 49 (expr -> term .)
    CONSTANTS       reduce using rule 49 (expr -> term .)
    INSTANCEVAR     reduce using rule 49 (expr -> term .)
    CLASSVAR        reduce using rule 49 (expr -> term .)
    $end            reduce using rule 49 (expr -> term .)
    ELSE            reduce using rule 49 (expr -> term .)
    ELSIF           reduce using rule 49 (expr -> term .)
    NEWLINE         reduce using rule 49 (expr -> term .)
    EXP             shift and go to state 42
    MUL             shift and go to state 47
    DIV             shift and go to state 44
    MOD             shift and go to state 46
    ADD             shift and go to state 43
    SUB             shift and go to state 45

    arith                          shift and go to state 48

state 72

    (29) logcompare -> NOT .

    NUMBER          reduce using rule 29 (logcompare -> NOT .)
    FLOAT           reduce using rule 29 (logcompare -> NOT .)
    LOCAL           reduce using rule 29 (logcompare -> NOT .)
    GLOBAL          reduce using rule 29 (logcompare -> NOT .)
    CONSTANTS       reduce using rule 29 (logcompare -> NOT .)
    INSTANCEVAR     reduce using rule 29 (logcompare -> NOT .)
    CLASSVAR        reduce using rule 29 (logcompare -> NOT .)
    TRUE            reduce using rule 29 (logcompare -> NOT .)
    FALSE           reduce using rule 29 (logcompare -> NOT .)


state 73

    (25) logcompare -> ORLOG .

    NUMBER          reduce using rule 25 (logcompare -> ORLOG .)
    FLOAT           reduce using rule 25 (logcompare -> ORLOG .)
    LOCAL           reduce using rule 25 (logcompare -> ORLOG .)
    GLOBAL          reduce using rule 25 (logcompare -> ORLOG .)
    CONSTANTS       reduce using rule 25 (logcompare -> ORLOG .)
    INSTANCEVAR     reduce using rule 25 (logcompare -> ORLOG .)
    CLASSVAR        reduce using rule 25 (logcompare -> ORLOG .)
    TRUE            reduce using rule 25 (logcompare -> ORLOG .)
    FALSE           reduce using rule 25 (logcompare -> ORLOG .)


state 74

    (71) if -> IF logical THEN . expr END
    (73) if -> IF logical THEN .
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (58) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (97) slice -> . variable LBRACK defslice RBRACK
    (96) index -> . variable LBRACK INT RBRACK

  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for LOCAL resolved as shift
  ! shift/reduce conflict for GLOBAL resolved as shift
  ! shift/reduce conflict for CONSTANTS resolved as shift
  ! shift/reduce conflict for INSTANCEVAR resolved as shift
  ! shift/reduce conflict for CLASSVAR resolved as shift
    ELSE            reduce using rule 73 (if -> IF logical THEN .)
    ELSIF           reduce using rule 73 (if -> IF logical THEN .)
    END             reduce using rule 73 (if -> IF logical THEN .)
    IF              reduce using rule 73 (if -> IF logical THEN .)
    WHILE           reduce using rule 73 (if -> IF logical THEN .)
    BEGIN           reduce using rule 73 (if -> IF logical THEN .)
    FOR             reduce using rule 73 (if -> IF logical THEN .)
    $end            reduce using rule 73 (if -> IF logical THEN .)
    NEWLINE         reduce using rule 73 (if -> IF logical THEN .)
    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    STRING          shift and go to state 18
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21

  ! NUMBER          [ reduce using rule 73 (if -> IF logical THEN .) ]
  ! FLOAT           [ reduce using rule 73 (if -> IF logical THEN .) ]
  ! STRING          [ reduce using rule 73 (if -> IF logical THEN .) ]
  ! LOCAL           [ reduce using rule 73 (if -> IF logical THEN .) ]
  ! GLOBAL          [ reduce using rule 73 (if -> IF logical THEN .) ]
  ! CONSTANTS       [ reduce using rule 73 (if -> IF logical THEN .) ]
  ! INSTANCEVAR     [ reduce using rule 73 (if -> IF logical THEN .) ]
  ! CLASSVAR        [ reduce using rule 73 (if -> IF logical THEN .) ]

    expr                           shift and go to state 107
    term                           shift and go to state 71
    slice                          shift and go to state 13
    index                          shift and go to state 10
    math                           shift and go to state 22
    variable                       shift and go to state 77
    sterm                          shift and go to state 3

state 75

    (28) logcompare -> OR .

    NUMBER          reduce using rule 28 (logcompare -> OR .)
    FLOAT           reduce using rule 28 (logcompare -> OR .)
    LOCAL           reduce using rule 28 (logcompare -> OR .)
    GLOBAL          reduce using rule 28 (logcompare -> OR .)
    CONSTANTS       reduce using rule 28 (logcompare -> OR .)
    INSTANCEVAR     reduce using rule 28 (logcompare -> OR .)
    CLASSVAR        reduce using rule 28 (logcompare -> OR .)
    TRUE            reduce using rule 28 (logcompare -> OR .)
    FALSE           reduce using rule 28 (logcompare -> OR .)


state 76

    (24) logcompare -> ANDLOG .

    NUMBER          reduce using rule 24 (logcompare -> ANDLOG .)
    FLOAT           reduce using rule 24 (logcompare -> ANDLOG .)
    LOCAL           reduce using rule 24 (logcompare -> ANDLOG .)
    GLOBAL          reduce using rule 24 (logcompare -> ANDLOG .)
    CONSTANTS       reduce using rule 24 (logcompare -> ANDLOG .)
    INSTANCEVAR     reduce using rule 24 (logcompare -> ANDLOG .)
    CLASSVAR        reduce using rule 24 (logcompare -> ANDLOG .)
    TRUE            reduce using rule 24 (logcompare -> ANDLOG .)
    FALSE           reduce using rule 24 (logcompare -> ANDLOG .)


state 77

    (51) expr -> variable .
    (35) math -> variable . asig term
    (97) slice -> variable . LBRACK defslice RBRACK
    (96) index -> variable . LBRACK INT RBRACK
    (41) asig -> . ASS
    (42) asig -> . ADDASS
    (43) asig -> . SUBASS
    (44) asig -> . MULASS
    (45) asig -> . DIVASS
    (46) asig -> . MODASS
    (47) asig -> . EXPASS

    END             reduce using rule 51 (expr -> variable .)
    IF              reduce using rule 51 (expr -> variable .)
    WHILE           reduce using rule 51 (expr -> variable .)
    BEGIN           reduce using rule 51 (expr -> variable .)
    FOR             reduce using rule 51 (expr -> variable .)
    NUMBER          reduce using rule 51 (expr -> variable .)
    FLOAT           reduce using rule 51 (expr -> variable .)
    STRING          reduce using rule 51 (expr -> variable .)
    LOCAL           reduce using rule 51 (expr -> variable .)
    GLOBAL          reduce using rule 51 (expr -> variable .)
    CONSTANTS       reduce using rule 51 (expr -> variable .)
    INSTANCEVAR     reduce using rule 51 (expr -> variable .)
    CLASSVAR        reduce using rule 51 (expr -> variable .)
    $end            reduce using rule 51 (expr -> variable .)
    ELSE            reduce using rule 51 (expr -> variable .)
    ELSIF           reduce using rule 51 (expr -> variable .)
    NEWLINE         reduce using rule 51 (expr -> variable .)
    LBRACK          shift and go to state 56
    ASS             shift and go to state 108
    ADDASS          shift and go to state 52
    SUBASS          shift and go to state 57
    MULASS          shift and go to state 53
    DIVASS          shift and go to state 55
    MODASS          shift and go to state 54
    EXPASS          shift and go to state 51

    asig                           shift and go to state 50

state 78

    (27) logcompare -> AND .

    NUMBER          reduce using rule 27 (logcompare -> AND .)
    FLOAT           reduce using rule 27 (logcompare -> AND .)
    LOCAL           reduce using rule 27 (logcompare -> AND .)
    GLOBAL          reduce using rule 27 (logcompare -> AND .)
    CONSTANTS       reduce using rule 27 (logcompare -> AND .)
    INSTANCEVAR     reduce using rule 27 (logcompare -> AND .)
    CLASSVAR        reduce using rule 27 (logcompare -> AND .)
    TRUE            reduce using rule 27 (logcompare -> AND .)
    FALSE           reduce using rule 27 (logcompare -> AND .)


state 79

    (14) logical -> variable comparison . term
    (15) logical -> variable comparison . boolean
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (101) boolean -> . TRUE
    (102) boolean -> . FALSE

    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    TRUE            shift and go to state 35
    FALSE           shift and go to state 31

    term                           shift and go to state 109
    boolean                        shift and go to state 110

state 80

    (11) while -> BEGIN code END . WHILE logical

    WHILE           shift and go to state 111


state 81

    (8) while -> WHILE logical code . END
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (70) if -> . IF logical expr END
    (71) if -> . IF logical THEN expr END
    (72) if -> . IF logical
    (73) if -> . IF logical THEN
    (74) if -> . if else
    (75) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (84) expresiones -> . term DOUBLESECUENCEPOINT term
    (65) for -> . FOR iterador IN expresiones code END
    (66) for -> . FOR iterador IN expresiones DO code END
    (67) for -> . FOR iterador IN array code END
    (68) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (58) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (97) slice -> . variable LBRACK defslice RBRACK
    (96) index -> . variable LBRACK INT RBRACK

    END             shift and go to state 112
    IF              shift and go to state 6
    WHILE           shift and go to state 8
    BEGIN           shift and go to state 7
    FOR             shift and go to state 11
    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    STRING          shift and go to state 18
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21

    expr                           shift and go to state 1
    slice                          shift and go to state 13
    if                             shift and go to state 2
    expresiones                    shift and go to state 15
    sterm                          shift and go to state 3
    for                            shift and go to state 16
    term                           shift and go to state 17
    code                           shift and go to state 30
    assign                         shift and go to state 23
    math                           shift and go to state 22
    while                          shift and go to state 9
    index                          shift and go to state 10
    variable                       shift and go to state 25

state 82

    (9) while -> WHILE logical DO . salto code salto END
    (69) salto -> . NEWLINE

    NEWLINE         shift and go to state 113

    salto                          shift and go to state 114

state 83

    (10) while -> WHILE logical DOBLEPOINT . salto code salto END
    (69) salto -> . NEWLINE

    NEWLINE         shift and go to state 113

    salto                          shift and go to state 115

state 84

    (65) for -> FOR iterador IN . expresiones code END
    (66) for -> FOR iterador IN . expresiones DO code END
    (67) for -> FOR iterador IN . array code END
    (68) for -> FOR iterador IN . array DO code END
    (84) expresiones -> . term DOUBLESECUENCEPOINT term
    (85) array -> . LBRACK defarray RBRACK
    (56) term -> . NUMBER
    (57) term -> . FLOAT

    LBRACK          shift and go to state 94
    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14

    array                          shift and go to state 117
    term                           shift and go to state 118
    expresiones                    shift and go to state 116

state 85

    (83) iterador -> variable COMA . variable
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR

    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21

    variable                       shift and go to state 119

state 86

    (84) expresiones -> term DOUBLESECUENCEPOINT term .

    END             reduce using rule 84 (expresiones -> term DOUBLESECUENCEPOINT term .)
    IF              reduce using rule 84 (expresiones -> term DOUBLESECUENCEPOINT term .)
    WHILE           reduce using rule 84 (expresiones -> term DOUBLESECUENCEPOINT term .)
    BEGIN           reduce using rule 84 (expresiones -> term DOUBLESECUENCEPOINT term .)
    FOR             reduce using rule 84 (expresiones -> term DOUBLESECUENCEPOINT term .)
    NUMBER          reduce using rule 84 (expresiones -> term DOUBLESECUENCEPOINT term .)
    FLOAT           reduce using rule 84 (expresiones -> term DOUBLESECUENCEPOINT term .)
    STRING          reduce using rule 84 (expresiones -> term DOUBLESECUENCEPOINT term .)
    LOCAL           reduce using rule 84 (expresiones -> term DOUBLESECUENCEPOINT term .)
    GLOBAL          reduce using rule 84 (expresiones -> term DOUBLESECUENCEPOINT term .)
    CONSTANTS       reduce using rule 84 (expresiones -> term DOUBLESECUENCEPOINT term .)
    INSTANCEVAR     reduce using rule 84 (expresiones -> term DOUBLESECUENCEPOINT term .)
    CLASSVAR        reduce using rule 84 (expresiones -> term DOUBLESECUENCEPOINT term .)
    DO              reduce using rule 84 (expresiones -> term DOUBLESECUENCEPOINT term .)
    NEWLINE         reduce using rule 84 (expresiones -> term DOUBLESECUENCEPOINT term .)
    $end            reduce using rule 84 (expresiones -> term DOUBLESECUENCEPOINT term .)
    ELSE            reduce using rule 84 (expresiones -> term DOUBLESECUENCEPOINT term .)
    ELSIF           reduce using rule 84 (expresiones -> term DOUBLESECUENCEPOINT term .)


state 87

    (33) math -> term arith term .
    (33) math -> term . arith term
    (34) math -> term . arith math
    (59) arith -> . EXP
    (60) arith -> . MUL
    (61) arith -> . DIV
    (62) arith -> . MOD
    (63) arith -> . ADD
    (64) arith -> . SUB

    IF              reduce using rule 33 (math -> term arith term .)
    WHILE           reduce using rule 33 (math -> term arith term .)
    BEGIN           reduce using rule 33 (math -> term arith term .)
    FOR             reduce using rule 33 (math -> term arith term .)
    NUMBER          reduce using rule 33 (math -> term arith term .)
    FLOAT           reduce using rule 33 (math -> term arith term .)
    STRING          reduce using rule 33 (math -> term arith term .)
    LOCAL           reduce using rule 33 (math -> term arith term .)
    GLOBAL          reduce using rule 33 (math -> term arith term .)
    CONSTANTS       reduce using rule 33 (math -> term arith term .)
    INSTANCEVAR     reduce using rule 33 (math -> term arith term .)
    CLASSVAR        reduce using rule 33 (math -> term arith term .)
    END             reduce using rule 33 (math -> term arith term .)
    $end            reduce using rule 33 (math -> term arith term .)
    ELSE            reduce using rule 33 (math -> term arith term .)
    ELSIF           reduce using rule 33 (math -> term arith term .)
    NEWLINE         reduce using rule 33 (math -> term arith term .)
    EXP             shift and go to state 42
    MUL             shift and go to state 47
    DIV             shift and go to state 44
    MOD             shift and go to state 46
    ADD             shift and go to state 43
    SUB             shift and go to state 45

    arith                          shift and go to state 48

state 88

    (34) math -> term arith math .

    IF              reduce using rule 34 (math -> term arith math .)
    WHILE           reduce using rule 34 (math -> term arith math .)
    BEGIN           reduce using rule 34 (math -> term arith math .)
    FOR             reduce using rule 34 (math -> term arith math .)
    NUMBER          reduce using rule 34 (math -> term arith math .)
    FLOAT           reduce using rule 34 (math -> term arith math .)
    STRING          reduce using rule 34 (math -> term arith math .)
    LOCAL           reduce using rule 34 (math -> term arith math .)
    GLOBAL          reduce using rule 34 (math -> term arith math .)
    CONSTANTS       reduce using rule 34 (math -> term arith math .)
    INSTANCEVAR     reduce using rule 34 (math -> term arith math .)
    CLASSVAR        reduce using rule 34 (math -> term arith math .)
    END             reduce using rule 34 (math -> term arith math .)
    $end            reduce using rule 34 (math -> term arith math .)
    ELSE            reduce using rule 34 (math -> term arith math .)
    ELSIF           reduce using rule 34 (math -> term arith math .)
    NEWLINE         reduce using rule 34 (math -> term arith math .)


state 89

    (35) math -> variable . asig term
    (41) asig -> . ASS
    (42) asig -> . ADDASS
    (43) asig -> . SUBASS
    (44) asig -> . MULASS
    (45) asig -> . DIVASS
    (46) asig -> . MODASS
    (47) asig -> . EXPASS

    ASS             shift and go to state 108
    ADDASS          shift and go to state 52
    SUBASS          shift and go to state 57
    MULASS          shift and go to state 53
    DIVASS          shift and go to state 55
    MODASS          shift and go to state 54
    EXPASS          shift and go to state 51

    asig                           shift and go to state 50

state 90

    (30) assign -> variable ASS expr .

    IF              reduce using rule 30 (assign -> variable ASS expr .)
    WHILE           reduce using rule 30 (assign -> variable ASS expr .)
    BEGIN           reduce using rule 30 (assign -> variable ASS expr .)
    FOR             reduce using rule 30 (assign -> variable ASS expr .)
    NUMBER          reduce using rule 30 (assign -> variable ASS expr .)
    FLOAT           reduce using rule 30 (assign -> variable ASS expr .)
    STRING          reduce using rule 30 (assign -> variable ASS expr .)
    LOCAL           reduce using rule 30 (assign -> variable ASS expr .)
    GLOBAL          reduce using rule 30 (assign -> variable ASS expr .)
    CONSTANTS       reduce using rule 30 (assign -> variable ASS expr .)
    INSTANCEVAR     reduce using rule 30 (assign -> variable ASS expr .)
    CLASSVAR        reduce using rule 30 (assign -> variable ASS expr .)
    END             reduce using rule 30 (assign -> variable ASS expr .)
    NEWLINE         reduce using rule 30 (assign -> variable ASS expr .)
    ELSE            reduce using rule 30 (assign -> variable ASS expr .)
    ELSIF           reduce using rule 30 (assign -> variable ASS expr .)
    $end            reduce using rule 30 (assign -> variable ASS expr .)


state 91

    (50) expr -> sterm .
    (54) sexpr -> sterm . MUL term
    (55) sexpr -> sterm . ADD sexpr

    IF              reduce using rule 50 (expr -> sterm .)
    WHILE           reduce using rule 50 (expr -> sterm .)
    BEGIN           reduce using rule 50 (expr -> sterm .)
    FOR             reduce using rule 50 (expr -> sterm .)
    NUMBER          reduce using rule 50 (expr -> sterm .)
    FLOAT           reduce using rule 50 (expr -> sterm .)
    STRING          reduce using rule 50 (expr -> sterm .)
    LOCAL           reduce using rule 50 (expr -> sterm .)
    GLOBAL          reduce using rule 50 (expr -> sterm .)
    CONSTANTS       reduce using rule 50 (expr -> sterm .)
    INSTANCEVAR     reduce using rule 50 (expr -> sterm .)
    CLASSVAR        reduce using rule 50 (expr -> sterm .)
    $end            reduce using rule 50 (expr -> sterm .)
    END             reduce using rule 50 (expr -> sterm .)
    ELSE            reduce using rule 50 (expr -> sterm .)
    ELSIF           reduce using rule 50 (expr -> sterm .)
    NEWLINE         reduce using rule 50 (expr -> sterm .)
    MUL             shift and go to state 120
    ADD             shift and go to state 121


state 92

    (31) assign -> variable ASS sexpr .

    IF              reduce using rule 31 (assign -> variable ASS sexpr .)
    WHILE           reduce using rule 31 (assign -> variable ASS sexpr .)
    BEGIN           reduce using rule 31 (assign -> variable ASS sexpr .)
    FOR             reduce using rule 31 (assign -> variable ASS sexpr .)
    NUMBER          reduce using rule 31 (assign -> variable ASS sexpr .)
    FLOAT           reduce using rule 31 (assign -> variable ASS sexpr .)
    STRING          reduce using rule 31 (assign -> variable ASS sexpr .)
    LOCAL           reduce using rule 31 (assign -> variable ASS sexpr .)
    GLOBAL          reduce using rule 31 (assign -> variable ASS sexpr .)
    CONSTANTS       reduce using rule 31 (assign -> variable ASS sexpr .)
    INSTANCEVAR     reduce using rule 31 (assign -> variable ASS sexpr .)
    CLASSVAR        reduce using rule 31 (assign -> variable ASS sexpr .)
    END             reduce using rule 31 (assign -> variable ASS sexpr .)
    NEWLINE         reduce using rule 31 (assign -> variable ASS sexpr .)
    ELSE            reduce using rule 31 (assign -> variable ASS sexpr .)
    ELSIF           reduce using rule 31 (assign -> variable ASS sexpr .)
    $end            reduce using rule 31 (assign -> variable ASS sexpr .)


state 93

    (32) assign -> variable ASS array .

    IF              reduce using rule 32 (assign -> variable ASS array .)
    WHILE           reduce using rule 32 (assign -> variable ASS array .)
    BEGIN           reduce using rule 32 (assign -> variable ASS array .)
    FOR             reduce using rule 32 (assign -> variable ASS array .)
    NUMBER          reduce using rule 32 (assign -> variable ASS array .)
    FLOAT           reduce using rule 32 (assign -> variable ASS array .)
    STRING          reduce using rule 32 (assign -> variable ASS array .)
    LOCAL           reduce using rule 32 (assign -> variable ASS array .)
    GLOBAL          reduce using rule 32 (assign -> variable ASS array .)
    CONSTANTS       reduce using rule 32 (assign -> variable ASS array .)
    INSTANCEVAR     reduce using rule 32 (assign -> variable ASS array .)
    CLASSVAR        reduce using rule 32 (assign -> variable ASS array .)
    END             reduce using rule 32 (assign -> variable ASS array .)
    NEWLINE         reduce using rule 32 (assign -> variable ASS array .)
    ELSE            reduce using rule 32 (assign -> variable ASS array .)
    ELSIF           reduce using rule 32 (assign -> variable ASS array .)
    $end            reduce using rule 32 (assign -> variable ASS array .)


state 94

    (85) array -> LBRACK . defarray RBRACK
    (86) defarray -> . NUMBER
    (87) defarray -> . NUMBER COMA defarray
    (88) defarray -> . STRING
    (89) defarray -> . STRING COMA defarray
    (90) defarray -> . INT
    (91) defarray -> . INT COMA defarray
    (92) defarray -> . FLOAT
    (93) defarray -> . FLOAT COMA defarray
    (94) defarray -> . boolean
    (95) defarray -> . boolean COMA defarray
    (101) boolean -> . TRUE
    (102) boolean -> . FALSE

    NUMBER          shift and go to state 125
    STRING          shift and go to state 127
    INT             shift and go to state 126
    FLOAT           shift and go to state 122
    TRUE            shift and go to state 35
    FALSE           shift and go to state 31

    defarray                       shift and go to state 123
    boolean                        shift and go to state 124

state 95

    (35) math -> variable asig term .

    IF              reduce using rule 35 (math -> variable asig term .)
    WHILE           reduce using rule 35 (math -> variable asig term .)
    BEGIN           reduce using rule 35 (math -> variable asig term .)
    FOR             reduce using rule 35 (math -> variable asig term .)
    NUMBER          reduce using rule 35 (math -> variable asig term .)
    FLOAT           reduce using rule 35 (math -> variable asig term .)
    STRING          reduce using rule 35 (math -> variable asig term .)
    LOCAL           reduce using rule 35 (math -> variable asig term .)
    GLOBAL          reduce using rule 35 (math -> variable asig term .)
    CONSTANTS       reduce using rule 35 (math -> variable asig term .)
    INSTANCEVAR     reduce using rule 35 (math -> variable asig term .)
    CLASSVAR        reduce using rule 35 (math -> variable asig term .)
    END             reduce using rule 35 (math -> variable asig term .)
    $end            reduce using rule 35 (math -> variable asig term .)
    ELSE            reduce using rule 35 (math -> variable asig term .)
    ELSIF           reduce using rule 35 (math -> variable asig term .)
    NEWLINE         reduce using rule 35 (math -> variable asig term .)


state 96

    (96) index -> variable LBRACK INT . RBRACK
    (98) defslice -> INT . DOBLEPOINT INT
    (99) defslice -> INT . DOBLEPOINT

    RBRACK          shift and go to state 128
    DOBLEPOINT      shift and go to state 129


state 97

    (100) defslice -> DOBLEPOINT . INT

    INT             shift and go to state 130


state 98

    (97) slice -> variable LBRACK defslice . RBRACK

    RBRACK          shift and go to state 131


state 99

    (78) final -> code .
    (80) final -> code . else
    (81) final -> code . elsif
    (7) code -> code . code
    (76) else -> . ELSE code END
    (77) elsif -> . ELSIF logical final
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (70) if -> . IF logical expr END
    (71) if -> . IF logical THEN expr END
    (72) if -> . IF logical
    (73) if -> . IF logical THEN
    (74) if -> . if else
    (75) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (84) expresiones -> . term DOUBLESECUENCEPOINT term
    (65) for -> . FOR iterador IN expresiones code END
    (66) for -> . FOR iterador IN expresiones DO code END
    (67) for -> . FOR iterador IN array code END
    (68) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (58) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (97) slice -> . variable LBRACK defslice RBRACK
    (96) index -> . variable LBRACK INT RBRACK

    END             reduce using rule 78 (final -> code .)
    ELSE            shift and go to state 29
    ELSIF           shift and go to state 26
    IF              shift and go to state 6
    WHILE           shift and go to state 8
    BEGIN           shift and go to state 7
    FOR             shift and go to state 11
    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    STRING          shift and go to state 18
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21

    expr                           shift and go to state 1
    else                           shift and go to state 132
    if                             shift and go to state 2
    expresiones                    shift and go to state 15
    sterm                          shift and go to state 3
    for                            shift and go to state 16
    term                           shift and go to state 17
    code                           shift and go to state 30
    assign                         shift and go to state 23
    slice                          shift and go to state 13
    math                           shift and go to state 22
    while                          shift and go to state 9
    elsif                          shift and go to state 133
    index                          shift and go to state 10
    variable                       shift and go to state 25

state 100

    (79) final -> THEN . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (70) if -> . IF logical expr END
    (71) if -> . IF logical THEN expr END
    (72) if -> . IF logical
    (73) if -> . IF logical THEN
    (74) if -> . if else
    (75) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (84) expresiones -> . term DOUBLESECUENCEPOINT term
    (65) for -> . FOR iterador IN expresiones code END
    (66) for -> . FOR iterador IN expresiones DO code END
    (67) for -> . FOR iterador IN array code END
    (68) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (58) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (97) slice -> . variable LBRACK defslice RBRACK
    (96) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 6
    WHILE           shift and go to state 8
    BEGIN           shift and go to state 7
    FOR             shift and go to state 11
    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    STRING          shift and go to state 18
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21

    expr                           shift and go to state 1
    slice                          shift and go to state 13
    if                             shift and go to state 2
    expresiones                    shift and go to state 15
    sterm                          shift and go to state 3
    for                            shift and go to state 16
    term                           shift and go to state 17
    code                           shift and go to state 134
    assign                         shift and go to state 23
    math                           shift and go to state 22
    while                          shift and go to state 9
    index                          shift and go to state 10
    variable                       shift and go to state 25

state 101

    (77) elsif -> ELSIF logical final .

    END             reduce using rule 77 (elsif -> ELSIF logical final .)


state 102

    (76) else -> ELSE code END .

    END             reduce using rule 76 (else -> ELSE code END .)
    ELSE            reduce using rule 76 (else -> ELSE code END .)
    ELSIF           reduce using rule 76 (else -> ELSE code END .)
    IF              reduce using rule 76 (else -> ELSE code END .)
    WHILE           reduce using rule 76 (else -> ELSE code END .)
    BEGIN           reduce using rule 76 (else -> ELSE code END .)
    FOR             reduce using rule 76 (else -> ELSE code END .)
    NUMBER          reduce using rule 76 (else -> ELSE code END .)
    FLOAT           reduce using rule 76 (else -> ELSE code END .)
    STRING          reduce using rule 76 (else -> ELSE code END .)
    LOCAL           reduce using rule 76 (else -> ELSE code END .)
    GLOBAL          reduce using rule 76 (else -> ELSE code END .)
    CONSTANTS       reduce using rule 76 (else -> ELSE code END .)
    INSTANCEVAR     reduce using rule 76 (else -> ELSE code END .)
    CLASSVAR        reduce using rule 76 (else -> ELSE code END .)
    $end            reduce using rule 76 (else -> ELSE code END .)
    NEWLINE         reduce using rule 76 (else -> ELSE code END .)


state 103

    (12) logical -> term comparison term .
    (12) logical -> term . comparison term
    (13) logical -> term . comparison logical
    (18) comparison -> . EQUAL
    (19) comparison -> . NOTEQ
    (20) comparison -> . GREATHER
    (21) comparison -> . LOWER
    (22) comparison -> . GREATHEREQ
    (23) comparison -> . LOWEREQ

    THEN            reduce using rule 12 (logical -> term comparison term .)
    ANDLOG          reduce using rule 12 (logical -> term comparison term .)
    ORLOG           reduce using rule 12 (logical -> term comparison term .)
    NOTLOG          reduce using rule 12 (logical -> term comparison term .)
    AND             reduce using rule 12 (logical -> term comparison term .)
    OR              reduce using rule 12 (logical -> term comparison term .)
    NOT             reduce using rule 12 (logical -> term comparison term .)
    NUMBER          reduce using rule 12 (logical -> term comparison term .)
    FLOAT           reduce using rule 12 (logical -> term comparison term .)
    STRING          reduce using rule 12 (logical -> term comparison term .)
    LOCAL           reduce using rule 12 (logical -> term comparison term .)
    GLOBAL          reduce using rule 12 (logical -> term comparison term .)
    CONSTANTS       reduce using rule 12 (logical -> term comparison term .)
    INSTANCEVAR     reduce using rule 12 (logical -> term comparison term .)
    CLASSVAR        reduce using rule 12 (logical -> term comparison term .)
    ELSE            reduce using rule 12 (logical -> term comparison term .)
    ELSIF           reduce using rule 12 (logical -> term comparison term .)
    IF              reduce using rule 12 (logical -> term comparison term .)
    WHILE           reduce using rule 12 (logical -> term comparison term .)
    BEGIN           reduce using rule 12 (logical -> term comparison term .)
    FOR             reduce using rule 12 (logical -> term comparison term .)
    $end            reduce using rule 12 (logical -> term comparison term .)
    END             reduce using rule 12 (logical -> term comparison term .)
    NEWLINE         reduce using rule 12 (logical -> term comparison term .)
    DO              reduce using rule 12 (logical -> term comparison term .)
    DOBLEPOINT      reduce using rule 12 (logical -> term comparison term .)
    EQUAL           shift and go to state 63
    NOTEQ           shift and go to state 64
    GREATHER        shift and go to state 65
    LOWER           shift and go to state 66
    GREATHEREQ      shift and go to state 61
    LOWEREQ         shift and go to state 62

    comparison                     shift and go to state 67

state 104

    (13) logical -> term comparison logical .
    (16) logical -> logical . logcompare logical
    (24) logcompare -> . ANDLOG
    (25) logcompare -> . ORLOG
    (26) logcompare -> . NOTLOG
    (27) logcompare -> . AND
    (28) logcompare -> . OR
    (29) logcompare -> . NOT

  ! shift/reduce conflict for ANDLOG resolved as shift
  ! shift/reduce conflict for ORLOG resolved as shift
  ! shift/reduce conflict for NOTLOG resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    THEN            reduce using rule 13 (logical -> term comparison logical .)
    NUMBER          reduce using rule 13 (logical -> term comparison logical .)
    FLOAT           reduce using rule 13 (logical -> term comparison logical .)
    STRING          reduce using rule 13 (logical -> term comparison logical .)
    LOCAL           reduce using rule 13 (logical -> term comparison logical .)
    GLOBAL          reduce using rule 13 (logical -> term comparison logical .)
    CONSTANTS       reduce using rule 13 (logical -> term comparison logical .)
    INSTANCEVAR     reduce using rule 13 (logical -> term comparison logical .)
    CLASSVAR        reduce using rule 13 (logical -> term comparison logical .)
    ELSE            reduce using rule 13 (logical -> term comparison logical .)
    ELSIF           reduce using rule 13 (logical -> term comparison logical .)
    IF              reduce using rule 13 (logical -> term comparison logical .)
    WHILE           reduce using rule 13 (logical -> term comparison logical .)
    BEGIN           reduce using rule 13 (logical -> term comparison logical .)
    FOR             reduce using rule 13 (logical -> term comparison logical .)
    $end            reduce using rule 13 (logical -> term comparison logical .)
    END             reduce using rule 13 (logical -> term comparison logical .)
    NEWLINE         reduce using rule 13 (logical -> term comparison logical .)
    DO              reduce using rule 13 (logical -> term comparison logical .)
    DOBLEPOINT      reduce using rule 13 (logical -> term comparison logical .)
    ANDLOG          shift and go to state 76
    ORLOG           shift and go to state 73
    NOTLOG          shift and go to state 70
    AND             shift and go to state 78
    OR              shift and go to state 75
    NOT             shift and go to state 72

  ! ANDLOG          [ reduce using rule 13 (logical -> term comparison logical .) ]
  ! ORLOG           [ reduce using rule 13 (logical -> term comparison logical .) ]
  ! NOTLOG          [ reduce using rule 13 (logical -> term comparison logical .) ]
  ! AND             [ reduce using rule 13 (logical -> term comparison logical .) ]
  ! OR              [ reduce using rule 13 (logical -> term comparison logical .) ]
  ! NOT             [ reduce using rule 13 (logical -> term comparison logical .) ]

    logcompare                     shift and go to state 69

state 105

    (70) if -> IF logical expr END .

    ELSE            reduce using rule 70 (if -> IF logical expr END .)
    ELSIF           reduce using rule 70 (if -> IF logical expr END .)
    END             reduce using rule 70 (if -> IF logical expr END .)
    IF              reduce using rule 70 (if -> IF logical expr END .)
    WHILE           reduce using rule 70 (if -> IF logical expr END .)
    BEGIN           reduce using rule 70 (if -> IF logical expr END .)
    FOR             reduce using rule 70 (if -> IF logical expr END .)
    NUMBER          reduce using rule 70 (if -> IF logical expr END .)
    FLOAT           reduce using rule 70 (if -> IF logical expr END .)
    STRING          reduce using rule 70 (if -> IF logical expr END .)
    LOCAL           reduce using rule 70 (if -> IF logical expr END .)
    GLOBAL          reduce using rule 70 (if -> IF logical expr END .)
    CONSTANTS       reduce using rule 70 (if -> IF logical expr END .)
    INSTANCEVAR     reduce using rule 70 (if -> IF logical expr END .)
    CLASSVAR        reduce using rule 70 (if -> IF logical expr END .)
    $end            reduce using rule 70 (if -> IF logical expr END .)
    NEWLINE         reduce using rule 70 (if -> IF logical expr END .)


state 106

    (16) logical -> logical logcompare logical .
    (16) logical -> logical . logcompare logical
    (24) logcompare -> . ANDLOG
    (25) logcompare -> . ORLOG
    (26) logcompare -> . NOTLOG
    (27) logcompare -> . AND
    (28) logcompare -> . OR
    (29) logcompare -> . NOT

  ! shift/reduce conflict for ANDLOG resolved as shift
  ! shift/reduce conflict for ORLOG resolved as shift
  ! shift/reduce conflict for NOTLOG resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    THEN            reduce using rule 16 (logical -> logical logcompare logical .)
    NUMBER          reduce using rule 16 (logical -> logical logcompare logical .)
    FLOAT           reduce using rule 16 (logical -> logical logcompare logical .)
    STRING          reduce using rule 16 (logical -> logical logcompare logical .)
    LOCAL           reduce using rule 16 (logical -> logical logcompare logical .)
    GLOBAL          reduce using rule 16 (logical -> logical logcompare logical .)
    CONSTANTS       reduce using rule 16 (logical -> logical logcompare logical .)
    INSTANCEVAR     reduce using rule 16 (logical -> logical logcompare logical .)
    CLASSVAR        reduce using rule 16 (logical -> logical logcompare logical .)
    ELSE            reduce using rule 16 (logical -> logical logcompare logical .)
    ELSIF           reduce using rule 16 (logical -> logical logcompare logical .)
    IF              reduce using rule 16 (logical -> logical logcompare logical .)
    WHILE           reduce using rule 16 (logical -> logical logcompare logical .)
    BEGIN           reduce using rule 16 (logical -> logical logcompare logical .)
    FOR             reduce using rule 16 (logical -> logical logcompare logical .)
    $end            reduce using rule 16 (logical -> logical logcompare logical .)
    END             reduce using rule 16 (logical -> logical logcompare logical .)
    NEWLINE         reduce using rule 16 (logical -> logical logcompare logical .)
    DO              reduce using rule 16 (logical -> logical logcompare logical .)
    DOBLEPOINT      reduce using rule 16 (logical -> logical logcompare logical .)
    ANDLOG          shift and go to state 76
    ORLOG           shift and go to state 73
    NOTLOG          shift and go to state 70
    AND             shift and go to state 78
    OR              shift and go to state 75
    NOT             shift and go to state 72

  ! ANDLOG          [ reduce using rule 16 (logical -> logical logcompare logical .) ]
  ! ORLOG           [ reduce using rule 16 (logical -> logical logcompare logical .) ]
  ! NOTLOG          [ reduce using rule 16 (logical -> logical logcompare logical .) ]
  ! AND             [ reduce using rule 16 (logical -> logical logcompare logical .) ]
  ! OR              [ reduce using rule 16 (logical -> logical logcompare logical .) ]
  ! NOT             [ reduce using rule 16 (logical -> logical logcompare logical .) ]

    logcompare                     shift and go to state 69

state 107

    (71) if -> IF logical THEN expr . END

    END             shift and go to state 135


state 108

    (41) asig -> ASS .

    NUMBER          reduce using rule 41 (asig -> ASS .)
    FLOAT           reduce using rule 41 (asig -> ASS .)


state 109

    (14) logical -> variable comparison term .

    THEN            reduce using rule 14 (logical -> variable comparison term .)
    ANDLOG          reduce using rule 14 (logical -> variable comparison term .)
    ORLOG           reduce using rule 14 (logical -> variable comparison term .)
    NOTLOG          reduce using rule 14 (logical -> variable comparison term .)
    AND             reduce using rule 14 (logical -> variable comparison term .)
    OR              reduce using rule 14 (logical -> variable comparison term .)
    NOT             reduce using rule 14 (logical -> variable comparison term .)
    NUMBER          reduce using rule 14 (logical -> variable comparison term .)
    FLOAT           reduce using rule 14 (logical -> variable comparison term .)
    STRING          reduce using rule 14 (logical -> variable comparison term .)
    LOCAL           reduce using rule 14 (logical -> variable comparison term .)
    GLOBAL          reduce using rule 14 (logical -> variable comparison term .)
    CONSTANTS       reduce using rule 14 (logical -> variable comparison term .)
    INSTANCEVAR     reduce using rule 14 (logical -> variable comparison term .)
    CLASSVAR        reduce using rule 14 (logical -> variable comparison term .)
    ELSE            reduce using rule 14 (logical -> variable comparison term .)
    ELSIF           reduce using rule 14 (logical -> variable comparison term .)
    IF              reduce using rule 14 (logical -> variable comparison term .)
    WHILE           reduce using rule 14 (logical -> variable comparison term .)
    BEGIN           reduce using rule 14 (logical -> variable comparison term .)
    FOR             reduce using rule 14 (logical -> variable comparison term .)
    $end            reduce using rule 14 (logical -> variable comparison term .)
    END             reduce using rule 14 (logical -> variable comparison term .)
    NEWLINE         reduce using rule 14 (logical -> variable comparison term .)
    DO              reduce using rule 14 (logical -> variable comparison term .)
    DOBLEPOINT      reduce using rule 14 (logical -> variable comparison term .)


state 110

    (15) logical -> variable comparison boolean .

    THEN            reduce using rule 15 (logical -> variable comparison boolean .)
    ANDLOG          reduce using rule 15 (logical -> variable comparison boolean .)
    ORLOG           reduce using rule 15 (logical -> variable comparison boolean .)
    NOTLOG          reduce using rule 15 (logical -> variable comparison boolean .)
    AND             reduce using rule 15 (logical -> variable comparison boolean .)
    OR              reduce using rule 15 (logical -> variable comparison boolean .)
    NOT             reduce using rule 15 (logical -> variable comparison boolean .)
    NUMBER          reduce using rule 15 (logical -> variable comparison boolean .)
    FLOAT           reduce using rule 15 (logical -> variable comparison boolean .)
    STRING          reduce using rule 15 (logical -> variable comparison boolean .)
    LOCAL           reduce using rule 15 (logical -> variable comparison boolean .)
    GLOBAL          reduce using rule 15 (logical -> variable comparison boolean .)
    CONSTANTS       reduce using rule 15 (logical -> variable comparison boolean .)
    INSTANCEVAR     reduce using rule 15 (logical -> variable comparison boolean .)
    CLASSVAR        reduce using rule 15 (logical -> variable comparison boolean .)
    ELSE            reduce using rule 15 (logical -> variable comparison boolean .)
    ELSIF           reduce using rule 15 (logical -> variable comparison boolean .)
    IF              reduce using rule 15 (logical -> variable comparison boolean .)
    WHILE           reduce using rule 15 (logical -> variable comparison boolean .)
    BEGIN           reduce using rule 15 (logical -> variable comparison boolean .)
    FOR             reduce using rule 15 (logical -> variable comparison boolean .)
    $end            reduce using rule 15 (logical -> variable comparison boolean .)
    END             reduce using rule 15 (logical -> variable comparison boolean .)
    NEWLINE         reduce using rule 15 (logical -> variable comparison boolean .)
    DO              reduce using rule 15 (logical -> variable comparison boolean .)
    DOBLEPOINT      reduce using rule 15 (logical -> variable comparison boolean .)


state 111

    (11) while -> BEGIN code END WHILE . logical
    (12) logical -> . term comparison term
    (13) logical -> . term comparison logical
    (14) logical -> . variable comparison term
    (15) logical -> . variable comparison boolean
    (16) logical -> . logical logcompare logical
    (17) logical -> . boolean
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (101) boolean -> . TRUE
    (102) boolean -> . FALSE

    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21
    TRUE            shift and go to state 35
    FALSE           shift and go to state 31

    term                           shift and go to state 32
    logical                        shift and go to state 136
    variable                       shift and go to state 34
    boolean                        shift and go to state 36

state 112

    (8) while -> WHILE logical code END .

    IF              reduce using rule 8 (while -> WHILE logical code END .)
    WHILE           reduce using rule 8 (while -> WHILE logical code END .)
    BEGIN           reduce using rule 8 (while -> WHILE logical code END .)
    FOR             reduce using rule 8 (while -> WHILE logical code END .)
    NUMBER          reduce using rule 8 (while -> WHILE logical code END .)
    FLOAT           reduce using rule 8 (while -> WHILE logical code END .)
    STRING          reduce using rule 8 (while -> WHILE logical code END .)
    LOCAL           reduce using rule 8 (while -> WHILE logical code END .)
    GLOBAL          reduce using rule 8 (while -> WHILE logical code END .)
    CONSTANTS       reduce using rule 8 (while -> WHILE logical code END .)
    INSTANCEVAR     reduce using rule 8 (while -> WHILE logical code END .)
    CLASSVAR        reduce using rule 8 (while -> WHILE logical code END .)
    END             reduce using rule 8 (while -> WHILE logical code END .)
    ELSE            reduce using rule 8 (while -> WHILE logical code END .)
    ELSIF           reduce using rule 8 (while -> WHILE logical code END .)
    $end            reduce using rule 8 (while -> WHILE logical code END .)
    NEWLINE         reduce using rule 8 (while -> WHILE logical code END .)


state 113

    (69) salto -> NEWLINE .

    END             reduce using rule 69 (salto -> NEWLINE .)
    IF              reduce using rule 69 (salto -> NEWLINE .)
    WHILE           reduce using rule 69 (salto -> NEWLINE .)
    BEGIN           reduce using rule 69 (salto -> NEWLINE .)
    FOR             reduce using rule 69 (salto -> NEWLINE .)
    NUMBER          reduce using rule 69 (salto -> NEWLINE .)
    FLOAT           reduce using rule 69 (salto -> NEWLINE .)
    STRING          reduce using rule 69 (salto -> NEWLINE .)
    LOCAL           reduce using rule 69 (salto -> NEWLINE .)
    GLOBAL          reduce using rule 69 (salto -> NEWLINE .)
    CONSTANTS       reduce using rule 69 (salto -> NEWLINE .)
    INSTANCEVAR     reduce using rule 69 (salto -> NEWLINE .)
    CLASSVAR        reduce using rule 69 (salto -> NEWLINE .)


state 114

    (9) while -> WHILE logical DO salto . code salto END
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (70) if -> . IF logical expr END
    (71) if -> . IF logical THEN expr END
    (72) if -> . IF logical
    (73) if -> . IF logical THEN
    (74) if -> . if else
    (75) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (84) expresiones -> . term DOUBLESECUENCEPOINT term
    (65) for -> . FOR iterador IN expresiones code END
    (66) for -> . FOR iterador IN expresiones DO code END
    (67) for -> . FOR iterador IN array code END
    (68) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (58) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (97) slice -> . variable LBRACK defslice RBRACK
    (96) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 6
    WHILE           shift and go to state 8
    BEGIN           shift and go to state 7
    FOR             shift and go to state 11
    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    STRING          shift and go to state 18
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21

    expr                           shift and go to state 1
    slice                          shift and go to state 13
    if                             shift and go to state 2
    expresiones                    shift and go to state 15
    sterm                          shift and go to state 3
    for                            shift and go to state 16
    term                           shift and go to state 17
    code                           shift and go to state 137
    assign                         shift and go to state 23
    math                           shift and go to state 22
    while                          shift and go to state 9
    index                          shift and go to state 10
    variable                       shift and go to state 25

state 115

    (10) while -> WHILE logical DOBLEPOINT salto . code salto END
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (70) if -> . IF logical expr END
    (71) if -> . IF logical THEN expr END
    (72) if -> . IF logical
    (73) if -> . IF logical THEN
    (74) if -> . if else
    (75) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (84) expresiones -> . term DOUBLESECUENCEPOINT term
    (65) for -> . FOR iterador IN expresiones code END
    (66) for -> . FOR iterador IN expresiones DO code END
    (67) for -> . FOR iterador IN array code END
    (68) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (58) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (97) slice -> . variable LBRACK defslice RBRACK
    (96) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 6
    WHILE           shift and go to state 8
    BEGIN           shift and go to state 7
    FOR             shift and go to state 11
    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    STRING          shift and go to state 18
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21

    expr                           shift and go to state 1
    slice                          shift and go to state 13
    if                             shift and go to state 2
    expresiones                    shift and go to state 15
    sterm                          shift and go to state 3
    for                            shift and go to state 16
    term                           shift and go to state 17
    code                           shift and go to state 138
    assign                         shift and go to state 23
    math                           shift and go to state 22
    while                          shift and go to state 9
    index                          shift and go to state 10
    variable                       shift and go to state 25

state 116

    (65) for -> FOR iterador IN expresiones . code END
    (66) for -> FOR iterador IN expresiones . DO code END
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (70) if -> . IF logical expr END
    (71) if -> . IF logical THEN expr END
    (72) if -> . IF logical
    (73) if -> . IF logical THEN
    (74) if -> . if else
    (75) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (84) expresiones -> . term DOUBLESECUENCEPOINT term
    (65) for -> . FOR iterador IN expresiones code END
    (66) for -> . FOR iterador IN expresiones DO code END
    (67) for -> . FOR iterador IN array code END
    (68) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (58) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (97) slice -> . variable LBRACK defslice RBRACK
    (96) index -> . variable LBRACK INT RBRACK

    DO              shift and go to state 140
    IF              shift and go to state 6
    WHILE           shift and go to state 8
    BEGIN           shift and go to state 7
    FOR             shift and go to state 11
    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    STRING          shift and go to state 18
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21

    expr                           shift and go to state 1
    slice                          shift and go to state 13
    if                             shift and go to state 2
    expresiones                    shift and go to state 15
    sterm                          shift and go to state 3
    for                            shift and go to state 16
    term                           shift and go to state 17
    code                           shift and go to state 139
    assign                         shift and go to state 23
    math                           shift and go to state 22
    while                          shift and go to state 9
    index                          shift and go to state 10
    variable                       shift and go to state 25

state 117

    (67) for -> FOR iterador IN array . code END
    (68) for -> FOR iterador IN array . DO code END
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (70) if -> . IF logical expr END
    (71) if -> . IF logical THEN expr END
    (72) if -> . IF logical
    (73) if -> . IF logical THEN
    (74) if -> . if else
    (75) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (84) expresiones -> . term DOUBLESECUENCEPOINT term
    (65) for -> . FOR iterador IN expresiones code END
    (66) for -> . FOR iterador IN expresiones DO code END
    (67) for -> . FOR iterador IN array code END
    (68) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (58) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (97) slice -> . variable LBRACK defslice RBRACK
    (96) index -> . variable LBRACK INT RBRACK

    DO              shift and go to state 142
    IF              shift and go to state 6
    WHILE           shift and go to state 8
    BEGIN           shift and go to state 7
    FOR             shift and go to state 11
    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    STRING          shift and go to state 18
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21

    expr                           shift and go to state 1
    slice                          shift and go to state 13
    if                             shift and go to state 2
    expresiones                    shift and go to state 15
    sterm                          shift and go to state 3
    for                            shift and go to state 16
    term                           shift and go to state 17
    code                           shift and go to state 141
    assign                         shift and go to state 23
    math                           shift and go to state 22
    while                          shift and go to state 9
    index                          shift and go to state 10
    variable                       shift and go to state 25

state 118

    (84) expresiones -> term . DOUBLESECUENCEPOINT term

    DOUBLESECUENCEPOINT shift and go to state 41


state 119

    (83) iterador -> variable COMA variable .

    IN              reduce using rule 83 (iterador -> variable COMA variable .)


state 120

    (54) sexpr -> sterm MUL . term
    (56) term -> . NUMBER
    (57) term -> . FLOAT

    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14

    term                           shift and go to state 143

state 121

    (55) sexpr -> sterm ADD . sexpr
    (54) sexpr -> . sterm MUL term
    (55) sexpr -> . sterm ADD sexpr
    (58) sterm -> . STRING

    STRING          shift and go to state 18

    sexpr                          shift and go to state 144
    sterm                          shift and go to state 145

state 122

    (92) defarray -> FLOAT .
    (93) defarray -> FLOAT . COMA defarray

    RBRACK          reduce using rule 92 (defarray -> FLOAT .)
    COMA            shift and go to state 146


state 123

    (85) array -> LBRACK defarray . RBRACK

    RBRACK          shift and go to state 147


state 124

    (94) defarray -> boolean .
    (95) defarray -> boolean . COMA defarray

    RBRACK          reduce using rule 94 (defarray -> boolean .)
    COMA            shift and go to state 148


state 125

    (86) defarray -> NUMBER .
    (87) defarray -> NUMBER . COMA defarray

    RBRACK          reduce using rule 86 (defarray -> NUMBER .)
    COMA            shift and go to state 149


state 126

    (90) defarray -> INT .
    (91) defarray -> INT . COMA defarray

    RBRACK          reduce using rule 90 (defarray -> INT .)
    COMA            shift and go to state 150


state 127

    (88) defarray -> STRING .
    (89) defarray -> STRING . COMA defarray

    RBRACK          reduce using rule 88 (defarray -> STRING .)
    COMA            shift and go to state 151


state 128

    (96) index -> variable LBRACK INT RBRACK .

    NEWLINE         reduce using rule 96 (index -> variable LBRACK INT RBRACK .)
    IF              reduce using rule 96 (index -> variable LBRACK INT RBRACK .)
    WHILE           reduce using rule 96 (index -> variable LBRACK INT RBRACK .)
    BEGIN           reduce using rule 96 (index -> variable LBRACK INT RBRACK .)
    FOR             reduce using rule 96 (index -> variable LBRACK INT RBRACK .)
    NUMBER          reduce using rule 96 (index -> variable LBRACK INT RBRACK .)
    FLOAT           reduce using rule 96 (index -> variable LBRACK INT RBRACK .)
    STRING          reduce using rule 96 (index -> variable LBRACK INT RBRACK .)
    LOCAL           reduce using rule 96 (index -> variable LBRACK INT RBRACK .)
    GLOBAL          reduce using rule 96 (index -> variable LBRACK INT RBRACK .)
    CONSTANTS       reduce using rule 96 (index -> variable LBRACK INT RBRACK .)
    INSTANCEVAR     reduce using rule 96 (index -> variable LBRACK INT RBRACK .)
    CLASSVAR        reduce using rule 96 (index -> variable LBRACK INT RBRACK .)
    END             reduce using rule 96 (index -> variable LBRACK INT RBRACK .)
    ELSE            reduce using rule 96 (index -> variable LBRACK INT RBRACK .)
    ELSIF           reduce using rule 96 (index -> variable LBRACK INT RBRACK .)
    $end            reduce using rule 96 (index -> variable LBRACK INT RBRACK .)


state 129

    (98) defslice -> INT DOBLEPOINT . INT
    (99) defslice -> INT DOBLEPOINT .

    INT             shift and go to state 152
    RBRACK          reduce using rule 99 (defslice -> INT DOBLEPOINT .)


state 130

    (100) defslice -> DOBLEPOINT INT .

    RBRACK          reduce using rule 100 (defslice -> DOBLEPOINT INT .)


state 131

    (97) slice -> variable LBRACK defslice RBRACK .

    IF              reduce using rule 97 (slice -> variable LBRACK defslice RBRACK .)
    WHILE           reduce using rule 97 (slice -> variable LBRACK defslice RBRACK .)
    BEGIN           reduce using rule 97 (slice -> variable LBRACK defslice RBRACK .)
    FOR             reduce using rule 97 (slice -> variable LBRACK defslice RBRACK .)
    NUMBER          reduce using rule 97 (slice -> variable LBRACK defslice RBRACK .)
    FLOAT           reduce using rule 97 (slice -> variable LBRACK defslice RBRACK .)
    STRING          reduce using rule 97 (slice -> variable LBRACK defslice RBRACK .)
    LOCAL           reduce using rule 97 (slice -> variable LBRACK defslice RBRACK .)
    GLOBAL          reduce using rule 97 (slice -> variable LBRACK defslice RBRACK .)
    CONSTANTS       reduce using rule 97 (slice -> variable LBRACK defslice RBRACK .)
    INSTANCEVAR     reduce using rule 97 (slice -> variable LBRACK defslice RBRACK .)
    CLASSVAR        reduce using rule 97 (slice -> variable LBRACK defslice RBRACK .)
    END             reduce using rule 97 (slice -> variable LBRACK defslice RBRACK .)
    NEWLINE         reduce using rule 97 (slice -> variable LBRACK defslice RBRACK .)
    ELSE            reduce using rule 97 (slice -> variable LBRACK defslice RBRACK .)
    ELSIF           reduce using rule 97 (slice -> variable LBRACK defslice RBRACK .)
    $end            reduce using rule 97 (slice -> variable LBRACK defslice RBRACK .)


state 132

    (80) final -> code else .

    END             reduce using rule 80 (final -> code else .)


state 133

    (81) final -> code elsif .

    END             reduce using rule 81 (final -> code elsif .)


state 134

    (79) final -> THEN code .
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (70) if -> . IF logical expr END
    (71) if -> . IF logical THEN expr END
    (72) if -> . IF logical
    (73) if -> . IF logical THEN
    (74) if -> . if else
    (75) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (84) expresiones -> . term DOUBLESECUENCEPOINT term
    (65) for -> . FOR iterador IN expresiones code END
    (66) for -> . FOR iterador IN expresiones DO code END
    (67) for -> . FOR iterador IN array code END
    (68) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (58) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (97) slice -> . variable LBRACK defslice RBRACK
    (96) index -> . variable LBRACK INT RBRACK

    END             reduce using rule 79 (final -> THEN code .)
    IF              shift and go to state 6
    WHILE           shift and go to state 8
    BEGIN           shift and go to state 7
    FOR             shift and go to state 11
    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    STRING          shift and go to state 18
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21

    expr                           shift and go to state 1
    slice                          shift and go to state 13
    if                             shift and go to state 2
    expresiones                    shift and go to state 15
    sterm                          shift and go to state 3
    for                            shift and go to state 16
    term                           shift and go to state 17
    code                           shift and go to state 30
    assign                         shift and go to state 23
    math                           shift and go to state 22
    while                          shift and go to state 9
    index                          shift and go to state 10
    variable                       shift and go to state 25

state 135

    (71) if -> IF logical THEN expr END .

    ELSE            reduce using rule 71 (if -> IF logical THEN expr END .)
    ELSIF           reduce using rule 71 (if -> IF logical THEN expr END .)
    END             reduce using rule 71 (if -> IF logical THEN expr END .)
    IF              reduce using rule 71 (if -> IF logical THEN expr END .)
    WHILE           reduce using rule 71 (if -> IF logical THEN expr END .)
    BEGIN           reduce using rule 71 (if -> IF logical THEN expr END .)
    FOR             reduce using rule 71 (if -> IF logical THEN expr END .)
    NUMBER          reduce using rule 71 (if -> IF logical THEN expr END .)
    FLOAT           reduce using rule 71 (if -> IF logical THEN expr END .)
    STRING          reduce using rule 71 (if -> IF logical THEN expr END .)
    LOCAL           reduce using rule 71 (if -> IF logical THEN expr END .)
    GLOBAL          reduce using rule 71 (if -> IF logical THEN expr END .)
    CONSTANTS       reduce using rule 71 (if -> IF logical THEN expr END .)
    INSTANCEVAR     reduce using rule 71 (if -> IF logical THEN expr END .)
    CLASSVAR        reduce using rule 71 (if -> IF logical THEN expr END .)
    $end            reduce using rule 71 (if -> IF logical THEN expr END .)
    NEWLINE         reduce using rule 71 (if -> IF logical THEN expr END .)


state 136

    (11) while -> BEGIN code END WHILE logical .
    (16) logical -> logical . logcompare logical
    (24) logcompare -> . ANDLOG
    (25) logcompare -> . ORLOG
    (26) logcompare -> . NOTLOG
    (27) logcompare -> . AND
    (28) logcompare -> . OR
    (29) logcompare -> . NOT

    IF              reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    WHILE           reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    BEGIN           reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    FOR             reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    NUMBER          reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    FLOAT           reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    STRING          reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    LOCAL           reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    GLOBAL          reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    CONSTANTS       reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    INSTANCEVAR     reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    CLASSVAR        reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    END             reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    ELSE            reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    ELSIF           reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    $end            reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    NEWLINE         reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    ANDLOG          shift and go to state 76
    ORLOG           shift and go to state 73
    NOTLOG          shift and go to state 70
    AND             shift and go to state 78
    OR              shift and go to state 75
    NOT             shift and go to state 72

    logcompare                     shift and go to state 69

state 137

    (9) while -> WHILE logical DO salto code . salto END
    (7) code -> code . code
    (69) salto -> . NEWLINE
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (70) if -> . IF logical expr END
    (71) if -> . IF logical THEN expr END
    (72) if -> . IF logical
    (73) if -> . IF logical THEN
    (74) if -> . if else
    (75) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (84) expresiones -> . term DOUBLESECUENCEPOINT term
    (65) for -> . FOR iterador IN expresiones code END
    (66) for -> . FOR iterador IN expresiones DO code END
    (67) for -> . FOR iterador IN array code END
    (68) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (58) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (97) slice -> . variable LBRACK defslice RBRACK
    (96) index -> . variable LBRACK INT RBRACK

    NEWLINE         shift and go to state 113
    IF              shift and go to state 6
    WHILE           shift and go to state 8
    BEGIN           shift and go to state 7
    FOR             shift and go to state 11
    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    STRING          shift and go to state 18
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21

    expr                           shift and go to state 1
    slice                          shift and go to state 13
    if                             shift and go to state 2
    salto                          shift and go to state 153
    expresiones                    shift and go to state 15
    sterm                          shift and go to state 3
    for                            shift and go to state 16
    term                           shift and go to state 17
    code                           shift and go to state 30
    assign                         shift and go to state 23
    math                           shift and go to state 22
    while                          shift and go to state 9
    index                          shift and go to state 10
    variable                       shift and go to state 25

state 138

    (10) while -> WHILE logical DOBLEPOINT salto code . salto END
    (7) code -> code . code
    (69) salto -> . NEWLINE
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (70) if -> . IF logical expr END
    (71) if -> . IF logical THEN expr END
    (72) if -> . IF logical
    (73) if -> . IF logical THEN
    (74) if -> . if else
    (75) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (84) expresiones -> . term DOUBLESECUENCEPOINT term
    (65) for -> . FOR iterador IN expresiones code END
    (66) for -> . FOR iterador IN expresiones DO code END
    (67) for -> . FOR iterador IN array code END
    (68) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (58) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (97) slice -> . variable LBRACK defslice RBRACK
    (96) index -> . variable LBRACK INT RBRACK

    NEWLINE         shift and go to state 113
    IF              shift and go to state 6
    WHILE           shift and go to state 8
    BEGIN           shift and go to state 7
    FOR             shift and go to state 11
    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    STRING          shift and go to state 18
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21

    expr                           shift and go to state 1
    slice                          shift and go to state 13
    if                             shift and go to state 2
    salto                          shift and go to state 154
    expresiones                    shift and go to state 15
    sterm                          shift and go to state 3
    for                            shift and go to state 16
    term                           shift and go to state 17
    code                           shift and go to state 30
    assign                         shift and go to state 23
    math                           shift and go to state 22
    while                          shift and go to state 9
    index                          shift and go to state 10
    variable                       shift and go to state 25

state 139

    (65) for -> FOR iterador IN expresiones code . END
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (70) if -> . IF logical expr END
    (71) if -> . IF logical THEN expr END
    (72) if -> . IF logical
    (73) if -> . IF logical THEN
    (74) if -> . if else
    (75) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (84) expresiones -> . term DOUBLESECUENCEPOINT term
    (65) for -> . FOR iterador IN expresiones code END
    (66) for -> . FOR iterador IN expresiones DO code END
    (67) for -> . FOR iterador IN array code END
    (68) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (58) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (97) slice -> . variable LBRACK defslice RBRACK
    (96) index -> . variable LBRACK INT RBRACK

    END             shift and go to state 155
    IF              shift and go to state 6
    WHILE           shift and go to state 8
    BEGIN           shift and go to state 7
    FOR             shift and go to state 11
    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    STRING          shift and go to state 18
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21

    expr                           shift and go to state 1
    slice                          shift and go to state 13
    if                             shift and go to state 2
    expresiones                    shift and go to state 15
    sterm                          shift and go to state 3
    for                            shift and go to state 16
    term                           shift and go to state 17
    code                           shift and go to state 30
    assign                         shift and go to state 23
    math                           shift and go to state 22
    while                          shift and go to state 9
    index                          shift and go to state 10
    variable                       shift and go to state 25

state 140

    (66) for -> FOR iterador IN expresiones DO . code END
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (70) if -> . IF logical expr END
    (71) if -> . IF logical THEN expr END
    (72) if -> . IF logical
    (73) if -> . IF logical THEN
    (74) if -> . if else
    (75) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (84) expresiones -> . term DOUBLESECUENCEPOINT term
    (65) for -> . FOR iterador IN expresiones code END
    (66) for -> . FOR iterador IN expresiones DO code END
    (67) for -> . FOR iterador IN array code END
    (68) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (58) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (97) slice -> . variable LBRACK defslice RBRACK
    (96) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 6
    WHILE           shift and go to state 8
    BEGIN           shift and go to state 7
    FOR             shift and go to state 11
    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    STRING          shift and go to state 18
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21

    expr                           shift and go to state 1
    slice                          shift and go to state 13
    if                             shift and go to state 2
    expresiones                    shift and go to state 15
    sterm                          shift and go to state 3
    for                            shift and go to state 16
    term                           shift and go to state 17
    code                           shift and go to state 156
    assign                         shift and go to state 23
    math                           shift and go to state 22
    while                          shift and go to state 9
    index                          shift and go to state 10
    variable                       shift and go to state 25

state 141

    (67) for -> FOR iterador IN array code . END
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (70) if -> . IF logical expr END
    (71) if -> . IF logical THEN expr END
    (72) if -> . IF logical
    (73) if -> . IF logical THEN
    (74) if -> . if else
    (75) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (84) expresiones -> . term DOUBLESECUENCEPOINT term
    (65) for -> . FOR iterador IN expresiones code END
    (66) for -> . FOR iterador IN expresiones DO code END
    (67) for -> . FOR iterador IN array code END
    (68) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (58) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (97) slice -> . variable LBRACK defslice RBRACK
    (96) index -> . variable LBRACK INT RBRACK

    END             shift and go to state 157
    IF              shift and go to state 6
    WHILE           shift and go to state 8
    BEGIN           shift and go to state 7
    FOR             shift and go to state 11
    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    STRING          shift and go to state 18
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21

    expr                           shift and go to state 1
    slice                          shift and go to state 13
    if                             shift and go to state 2
    expresiones                    shift and go to state 15
    sterm                          shift and go to state 3
    for                            shift and go to state 16
    term                           shift and go to state 17
    code                           shift and go to state 30
    assign                         shift and go to state 23
    math                           shift and go to state 22
    while                          shift and go to state 9
    index                          shift and go to state 10
    variable                       shift and go to state 25

state 142

    (68) for -> FOR iterador IN array DO . code END
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (70) if -> . IF logical expr END
    (71) if -> . IF logical THEN expr END
    (72) if -> . IF logical
    (73) if -> . IF logical THEN
    (74) if -> . if else
    (75) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (84) expresiones -> . term DOUBLESECUENCEPOINT term
    (65) for -> . FOR iterador IN expresiones code END
    (66) for -> . FOR iterador IN expresiones DO code END
    (67) for -> . FOR iterador IN array code END
    (68) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (58) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (97) slice -> . variable LBRACK defslice RBRACK
    (96) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 6
    WHILE           shift and go to state 8
    BEGIN           shift and go to state 7
    FOR             shift and go to state 11
    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    STRING          shift and go to state 18
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21

    expr                           shift and go to state 1
    slice                          shift and go to state 13
    if                             shift and go to state 2
    expresiones                    shift and go to state 15
    sterm                          shift and go to state 3
    for                            shift and go to state 16
    term                           shift and go to state 17
    code                           shift and go to state 158
    assign                         shift and go to state 23
    math                           shift and go to state 22
    while                          shift and go to state 9
    index                          shift and go to state 10
    variable                       shift and go to state 25

state 143

    (54) sexpr -> sterm MUL term .

    IF              reduce using rule 54 (sexpr -> sterm MUL term .)
    WHILE           reduce using rule 54 (sexpr -> sterm MUL term .)
    BEGIN           reduce using rule 54 (sexpr -> sterm MUL term .)
    FOR             reduce using rule 54 (sexpr -> sterm MUL term .)
    NUMBER          reduce using rule 54 (sexpr -> sterm MUL term .)
    FLOAT           reduce using rule 54 (sexpr -> sterm MUL term .)
    STRING          reduce using rule 54 (sexpr -> sterm MUL term .)
    LOCAL           reduce using rule 54 (sexpr -> sterm MUL term .)
    GLOBAL          reduce using rule 54 (sexpr -> sterm MUL term .)
    CONSTANTS       reduce using rule 54 (sexpr -> sterm MUL term .)
    INSTANCEVAR     reduce using rule 54 (sexpr -> sterm MUL term .)
    CLASSVAR        reduce using rule 54 (sexpr -> sterm MUL term .)
    $end            reduce using rule 54 (sexpr -> sterm MUL term .)
    END             reduce using rule 54 (sexpr -> sterm MUL term .)
    ELSE            reduce using rule 54 (sexpr -> sterm MUL term .)
    ELSIF           reduce using rule 54 (sexpr -> sterm MUL term .)
    NEWLINE         reduce using rule 54 (sexpr -> sterm MUL term .)


state 144

    (55) sexpr -> sterm ADD sexpr .

    IF              reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    WHILE           reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    BEGIN           reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    FOR             reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    NUMBER          reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    FLOAT           reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    STRING          reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    LOCAL           reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    GLOBAL          reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    CONSTANTS       reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    INSTANCEVAR     reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    CLASSVAR        reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    $end            reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    END             reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    ELSE            reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    ELSIF           reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    NEWLINE         reduce using rule 55 (sexpr -> sterm ADD sexpr .)


state 145

    (54) sexpr -> sterm . MUL term
    (55) sexpr -> sterm . ADD sexpr

    MUL             shift and go to state 120
    ADD             shift and go to state 121


state 146

    (93) defarray -> FLOAT COMA . defarray
    (86) defarray -> . NUMBER
    (87) defarray -> . NUMBER COMA defarray
    (88) defarray -> . STRING
    (89) defarray -> . STRING COMA defarray
    (90) defarray -> . INT
    (91) defarray -> . INT COMA defarray
    (92) defarray -> . FLOAT
    (93) defarray -> . FLOAT COMA defarray
    (94) defarray -> . boolean
    (95) defarray -> . boolean COMA defarray
    (101) boolean -> . TRUE
    (102) boolean -> . FALSE

    NUMBER          shift and go to state 125
    STRING          shift and go to state 127
    INT             shift and go to state 126
    FLOAT           shift and go to state 122
    TRUE            shift and go to state 35
    FALSE           shift and go to state 31

    defarray                       shift and go to state 159
    boolean                        shift and go to state 124

state 147

    (85) array -> LBRACK defarray RBRACK .

    IF              reduce using rule 85 (array -> LBRACK defarray RBRACK .)
    WHILE           reduce using rule 85 (array -> LBRACK defarray RBRACK .)
    BEGIN           reduce using rule 85 (array -> LBRACK defarray RBRACK .)
    FOR             reduce using rule 85 (array -> LBRACK defarray RBRACK .)
    NUMBER          reduce using rule 85 (array -> LBRACK defarray RBRACK .)
    FLOAT           reduce using rule 85 (array -> LBRACK defarray RBRACK .)
    STRING          reduce using rule 85 (array -> LBRACK defarray RBRACK .)
    LOCAL           reduce using rule 85 (array -> LBRACK defarray RBRACK .)
    GLOBAL          reduce using rule 85 (array -> LBRACK defarray RBRACK .)
    CONSTANTS       reduce using rule 85 (array -> LBRACK defarray RBRACK .)
    INSTANCEVAR     reduce using rule 85 (array -> LBRACK defarray RBRACK .)
    CLASSVAR        reduce using rule 85 (array -> LBRACK defarray RBRACK .)
    $end            reduce using rule 85 (array -> LBRACK defarray RBRACK .)
    END             reduce using rule 85 (array -> LBRACK defarray RBRACK .)
    ELSE            reduce using rule 85 (array -> LBRACK defarray RBRACK .)
    ELSIF           reduce using rule 85 (array -> LBRACK defarray RBRACK .)
    NEWLINE         reduce using rule 85 (array -> LBRACK defarray RBRACK .)
    DO              reduce using rule 85 (array -> LBRACK defarray RBRACK .)


state 148

    (95) defarray -> boolean COMA . defarray
    (86) defarray -> . NUMBER
    (87) defarray -> . NUMBER COMA defarray
    (88) defarray -> . STRING
    (89) defarray -> . STRING COMA defarray
    (90) defarray -> . INT
    (91) defarray -> . INT COMA defarray
    (92) defarray -> . FLOAT
    (93) defarray -> . FLOAT COMA defarray
    (94) defarray -> . boolean
    (95) defarray -> . boolean COMA defarray
    (101) boolean -> . TRUE
    (102) boolean -> . FALSE

    NUMBER          shift and go to state 125
    STRING          shift and go to state 127
    INT             shift and go to state 126
    FLOAT           shift and go to state 122
    TRUE            shift and go to state 35
    FALSE           shift and go to state 31

    defarray                       shift and go to state 160
    boolean                        shift and go to state 124

state 149

    (87) defarray -> NUMBER COMA . defarray
    (86) defarray -> . NUMBER
    (87) defarray -> . NUMBER COMA defarray
    (88) defarray -> . STRING
    (89) defarray -> . STRING COMA defarray
    (90) defarray -> . INT
    (91) defarray -> . INT COMA defarray
    (92) defarray -> . FLOAT
    (93) defarray -> . FLOAT COMA defarray
    (94) defarray -> . boolean
    (95) defarray -> . boolean COMA defarray
    (101) boolean -> . TRUE
    (102) boolean -> . FALSE

    NUMBER          shift and go to state 125
    STRING          shift and go to state 127
    INT             shift and go to state 126
    FLOAT           shift and go to state 122
    TRUE            shift and go to state 35
    FALSE           shift and go to state 31

    defarray                       shift and go to state 161
    boolean                        shift and go to state 124

state 150

    (91) defarray -> INT COMA . defarray
    (86) defarray -> . NUMBER
    (87) defarray -> . NUMBER COMA defarray
    (88) defarray -> . STRING
    (89) defarray -> . STRING COMA defarray
    (90) defarray -> . INT
    (91) defarray -> . INT COMA defarray
    (92) defarray -> . FLOAT
    (93) defarray -> . FLOAT COMA defarray
    (94) defarray -> . boolean
    (95) defarray -> . boolean COMA defarray
    (101) boolean -> . TRUE
    (102) boolean -> . FALSE

    NUMBER          shift and go to state 125
    STRING          shift and go to state 127
    INT             shift and go to state 126
    FLOAT           shift and go to state 122
    TRUE            shift and go to state 35
    FALSE           shift and go to state 31

    defarray                       shift and go to state 162
    boolean                        shift and go to state 124

state 151

    (89) defarray -> STRING COMA . defarray
    (86) defarray -> . NUMBER
    (87) defarray -> . NUMBER COMA defarray
    (88) defarray -> . STRING
    (89) defarray -> . STRING COMA defarray
    (90) defarray -> . INT
    (91) defarray -> . INT COMA defarray
    (92) defarray -> . FLOAT
    (93) defarray -> . FLOAT COMA defarray
    (94) defarray -> . boolean
    (95) defarray -> . boolean COMA defarray
    (101) boolean -> . TRUE
    (102) boolean -> . FALSE

    NUMBER          shift and go to state 125
    STRING          shift and go to state 127
    INT             shift and go to state 126
    FLOAT           shift and go to state 122
    TRUE            shift and go to state 35
    FALSE           shift and go to state 31

    defarray                       shift and go to state 163
    boolean                        shift and go to state 124

state 152

    (98) defslice -> INT DOBLEPOINT INT .

    RBRACK          reduce using rule 98 (defslice -> INT DOBLEPOINT INT .)


state 153

    (9) while -> WHILE logical DO salto code salto . END

    END             shift and go to state 164


state 154

    (10) while -> WHILE logical DOBLEPOINT salto code salto . END

    END             shift and go to state 165


state 155

    (65) for -> FOR iterador IN expresiones code END .

    IF              reduce using rule 65 (for -> FOR iterador IN expresiones code END .)
    WHILE           reduce using rule 65 (for -> FOR iterador IN expresiones code END .)
    BEGIN           reduce using rule 65 (for -> FOR iterador IN expresiones code END .)
    FOR             reduce using rule 65 (for -> FOR iterador IN expresiones code END .)
    NUMBER          reduce using rule 65 (for -> FOR iterador IN expresiones code END .)
    FLOAT           reduce using rule 65 (for -> FOR iterador IN expresiones code END .)
    STRING          reduce using rule 65 (for -> FOR iterador IN expresiones code END .)
    LOCAL           reduce using rule 65 (for -> FOR iterador IN expresiones code END .)
    GLOBAL          reduce using rule 65 (for -> FOR iterador IN expresiones code END .)
    CONSTANTS       reduce using rule 65 (for -> FOR iterador IN expresiones code END .)
    INSTANCEVAR     reduce using rule 65 (for -> FOR iterador IN expresiones code END .)
    CLASSVAR        reduce using rule 65 (for -> FOR iterador IN expresiones code END .)
    $end            reduce using rule 65 (for -> FOR iterador IN expresiones code END .)
    END             reduce using rule 65 (for -> FOR iterador IN expresiones code END .)
    NEWLINE         reduce using rule 65 (for -> FOR iterador IN expresiones code END .)
    ELSE            reduce using rule 65 (for -> FOR iterador IN expresiones code END .)
    ELSIF           reduce using rule 65 (for -> FOR iterador IN expresiones code END .)


state 156

    (66) for -> FOR iterador IN expresiones DO code . END
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (70) if -> . IF logical expr END
    (71) if -> . IF logical THEN expr END
    (72) if -> . IF logical
    (73) if -> . IF logical THEN
    (74) if -> . if else
    (75) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (84) expresiones -> . term DOUBLESECUENCEPOINT term
    (65) for -> . FOR iterador IN expresiones code END
    (66) for -> . FOR iterador IN expresiones DO code END
    (67) for -> . FOR iterador IN array code END
    (68) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (58) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (97) slice -> . variable LBRACK defslice RBRACK
    (96) index -> . variable LBRACK INT RBRACK

    END             shift and go to state 166
    IF              shift and go to state 6
    WHILE           shift and go to state 8
    BEGIN           shift and go to state 7
    FOR             shift and go to state 11
    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    STRING          shift and go to state 18
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21

    expr                           shift and go to state 1
    slice                          shift and go to state 13
    if                             shift and go to state 2
    expresiones                    shift and go to state 15
    sterm                          shift and go to state 3
    for                            shift and go to state 16
    term                           shift and go to state 17
    code                           shift and go to state 30
    assign                         shift and go to state 23
    math                           shift and go to state 22
    while                          shift and go to state 9
    index                          shift and go to state 10
    variable                       shift and go to state 25

state 157

    (67) for -> FOR iterador IN array code END .

    IF              reduce using rule 67 (for -> FOR iterador IN array code END .)
    WHILE           reduce using rule 67 (for -> FOR iterador IN array code END .)
    BEGIN           reduce using rule 67 (for -> FOR iterador IN array code END .)
    FOR             reduce using rule 67 (for -> FOR iterador IN array code END .)
    NUMBER          reduce using rule 67 (for -> FOR iterador IN array code END .)
    FLOAT           reduce using rule 67 (for -> FOR iterador IN array code END .)
    STRING          reduce using rule 67 (for -> FOR iterador IN array code END .)
    LOCAL           reduce using rule 67 (for -> FOR iterador IN array code END .)
    GLOBAL          reduce using rule 67 (for -> FOR iterador IN array code END .)
    CONSTANTS       reduce using rule 67 (for -> FOR iterador IN array code END .)
    INSTANCEVAR     reduce using rule 67 (for -> FOR iterador IN array code END .)
    CLASSVAR        reduce using rule 67 (for -> FOR iterador IN array code END .)
    $end            reduce using rule 67 (for -> FOR iterador IN array code END .)
    END             reduce using rule 67 (for -> FOR iterador IN array code END .)
    NEWLINE         reduce using rule 67 (for -> FOR iterador IN array code END .)
    ELSE            reduce using rule 67 (for -> FOR iterador IN array code END .)
    ELSIF           reduce using rule 67 (for -> FOR iterador IN array code END .)


state 158

    (68) for -> FOR iterador IN array DO code . END
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (70) if -> . IF logical expr END
    (71) if -> . IF logical THEN expr END
    (72) if -> . IF logical
    (73) if -> . IF logical THEN
    (74) if -> . if else
    (75) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (84) expresiones -> . term DOUBLESECUENCEPOINT term
    (65) for -> . FOR iterador IN expresiones code END
    (66) for -> . FOR iterador IN expresiones DO code END
    (67) for -> . FOR iterador IN array code END
    (68) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) term -> . FLOAT
    (58) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (97) slice -> . variable LBRACK defslice RBRACK
    (96) index -> . variable LBRACK INT RBRACK

    END             shift and go to state 167
    IF              shift and go to state 6
    WHILE           shift and go to state 8
    BEGIN           shift and go to state 7
    FOR             shift and go to state 11
    NUMBER          shift and go to state 5
    FLOAT           shift and go to state 14
    STRING          shift and go to state 18
    LOCAL           shift and go to state 12
    GLOBAL          shift and go to state 24
    CONSTANTS       shift and go to state 19
    INSTANCEVAR     shift and go to state 20
    CLASSVAR        shift and go to state 21

    expr                           shift and go to state 1
    slice                          shift and go to state 13
    if                             shift and go to state 2
    expresiones                    shift and go to state 15
    sterm                          shift and go to state 3
    for                            shift and go to state 16
    term                           shift and go to state 17
    code                           shift and go to state 30
    assign                         shift and go to state 23
    math                           shift and go to state 22
    while                          shift and go to state 9
    index                          shift and go to state 10
    variable                       shift and go to state 25

state 159

    (93) defarray -> FLOAT COMA defarray .

    RBRACK          reduce using rule 93 (defarray -> FLOAT COMA defarray .)


state 160

    (95) defarray -> boolean COMA defarray .

    RBRACK          reduce using rule 95 (defarray -> boolean COMA defarray .)


state 161

    (87) defarray -> NUMBER COMA defarray .

    RBRACK          reduce using rule 87 (defarray -> NUMBER COMA defarray .)


state 162

    (91) defarray -> INT COMA defarray .

    RBRACK          reduce using rule 91 (defarray -> INT COMA defarray .)


state 163

    (89) defarray -> STRING COMA defarray .

    RBRACK          reduce using rule 89 (defarray -> STRING COMA defarray .)


state 164

    (9) while -> WHILE logical DO salto code salto END .

    IF              reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    WHILE           reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    BEGIN           reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    FOR             reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    NUMBER          reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    FLOAT           reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    STRING          reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    LOCAL           reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    GLOBAL          reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    CONSTANTS       reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    INSTANCEVAR     reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    CLASSVAR        reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    END             reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    ELSE            reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    ELSIF           reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    $end            reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    NEWLINE         reduce using rule 9 (while -> WHILE logical DO salto code salto END .)


state 165

    (10) while -> WHILE logical DOBLEPOINT salto code salto END .

    IF              reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    WHILE           reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    BEGIN           reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    FOR             reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    NUMBER          reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    FLOAT           reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    STRING          reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    LOCAL           reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    GLOBAL          reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    CONSTANTS       reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    INSTANCEVAR     reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    CLASSVAR        reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    END             reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    ELSE            reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    ELSIF           reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    $end            reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    NEWLINE         reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)


state 166

    (66) for -> FOR iterador IN expresiones DO code END .

    IF              reduce using rule 66 (for -> FOR iterador IN expresiones DO code END .)
    WHILE           reduce using rule 66 (for -> FOR iterador IN expresiones DO code END .)
    BEGIN           reduce using rule 66 (for -> FOR iterador IN expresiones DO code END .)
    FOR             reduce using rule 66 (for -> FOR iterador IN expresiones DO code END .)
    NUMBER          reduce using rule 66 (for -> FOR iterador IN expresiones DO code END .)
    FLOAT           reduce using rule 66 (for -> FOR iterador IN expresiones DO code END .)
    STRING          reduce using rule 66 (for -> FOR iterador IN expresiones DO code END .)
    LOCAL           reduce using rule 66 (for -> FOR iterador IN expresiones DO code END .)
    GLOBAL          reduce using rule 66 (for -> FOR iterador IN expresiones DO code END .)
    CONSTANTS       reduce using rule 66 (for -> FOR iterador IN expresiones DO code END .)
    INSTANCEVAR     reduce using rule 66 (for -> FOR iterador IN expresiones DO code END .)
    CLASSVAR        reduce using rule 66 (for -> FOR iterador IN expresiones DO code END .)
    $end            reduce using rule 66 (for -> FOR iterador IN expresiones DO code END .)
    END             reduce using rule 66 (for -> FOR iterador IN expresiones DO code END .)
    NEWLINE         reduce using rule 66 (for -> FOR iterador IN expresiones DO code END .)
    ELSE            reduce using rule 66 (for -> FOR iterador IN expresiones DO code END .)
    ELSIF           reduce using rule 66 (for -> FOR iterador IN expresiones DO code END .)


state 167

    (68) for -> FOR iterador IN array DO code END .

    IF              reduce using rule 68 (for -> FOR iterador IN array DO code END .)
    WHILE           reduce using rule 68 (for -> FOR iterador IN array DO code END .)
    BEGIN           reduce using rule 68 (for -> FOR iterador IN array DO code END .)
    FOR             reduce using rule 68 (for -> FOR iterador IN array DO code END .)
    NUMBER          reduce using rule 68 (for -> FOR iterador IN array DO code END .)
    FLOAT           reduce using rule 68 (for -> FOR iterador IN array DO code END .)
    STRING          reduce using rule 68 (for -> FOR iterador IN array DO code END .)
    LOCAL           reduce using rule 68 (for -> FOR iterador IN array DO code END .)
    GLOBAL          reduce using rule 68 (for -> FOR iterador IN array DO code END .)
    CONSTANTS       reduce using rule 68 (for -> FOR iterador IN array DO code END .)
    INSTANCEVAR     reduce using rule 68 (for -> FOR iterador IN array DO code END .)
    CLASSVAR        reduce using rule 68 (for -> FOR iterador IN array DO code END .)
    $end            reduce using rule 68 (for -> FOR iterador IN array DO code END .)
    END             reduce using rule 68 (for -> FOR iterador IN array DO code END .)
    NEWLINE         reduce using rule 68 (for -> FOR iterador IN array DO code END .)
    ELSE            reduce using rule 68 (for -> FOR iterador IN array DO code END .)
    ELSIF           reduce using rule 68 (for -> FOR iterador IN array DO code END .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 2 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 2 resolved as shift
WARNING: shift/reduce conflict for IF in state 30 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 30 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 30 resolved as shift
WARNING: shift/reduce conflict for FOR in state 30 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 30 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 30 resolved as shift
WARNING: shift/reduce conflict for STRING in state 30 resolved as shift
WARNING: shift/reduce conflict for LOCAL in state 30 resolved as shift
WARNING: shift/reduce conflict for GLOBAL in state 30 resolved as shift
WARNING: shift/reduce conflict for CONSTANTS in state 30 resolved as shift
WARNING: shift/reduce conflict for INSTANCEVAR in state 30 resolved as shift
WARNING: shift/reduce conflict for CLASSVAR in state 30 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 33 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 33 resolved as shift
WARNING: shift/reduce conflict for STRING in state 33 resolved as shift
WARNING: shift/reduce conflict for LOCAL in state 33 resolved as shift
WARNING: shift/reduce conflict for GLOBAL in state 33 resolved as shift
WARNING: shift/reduce conflict for CONSTANTS in state 33 resolved as shift
WARNING: shift/reduce conflict for INSTANCEVAR in state 33 resolved as shift
WARNING: shift/reduce conflict for CLASSVAR in state 33 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 49 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 49 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 74 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 74 resolved as shift
WARNING: shift/reduce conflict for STRING in state 74 resolved as shift
WARNING: shift/reduce conflict for LOCAL in state 74 resolved as shift
WARNING: shift/reduce conflict for GLOBAL in state 74 resolved as shift
WARNING: shift/reduce conflict for CONSTANTS in state 74 resolved as shift
WARNING: shift/reduce conflict for INSTANCEVAR in state 74 resolved as shift
WARNING: shift/reduce conflict for CLASSVAR in state 74 resolved as shift
WARNING: shift/reduce conflict for ANDLOG in state 104 resolved as shift
WARNING: shift/reduce conflict for ORLOG in state 104 resolved as shift
WARNING: shift/reduce conflict for NOTLOG in state 104 resolved as shift
WARNING: shift/reduce conflict for AND in state 104 resolved as shift
WARNING: shift/reduce conflict for OR in state 104 resolved as shift
WARNING: shift/reduce conflict for NOT in state 104 resolved as shift
WARNING: shift/reduce conflict for ANDLOG in state 106 resolved as shift
WARNING: shift/reduce conflict for ORLOG in state 106 resolved as shift
WARNING: shift/reduce conflict for NOTLOG in state 106 resolved as shift
WARNING: shift/reduce conflict for AND in state 106 resolved as shift
WARNING: shift/reduce conflict for OR in state 106 resolved as shift
WARNING: shift/reduce conflict for NOT in state 106 resolved as shift
