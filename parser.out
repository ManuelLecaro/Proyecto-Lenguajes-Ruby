Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ALIAS
    UNDEF
    SUPER
    SELF
    RESCUE
    FALSE
    PSEUDO
    TRUE
    LINE
    REDO
    MODULE
    FILE
    ENSURE
    WHEN
    CLASS
    UNLESS
    CASE
    UNTIL
    YIELD
    BREAK
    DEF
    NEXT
    DEFINED
    RETRY
    RETURN
    ERROR
    NIL
    BREAK
    CASE
    CLASS
    DEF
    DEFINED
    ENSURE
    ERROR
    FALSE
    FILE
    LINE
    MODULE
    NEXT
    NIL
    PSEUDO
    REDO
    RESCUE
    RETRY
    RETURN
    SELF
    SUPER
    TRUE
    UNDEF
    UNLESS
    UNTIL
    WHEN
    YIELD

Grammar

Rule 0     S' -> assign
Rule 1     assign -> variable ASS expr
Rule 2     assign -> variable ASS sexpr
Rule 3     math -> term arith term
Rule 4     math -> term arith math
Rule 5     math -> variable asig term
Rule 6     variable -> LOCAL
Rule 7     variable -> GLOBAL
Rule 8     variable -> CONSTANTS
Rule 9     variable -> INSTANCEVAR
Rule 10    variable -> CLASSVAR
Rule 11    asig -> ASS
Rule 12    asig -> ADDASS
Rule 13    asig -> SUBASS
Rule 14    asig -> MULASS
Rule 15    asig -> DIVASS
Rule 16    asig -> MODASS
Rule 17    asig -> EXPASS
Rule 18    expr -> math
Rule 19    expr -> term
Rule 20    expr -> variable
Rule 21    expr -> assign
Rule 22    sexpr -> sterm MUL term
Rule 23    sexpr -> sterm ADD sexpr
Rule 24    sexpr -> sterm
Rule 25    term -> NUMBER
Rule 26    sterm -> STRING
Rule 27    arith -> EXP
Rule 28    arith -> MUL
Rule 29    arith -> DIV
Rule 30    arith -> MOD
Rule 31    arith -> ADD
Rule 32    arith -> SUB
Rule 33    logic -> variable comparison variable
Rule 34    logic -> variable EQUAL BOOLEAN
Rule 35    logic -> variable comparison term
Rule 36    logic -> variable comparison sterm
Rule 37    logic -> logic logcompare logic
Rule 38    logic -> logic logcompare BOOLEAN
Rule 39    logic -> BOOLEAN logcompare BOOLEAN
Rule 40    logic -> BOOLEAN logcompare logic
Rule 41    logic -> term comparison variable
Rule 42    logic -> sterm comparison variable
Rule 43    comparison -> EQUAL
Rule 44    comparison -> NOTEQ
Rule 45    comparison -> GREATHER
Rule 46    comparison -> LOWER
Rule 47    comparison -> GREATHEREQ
Rule 48    comparison -> LOWEREQ
Rule 49    logcompare -> ANDLOG
Rule 50    logcompare -> ORLOG
Rule 51    logcompare -> NOTLOG
Rule 52    logcompare -> AND
Rule 53    logcompare -> OR
Rule 54    logcompare -> NOT
Rule 55    else -> ELSE expr END
Rule 56    elsif -> ELSIF logic expr
Rule 57    elsif -> ELSIF logic THEN expr
Rule 58    elsif -> ELSIF logic expr else
Rule 59    elsif -> ELSIF LOGIC expr elsif
Rule 60    if -> IF logic expr END
Rule 61    if -> IF logic THEN expr END
Rule 62    if -> IF logic
Rule 63    if -> IF logic THEN
Rule 64    if -> if else
Rule 65    if -> if elsif END
Rule 66    code -> expr
Rule 67    code -> if
Rule 68    while -> WHILE logic code END
Rule 69    while -> WHILE logic DO code END
Rule 70    while -> WHILE logic DOBLEPOINT code END
Rule 71    while -> BEGIN code END WHILE logic
Rule 72    iterador -> variable
Rule 73    iterador -> variable , variable
Rule 74    expresiones -> term DOUBLESECUENCEPOINT term
Rule 75    for -> FOR iterador IN expresiones code END
Rule 76    for -> FOR iterador IN expresiones DO code END
Rule 77    for -> FOR iterador IN array code END
Rule 78    for -> FOR iterador IN array DO code END
Rule 79    array -> LBRACK defarray RBRACK
Rule 80    defarray -> NUMBER
Rule 81    defarray -> NUMBER COMA defarray
Rule 82    defarray -> STRING
Rule 83    defarray -> STRING COMA defarray
Rule 84    defarray -> INT
Rule 85    defarray -> INT COMA defarray
Rule 86    defarray -> FLOAT
Rule 87    defarray -> FLOAT COMA defarray
Rule 88    defarray -> BOOLEAN
Rule 89    defarray -> BOOLEAN COMA defarray
Rule 90    assarray -> variable ASS array
Rule 91    assarray -> array
Rule 92    index -> variable LBRACK INT RBRACK
Rule 93    slice -> variable LBRACK defslice RBRACK
Rule 94    defslice -> INT DOBLEPOINT INT
Rule 95    defslice -> INT DOBLEPOINT
Rule 96    defslice -> DOBLEPOINT INT


Terminals, with rules where they appear

,                    : 70
ADD                  : 29 37
ADDASS               : 18
ALIAS                : 
AND                  : 48
ANDLOG               : 45
ASS                  : 1 2 17 76
BEGIN                : 68
BOOLEAN              : 6 87 88
BREAK                : 
CASE                 : 
CLASS                : 
CLASSVAR             : 16
COMA                 : 80 82 84 86 88
CONSTANTS            : 14
DEF                  : 
DEFINED              : 
DIV                  : 29
DIVASS               : 15
DO                   : 69 76 78
DOBLEPOINT           : 67 91 92 93
DOUBLESECUENCEPOINT  : 71
ELSE                 : 58
ELSIF                : 59 60 61 62
END                  : 52 53 57 58 65 66 67 68 72 73 74 75
ENSURE               : 
EQUAL                : 39
ERROR                : 
EXP                  : 33
EXPASS               : 23
FALSE                : 
FILE                 : 
<<<<<<< HEA
FLOAT                : 86 87
FOR                  : 75 76 77 78
GLOBAL               : 7
GREATHER             : 45
GREATHEREQ           : 47
IF                   : 60 61 62 63
IN                   : 75 76 77 78
INSTANCEVAR          : 15
INT                  : 83 84 89 91 91 92 93
LBRACK               : 78 89 90
LINE                 : 
LOCAL                : 12
LOWER                : 42
LOWEREQ              : 44
MOD                  : 36
MODASS               : 22
MODULE               : 
MUL                  : 28 34
MULASS               : 20
NEWLINE              : 51
NEXT                 : 
NIL                  : 
NOT                  : 50
NOTEQ                : 40
NOTLOG               : 47
NUMBER               : 31 79 80
OR                   : 49
ORLOG                : 46
PSEUDO               : 
RBRACK               : 78 89 90
REDO                 : 
RESCUE               : 
RETRY                : 
RETURN               : 
SELF                 : 
STRING               : 32 81 82
SUB                  : 38
SUBASS               : 19
SUPER                : 
THEN                 : 57 61 63
TRUE                 : 
UNDEF                : 
UNLESS               : 
UNTIL                : 
WHEN                 : 
WHILE                : 65 66 67 68
YIELD                : 
error                : 

Nonterminals, with rules where they appear

LOGIC                : 5
arith                : 3 4
array                : 74 75 76 77
asig                 : 5
assarray             : 
<<<<<<< HEAD
assign               : 21 0
code                 : 68 69 70 71 75 76 77 78
comparison           : 33 35 36 41 42
defarray             : 79 81 83 85 87 89
defslice             : 93
else                 : 58 64
elsif                : 59 65
expr                 : 1 55 56 57 58 59 60 61 66
expresiones          : 75 76
for                  : 
if                   : 64 65 67
index                : 
iterador             : 75 76 77 78
logcompare           : 37 38 39 40
logic                : 37 37 38 40 56 57 58 60 61 62 63 68 69 70 71
math                 : 4 18
sexpr                : 2 23
slice                : 
sterm                : 11 28 29 30
term                 : 3 3 4 5 10 25 28 71 71
variable             : 1 2 5 9 26 69 70 70 76 89 90
while                : 

Parsing method: LALR

state 0

    (0) S' -> . assign
    (1) assign -> . variable ASS expr
    (2) assign -> . variable ASS sexpr
    (12) variable -> . LOCAL
    (13) variable -> . GLOBAL
    (14) variable -> . CONSTANTS
    (15) variable -> . INSTANCEVAR
    (16) variable -> . CLASSVAR

    LOCAL           shift and go to state 3
    GLOBAL          shift and go to state 4
    CONSTANTS       shift and go to state 5
    INSTANCEVAR     shift and go to state 6
    CLASSVAR        shift and go to state 7

    assign                         shift and go to state 1
    variable                       shift and go to state 2

state 1

    (0) S' -> assign .



state 2

    (1) assign -> variable . ASS expr
    (2) assign -> variable . ASS sexpr

    ASS             shift and go to state 8


state 3

    (12) variable -> LOCAL .

    ASS             reduce using rule 12 (variable -> LOCAL .)
    ADDASS          reduce using rule 12 (variable -> LOCAL .)
    SUBASS          reduce using rule 12 (variable -> LOCAL .)
    MULASS          reduce using rule 12 (variable -> LOCAL .)
    DIVASS          reduce using rule 12 (variable -> LOCAL .)
    MODASS          reduce using rule 12 (variable -> LOCAL .)
    EXPASS          reduce using rule 12 (variable -> LOCAL .)
    $end            reduce using rule 12 (variable -> LOCAL .)


state 4

    (13) variable -> GLOBAL .

    ASS             reduce using rule 13 (variable -> GLOBAL .)
    ADDASS          reduce using rule 13 (variable -> GLOBAL .)
    SUBASS          reduce using rule 13 (variable -> GLOBAL .)
    MULASS          reduce using rule 13 (variable -> GLOBAL .)
    DIVASS          reduce using rule 13 (variable -> GLOBAL .)
    MODASS          reduce using rule 13 (variable -> GLOBAL .)
    EXPASS          reduce using rule 13 (variable -> GLOBAL .)
    $end            reduce using rule 13 (variable -> GLOBAL .)


state 5

    (14) variable -> CONSTANTS .

    ASS             reduce using rule 14 (variable -> CONSTANTS .)
    ADDASS          reduce using rule 14 (variable -> CONSTANTS .)
    SUBASS          reduce using rule 14 (variable -> CONSTANTS .)
    MULASS          reduce using rule 14 (variable -> CONSTANTS .)
    DIVASS          reduce using rule 14 (variable -> CONSTANTS .)
    MODASS          reduce using rule 14 (variable -> CONSTANTS .)
    EXPASS          reduce using rule 14 (variable -> CONSTANTS .)
    $end            reduce using rule 14 (variable -> CONSTANTS .)


state 6

    (15) variable -> INSTANCEVAR .

    ASS             reduce using rule 15 (variable -> INSTANCEVAR .)
    ADDASS          reduce using rule 15 (variable -> INSTANCEVAR .)
    SUBASS          reduce using rule 15 (variable -> INSTANCEVAR .)
    MULASS          reduce using rule 15 (variable -> INSTANCEVAR .)
    DIVASS          reduce using rule 15 (variable -> INSTANCEVAR .)
    MODASS          reduce using rule 15 (variable -> INSTANCEVAR .)
    EXPASS          reduce using rule 15 (variable -> INSTANCEVAR .)
    $end            reduce using rule 15 (variable -> INSTANCEVAR .)


state 7

    (16) variable -> CLASSVAR .

    ASS             reduce using rule 16 (variable -> CLASSVAR .)
    ADDASS          reduce using rule 16 (variable -> CLASSVAR .)
    SUBASS          reduce using rule 16 (variable -> CLASSVAR .)
    MULASS          reduce using rule 16 (variable -> CLASSVAR .)
    DIVASS          reduce using rule 16 (variable -> CLASSVAR .)
    MODASS          reduce using rule 16 (variable -> CLASSVAR .)
    EXPASS          reduce using rule 16 (variable -> CLASSVAR .)
    $end            reduce using rule 16 (variable -> CLASSVAR .)


state 8

    (1) assign -> variable ASS . expr
    (2) assign -> variable ASS . sexpr
    (24) expr -> . math
    (25) expr -> . term
    (26) expr -> . variable
    (27) expr -> . assign
    (28) sexpr -> . sterm MUL term
    (29) sexpr -> . sterm ADD sexpr
    (30) sexpr -> . sterm
    (3) math -> . term arith term
    (4) math -> . term arith math
    (5) math -> . variable asig term
    (31) term -> . NUMBER
    (12) variable -> . LOCAL
    (13) variable -> . GLOBAL
    (14) variable -> . CONSTANTS
    (15) variable -> . INSTANCEVAR
    (16) variable -> . CLASSVAR
    (1) assign -> . variable ASS expr
    (2) assign -> . variable ASS sexpr
    (32) sterm -> . STRING

    NUMBER          shift and go to state 16
    LOCAL           shift and go to state 3
    GLOBAL          shift and go to state 4
    CONSTANTS       shift and go to state 5
    INSTANCEVAR     shift and go to state 6
    CLASSVAR        shift and go to state 7
    STRING          shift and go to state 17

    variable                       shift and go to state 9
    expr                           shift and go to state 10
    sexpr                          shift and go to state 11
    math                           shift and go to state 12
    term                           shift and go to state 13
    assign                         shift and go to state 14
    sterm                          shift and go to state 15

state 9

    (26) expr -> variable .
    (5) math -> variable . asig term
    (1) assign -> variable . ASS expr
    (2) assign -> variable . ASS sexpr
    (17) asig -> . ASS
    (18) asig -> . ADDASS
    (19) asig -> . SUBASS
    (20) asig -> . MULASS
    (21) asig -> . DIVASS
    (22) asig -> . MODASS
    (23) asig -> . EXPASS

    $end            reduce using rule 26 (expr -> variable .)
    ASS             shift and go to state 19
    ADDASS          shift and go to state 20
    SUBASS          shift and go to state 21
    MULASS          shift and go to state 22
    DIVASS          shift and go to state 23
    MODASS          shift and go to state 24
    EXPASS          shift and go to state 25

    asig                           shift and go to state 18

state 10

    (1) assign -> variable ASS expr .

    $end            reduce using rule 1 (assign -> variable ASS expr .)


state 11

    (2) assign -> variable ASS sexpr .

    $end            reduce using rule 2 (assign -> variable ASS sexpr .)


state 12

    (24) expr -> math .

    $end            reduce using rule 24 (expr -> math .)


state 13

    (25) expr -> term .
    (3) math -> term . arith term
    (4) math -> term . arith math
    (33) arith -> . EXP
    (34) arith -> . MUL
    (35) arith -> . DIV
    (36) arith -> . MOD
    (37) arith -> . ADD
    (38) arith -> . SUB

    $end            reduce using rule 25 (expr -> term .)
    EXP             shift and go to state 27
    MUL             shift and go to state 28
    DIV             shift and go to state 29
    MOD             shift and go to state 30
    ADD             shift and go to state 31
    SUB             shift and go to state 32

    arith                          shift and go to state 26

state 14

    (27) expr -> assign .

    $end            reduce using rule 27 (expr -> assign .)


state 15

    (28) sexpr -> sterm . MUL term
    (29) sexpr -> sterm . ADD sexpr
    (30) sexpr -> sterm .

    MUL             shift and go to state 33
    ADD             shift and go to state 34
    $end            reduce using rule 30 (sexpr -> sterm .)


state 16

    (31) term -> NUMBER .

    EXP             reduce using rule 31 (term -> NUMBER .)
    MUL             reduce using rule 31 (term -> NUMBER .)
    DIV             reduce using rule 31 (term -> NUMBER .)
    MOD             reduce using rule 31 (term -> NUMBER .)
    ADD             reduce using rule 31 (term -> NUMBER .)
    SUB             reduce using rule 31 (term -> NUMBER .)
    $end            reduce using rule 31 (term -> NUMBER .)


state 17

    (32) sterm -> STRING .

    MUL             reduce using rule 32 (sterm -> STRING .)
    ADD             reduce using rule 32 (sterm -> STRING .)
    $end            reduce using rule 32 (sterm -> STRING .)


state 18

    (5) math -> variable asig . term
    (31) term -> . NUMBER

    NUMBER          shift and go to state 16

    term                           shift and go to state 35

state 19

    (1) assign -> variable ASS . expr
    (2) assign -> variable ASS . sexpr
    (17) asig -> ASS .
    (24) expr -> . math
    (25) expr -> . term
    (26) expr -> . variable
    (27) expr -> . assign
    (28) sexpr -> . sterm MUL term
    (29) sexpr -> . sterm ADD sexpr
    (30) sexpr -> . sterm
    (3) math -> . term arith term
    (4) math -> . term arith math
    (5) math -> . variable asig term
    (31) term -> . NUMBER
    (12) variable -> . LOCAL
    (13) variable -> . GLOBAL
    (14) variable -> . CONSTANTS
    (15) variable -> . INSTANCEVAR
    (16) variable -> . CLASSVAR
    (1) assign -> . variable ASS expr
    (2) assign -> . variable ASS sexpr
    (32) sterm -> . STRING

  ! shift/reduce conflict for NUMBER resolved as shift
    NUMBER          shift and go to state 16
    LOCAL           shift and go to state 3
    GLOBAL          shift and go to state 4
    CONSTANTS       shift and go to state 5
    INSTANCEVAR     shift and go to state 6
    CLASSVAR        shift and go to state 7
    STRING          shift and go to state 17

  ! NUMBER          [ reduce using rule 17 (asig -> ASS .) ]

    variable                       shift and go to state 9
    expr                           shift and go to state 10
    sexpr                          shift and go to state 11
    math                           shift and go to state 12
    term                           shift and go to state 13
    assign                         shift and go to state 14
    sterm                          shift and go to state 15

state 20

    (18) asig -> ADDASS .

    NUMBER          reduce using rule 18 (asig -> ADDASS .)


state 21

    (19) asig -> SUBASS .

    NUMBER          reduce using rule 19 (asig -> SUBASS .)


state 22

    (20) asig -> MULASS .

    NUMBER          reduce using rule 20 (asig -> MULASS .)


state 23

    (21) asig -> DIVASS .

    NUMBER          reduce using rule 21 (asig -> DIVASS .)


state 24

    (22) asig -> MODASS .

    NUMBER          reduce using rule 22 (asig -> MODASS .)


state 25

    (23) asig -> EXPASS .

    NUMBER          reduce using rule 23 (asig -> EXPASS .)


state 26

    (3) math -> term arith . term
    (4) math -> term arith . math
    (31) term -> . NUMBER
    (3) math -> . term arith term
    (4) math -> . term arith math
    (5) math -> . variable asig term
    (12) variable -> . LOCAL
    (13) variable -> . GLOBAL
    (14) variable -> . CONSTANTS
    (15) variable -> . INSTANCEVAR
    (16) variable -> . CLASSVAR

    NUMBER          shift and go to state 16
    LOCAL           shift and go to state 3
    GLOBAL          shift and go to state 4
    CONSTANTS       shift and go to state 5
    INSTANCEVAR     shift and go to state 6
    CLASSVAR        shift and go to state 7

    term                           shift and go to state 36
    math                           shift and go to state 37
    variable                       shift and go to state 38

state 27

    (33) arith -> EXP .

    NUMBER          reduce using rule 33 (arith -> EXP .)
    LOCAL           reduce using rule 33 (arith -> EXP .)
    GLOBAL          reduce using rule 33 (arith -> EXP .)
    CONSTANTS       reduce using rule 33 (arith -> EXP .)
    INSTANCEVAR     reduce using rule 33 (arith -> EXP .)
    CLASSVAR        reduce using rule 33 (arith -> EXP .)


state 28

    (34) arith -> MUL .

    NUMBER          reduce using rule 34 (arith -> MUL .)
    LOCAL           reduce using rule 34 (arith -> MUL .)
    GLOBAL          reduce using rule 34 (arith -> MUL .)
    CONSTANTS       reduce using rule 34 (arith -> MUL .)
    INSTANCEVAR     reduce using rule 34 (arith -> MUL .)
    CLASSVAR        reduce using rule 34 (arith -> MUL .)


state 29

    (35) arith -> DIV .

    NUMBER          reduce using rule 35 (arith -> DIV .)
    LOCAL           reduce using rule 35 (arith -> DIV .)
    GLOBAL          reduce using rule 35 (arith -> DIV .)
    CONSTANTS       reduce using rule 35 (arith -> DIV .)
    INSTANCEVAR     reduce using rule 35 (arith -> DIV .)
    CLASSVAR        reduce using rule 35 (arith -> DIV .)


state 30

    (36) arith -> MOD .

    NUMBER          reduce using rule 36 (arith -> MOD .)
    LOCAL           reduce using rule 36 (arith -> MOD .)
    GLOBAL          reduce using rule 36 (arith -> MOD .)
    CONSTANTS       reduce using rule 36 (arith -> MOD .)
    INSTANCEVAR     reduce using rule 36 (arith -> MOD .)
    CLASSVAR        reduce using rule 36 (arith -> MOD .)


state 31

    (37) arith -> ADD .

    NUMBER          reduce using rule 37 (arith -> ADD .)
    LOCAL           reduce using rule 37 (arith -> ADD .)
    GLOBAL          reduce using rule 37 (arith -> ADD .)
    CONSTANTS       reduce using rule 37 (arith -> ADD .)
    INSTANCEVAR     reduce using rule 37 (arith -> ADD .)
    CLASSVAR        reduce using rule 37 (arith -> ADD .)


state 32

    (38) arith -> SUB .

    NUMBER          reduce using rule 38 (arith -> SUB .)
    LOCAL           reduce using rule 38 (arith -> SUB .)
    GLOBAL          reduce using rule 38 (arith -> SUB .)
    CONSTANTS       reduce using rule 38 (arith -> SUB .)
    INSTANCEVAR     reduce using rule 38 (arith -> SUB .)
    CLASSVAR        reduce using rule 38 (arith -> SUB .)


state 33

    (28) sexpr -> sterm MUL . term
    (31) term -> . NUMBER

    NUMBER          shift and go to state 16

    term                           shift and go to state 39

state 34

    (29) sexpr -> sterm ADD . sexpr
    (28) sexpr -> . sterm MUL term
    (29) sexpr -> . sterm ADD sexpr
    (30) sexpr -> . sterm
    (32) sterm -> . STRING

    STRING          shift and go to state 17

    sterm                          shift and go to state 15
    sexpr                          shift and go to state 40

state 35

    (5) math -> variable asig term .

    $end            reduce using rule 5 (math -> variable asig term .)


state 36

    (3) math -> term arith term .
    (3) math -> term . arith term
    (4) math -> term . arith math
    (33) arith -> . EXP
    (34) arith -> . MUL
    (35) arith -> . DIV
    (36) arith -> . MOD
    (37) arith -> . ADD
    (38) arith -> . SUB

    $end            reduce using rule 3 (math -> term arith term .)
    EXP             shift and go to state 27
    MUL             shift and go to state 28
    DIV             shift and go to state 29
    MOD             shift and go to state 30
    ADD             shift and go to state 31
    SUB             shift and go to state 32

    arith                          shift and go to state 26

state 37

    (4) math -> term arith math .

    $end            reduce using rule 4 (math -> term arith math .)


state 38

    (5) math -> variable . asig term
    (17) asig -> . ASS
    (18) asig -> . ADDASS
    (19) asig -> . SUBASS
    (20) asig -> . MULASS
    (21) asig -> . DIVASS
    (22) asig -> . MODASS
    (23) asig -> . EXPASS

    ASS             shift and go to state 41
    ADDASS          shift and go to state 20
    SUBASS          shift and go to state 21
    MULASS          shift and go to state 22
    DIVASS          shift and go to state 23
    MODASS          shift and go to state 24
    EXPASS          shift and go to state 25

    asig                           shift and go to state 18

state 39

    (28) sexpr -> sterm MUL term .

    $end            reduce using rule 28 (sexpr -> sterm MUL term .)


state 40

    (29) sexpr -> sterm ADD sexpr .

    $end            reduce using rule 29 (sexpr -> sterm ADD sexpr .)


state 41

    (17) asig -> ASS .

    NUMBER          reduce using rule 17 (asig -> ASS .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for NUMBER in state 19 resolved as shift
