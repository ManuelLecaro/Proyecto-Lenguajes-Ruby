Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    RETURN
    MODULE
    FILE
    RESCUE
    REDO
    ALIAS
    ENSURE
    YIELD
    SELF
    RETRY
    NIL
    DEF
    UNLESS
    UNTIL
    LINE
    ERROR
    DEFINED
    SUPER
    CASE
    BREAK
    UNDEF
    WHEN
    NEXT
    CLASS
    PSEUDO

Grammar

Rule 0     S' -> code
Rule 1     code -> expr
Rule 2     code -> if
Rule 3     code -> while
Rule 4     code -> expresiones
Rule 5     code -> for
Rule 6     code -> assign
Rule 7     code -> code code
Rule 8     while -> WHILE logical code END
Rule 9     while -> WHILE logical DO salto code salto END
Rule 10    while -> WHILE logical DOBLEPOINT salto code salto END
Rule 11    while -> BEGIN code END WHILE logical
Rule 12    logical -> term comparison term
Rule 13    logical -> term comparison logical
Rule 14    logical -> variable comparison term
Rule 15    logical -> variable comparison boolean
Rule 16    logical -> logical logcompare logical
Rule 17    logical -> boolean
Rule 18    comparison -> EQUAL
Rule 19    comparison -> NOTEQ
Rule 20    comparison -> GREATHER
Rule 21    comparison -> LOWER
Rule 22    comparison -> GREATHEREQ
Rule 23    comparison -> LOWEREQ
Rule 24    logcompare -> ANDLOG
Rule 25    logcompare -> ORLOG
Rule 26    logcompare -> NOTLOG
Rule 27    logcompare -> AND
Rule 28    logcompare -> OR
Rule 29    logcompare -> NOT
Rule 30    assign -> variable ASS expr
Rule 31    assign -> variable ASS sexpr
Rule 32    assign -> variable ASS array
Rule 33    math -> term arith term
Rule 34    math -> term arith math
Rule 35    math -> variable asig term
Rule 36    variable -> LOCAL
Rule 37    variable -> GLOBAL
Rule 38    variable -> CONSTANTS
Rule 39    variable -> INSTANCEVAR
Rule 40    variable -> CLASSVAR
Rule 41    asig -> ASS
Rule 42    asig -> ADDASS
Rule 43    asig -> SUBASS
Rule 44    asig -> MULASS
Rule 45    asig -> DIVASS
Rule 46    asig -> MODASS
Rule 47    asig -> EXPASS
Rule 48    expr -> math
Rule 49    expr -> term
Rule 50    expr -> sterm
Rule 51    expr -> variable
Rule 52    expr -> slice
Rule 53    expr -> index
Rule 54    sexpr -> sterm MUL term
Rule 55    sexpr -> sterm ADD sexpr
Rule 56    term -> NUMBER
Rule 57    sterm -> STRING
Rule 58    arith -> EXP
Rule 59    arith -> MUL
Rule 60    arith -> DIV
Rule 61    arith -> MOD
Rule 62    arith -> ADD
Rule 63    arith -> SUB
Rule 64    for -> FOR iterador IN expresiones code END
Rule 65    for -> FOR iterador IN expresiones DO code END
Rule 66    for -> FOR iterador IN array code END
Rule 67    for -> FOR iterador IN array DO code END
Rule 68    salto -> NEWLINE
Rule 69    if -> IF logical expr END
Rule 70    if -> IF logical THEN expr END
Rule 71    if -> IF logical
Rule 72    if -> IF logical THEN
Rule 73    if -> if else
Rule 74    if -> if elsif END
Rule 75    else -> ELSE code END
Rule 76    elsif -> ELSIF logical final
Rule 77    final -> code
Rule 78    final -> THEN code
Rule 79    final -> code else
Rule 80    final -> code elsif
Rule 81    iterador -> variable
Rule 82    iterador -> variable COMA variable
Rule 83    expresiones -> term DOUBLESECUENCEPOINT term
Rule 84    array -> LBRACK defarray RBRACK
Rule 85    defarray -> NUMBER
Rule 86    defarray -> NUMBER COMA defarray
Rule 87    defarray -> STRING
Rule 88    defarray -> STRING COMA defarray
Rule 89    defarray -> INT
Rule 90    defarray -> INT COMA defarray
Rule 91    defarray -> FLOAT
Rule 92    defarray -> FLOAT COMA defarray
Rule 93    defarray -> boolean
Rule 94    defarray -> boolean COMA defarray
Rule 95    index -> variable LBRACK INT RBRACK
Rule 96    slice -> variable LBRACK defslice RBRACK
Rule 97    defslice -> INT DOBLEPOINT INT
Rule 98    defslice -> INT DOBLEPOINT
Rule 99    defslice -> DOBLEPOINT INT
Rule 100   boolean -> TRUE
Rule 101   boolean -> FALSE

Terminals, with rules where they appear

ADD                  : 55 62
ADDASS               : 42
ALIAS                : 
AND                  : 27
ANDLOG               : 24
ASS                  : 30 31 32 41
BEGIN                : 11
BREAK                : 
CASE                 : 
CLASS                : 
CLASSVAR             : 40
COMA                 : 82 86 88 90 92 94
CONSTANTS            : 38
DEF                  : 
DEFINED              : 
DIV                  : 60
DIVASS               : 45
DO                   : 9 65 67
DOBLEPOINT           : 10 97 98 99
DOUBLESECUENCEPOINT  : 83
ELSE                 : 75
ELSIF                : 76
END                  : 8 9 10 11 64 65 66 67 69 70 74 75
ENSURE               : 
EQUAL                : 18
ERROR                : 
EXP                  : 58
EXPASS               : 47
FALSE                : 101
FILE                 : 
FLOAT                : 91 92
FOR                  : 64 65 66 67
GLOBAL               : 37
GREATHER             : 20
GREATHEREQ           : 22
IF                   : 69 70 71 72
IN                   : 64 65 66 67
INSTANCEVAR          : 39
INT                  : 89 90 95 97 97 98 99
LBRACK               : 84 95 96
LINE                 : 
LOCAL                : 36
LOWER                : 21
LOWEREQ              : 23
MOD                  : 61
MODASS               : 46
MODULE               : 
MUL                  : 54 59
MULASS               : 44
NEWLINE              : 68
NEXT                 : 
NIL                  : 
NOT                  : 29
NOTEQ                : 19
NOTLOG               : 26
NUMBER               : 56 85 86
OR                   : 28
ORLOG                : 25
PSEUDO               : 
RBRACK               : 84 95 96
REDO                 : 
RESCUE               : 
RETRY                : 
RETURN               : 
SELF                 : 
STRING               : 57 87 88
SUB                  : 63
SUBASS               : 43
SUPER                : 
THEN                 : 70 72 78
TRUE                 : 100
UNDEF                : 
UNLESS               : 
UNTIL                : 
WHEN                 : 
WHILE                : 8 9 10 11
YIELD                : 
error                : 

Nonterminals, with rules where they appear

arith                : 33 34
array                : 32 66 67
asig                 : 35
assign               : 6
boolean              : 15 17 93 94
code                 : 7 7 8 9 10 11 64 65 66 67 75 77 78 79 80 0
comparison           : 12 13 14 15
defarray             : 84 86 88 90 92 94
defslice             : 96
else                 : 73 79
elsif                : 74 80
expr                 : 1 30 69 70
expresiones          : 4 64 65
final                : 76
for                  : 5
if                   : 2 73 74
index                : 53
iterador             : 64 65 66 67
logcompare           : 16
logical              : 8 9 10 11 13 16 16 69 70 71 72 76
math                 : 34 48
salto                : 9 9 10 10
sexpr                : 31 55
slice                : 52
sterm                : 50 54 55
term                 : 12 12 13 14 33 33 34 35 49 54 83 83
variable             : 14 15 30 31 32 35 51 81 82 82 95 96
while                : 3

Parsing method: LALR

state 0

    (0) S' -> . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 14
    WHILE           shift and go to state 24
    BEGIN           shift and go to state 20
    FOR             shift and go to state 19
    NUMBER          shift and go to state 17
    STRING          shift and go to state 22
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5

    term                           shift and go to state 15
    slice                          shift and go to state 1
    if                             shift and go to state 3
    expr                           shift and go to state 4
    for                            shift and go to state 18
    variable                       shift and go to state 6
    expresiones                    shift and go to state 8
    index                          shift and go to state 9
    while                          shift and go to state 21
    code                           shift and go to state 23
    math                           shift and go to state 11
    assign                         shift and go to state 12
    sterm                          shift and go to state 13

state 1

    (52) expr -> slice .

    IF              reduce using rule 52 (expr -> slice .)
    WHILE           reduce using rule 52 (expr -> slice .)
    BEGIN           reduce using rule 52 (expr -> slice .)
    FOR             reduce using rule 52 (expr -> slice .)
    NUMBER          reduce using rule 52 (expr -> slice .)
    STRING          reduce using rule 52 (expr -> slice .)
    LOCAL           reduce using rule 52 (expr -> slice .)
    GLOBAL          reduce using rule 52 (expr -> slice .)
    CONSTANTS       reduce using rule 52 (expr -> slice .)
    INSTANCEVAR     reduce using rule 52 (expr -> slice .)
    CLASSVAR        reduce using rule 52 (expr -> slice .)
    $end            reduce using rule 52 (expr -> slice .)
    END             reduce using rule 52 (expr -> slice .)
    ELSE            reduce using rule 52 (expr -> slice .)
    ELSIF           reduce using rule 52 (expr -> slice .)
    NEWLINE         reduce using rule 52 (expr -> slice .)


state 2

    (37) variable -> GLOBAL .

    ASS             reduce using rule 37 (variable -> GLOBAL .)
    LBRACK          reduce using rule 37 (variable -> GLOBAL .)
    ADDASS          reduce using rule 37 (variable -> GLOBAL .)
    SUBASS          reduce using rule 37 (variable -> GLOBAL .)
    MULASS          reduce using rule 37 (variable -> GLOBAL .)
    DIVASS          reduce using rule 37 (variable -> GLOBAL .)
    MODASS          reduce using rule 37 (variable -> GLOBAL .)
    EXPASS          reduce using rule 37 (variable -> GLOBAL .)
    IF              reduce using rule 37 (variable -> GLOBAL .)
    WHILE           reduce using rule 37 (variable -> GLOBAL .)
    BEGIN           reduce using rule 37 (variable -> GLOBAL .)
    FOR             reduce using rule 37 (variable -> GLOBAL .)
    NUMBER          reduce using rule 37 (variable -> GLOBAL .)
    STRING          reduce using rule 37 (variable -> GLOBAL .)
    LOCAL           reduce using rule 37 (variable -> GLOBAL .)
    GLOBAL          reduce using rule 37 (variable -> GLOBAL .)
    CONSTANTS       reduce using rule 37 (variable -> GLOBAL .)
    INSTANCEVAR     reduce using rule 37 (variable -> GLOBAL .)
    CLASSVAR        reduce using rule 37 (variable -> GLOBAL .)
    END             reduce using rule 37 (variable -> GLOBAL .)
    NEWLINE         reduce using rule 37 (variable -> GLOBAL .)
    COMA            reduce using rule 37 (variable -> GLOBAL .)
    IN              reduce using rule 37 (variable -> GLOBAL .)
    EQUAL           reduce using rule 37 (variable -> GLOBAL .)
    NOTEQ           reduce using rule 37 (variable -> GLOBAL .)
    GREATHER        reduce using rule 37 (variable -> GLOBAL .)
    LOWER           reduce using rule 37 (variable -> GLOBAL .)
    GREATHEREQ      reduce using rule 37 (variable -> GLOBAL .)
    LOWEREQ         reduce using rule 37 (variable -> GLOBAL .)
    $end            reduce using rule 37 (variable -> GLOBAL .)
    ELSE            reduce using rule 37 (variable -> GLOBAL .)
    ELSIF           reduce using rule 37 (variable -> GLOBAL .)


state 3

    (2) code -> if .
    (73) if -> if . else
    (74) if -> if . elsif END
    (75) else -> . ELSE code END
    (76) elsif -> . ELSIF logical final

  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
    IF              reduce using rule 2 (code -> if .)
    WHILE           reduce using rule 2 (code -> if .)
    BEGIN           reduce using rule 2 (code -> if .)
    FOR             reduce using rule 2 (code -> if .)
    NUMBER          reduce using rule 2 (code -> if .)
    STRING          reduce using rule 2 (code -> if .)
    LOCAL           reduce using rule 2 (code -> if .)
    GLOBAL          reduce using rule 2 (code -> if .)
    CONSTANTS       reduce using rule 2 (code -> if .)
    INSTANCEVAR     reduce using rule 2 (code -> if .)
    CLASSVAR        reduce using rule 2 (code -> if .)
    $end            reduce using rule 2 (code -> if .)
    END             reduce using rule 2 (code -> if .)
    NEWLINE         reduce using rule 2 (code -> if .)
    ELSE            shift and go to state 27
    ELSIF           shift and go to state 25

  ! ELSE            [ reduce using rule 2 (code -> if .) ]
  ! ELSIF           [ reduce using rule 2 (code -> if .) ]

    elsif                          shift and go to state 26
    else                           shift and go to state 28

state 4

    (1) code -> expr .

    IF              reduce using rule 1 (code -> expr .)
    WHILE           reduce using rule 1 (code -> expr .)
    BEGIN           reduce using rule 1 (code -> expr .)
    FOR             reduce using rule 1 (code -> expr .)
    NUMBER          reduce using rule 1 (code -> expr .)
    STRING          reduce using rule 1 (code -> expr .)
    LOCAL           reduce using rule 1 (code -> expr .)
    GLOBAL          reduce using rule 1 (code -> expr .)
    CONSTANTS       reduce using rule 1 (code -> expr .)
    INSTANCEVAR     reduce using rule 1 (code -> expr .)
    CLASSVAR        reduce using rule 1 (code -> expr .)
    $end            reduce using rule 1 (code -> expr .)
    END             reduce using rule 1 (code -> expr .)
    ELSE            reduce using rule 1 (code -> expr .)
    ELSIF           reduce using rule 1 (code -> expr .)
    NEWLINE         reduce using rule 1 (code -> expr .)


state 5

    (40) variable -> CLASSVAR .

    ASS             reduce using rule 40 (variable -> CLASSVAR .)
    LBRACK          reduce using rule 40 (variable -> CLASSVAR .)
    ADDASS          reduce using rule 40 (variable -> CLASSVAR .)
    SUBASS          reduce using rule 40 (variable -> CLASSVAR .)
    MULASS          reduce using rule 40 (variable -> CLASSVAR .)
    DIVASS          reduce using rule 40 (variable -> CLASSVAR .)
    MODASS          reduce using rule 40 (variable -> CLASSVAR .)
    EXPASS          reduce using rule 40 (variable -> CLASSVAR .)
    IF              reduce using rule 40 (variable -> CLASSVAR .)
    WHILE           reduce using rule 40 (variable -> CLASSVAR .)
    BEGIN           reduce using rule 40 (variable -> CLASSVAR .)
    FOR             reduce using rule 40 (variable -> CLASSVAR .)
    NUMBER          reduce using rule 40 (variable -> CLASSVAR .)
    STRING          reduce using rule 40 (variable -> CLASSVAR .)
    LOCAL           reduce using rule 40 (variable -> CLASSVAR .)
    GLOBAL          reduce using rule 40 (variable -> CLASSVAR .)
    CONSTANTS       reduce using rule 40 (variable -> CLASSVAR .)
    INSTANCEVAR     reduce using rule 40 (variable -> CLASSVAR .)
    CLASSVAR        reduce using rule 40 (variable -> CLASSVAR .)
    END             reduce using rule 40 (variable -> CLASSVAR .)
    NEWLINE         reduce using rule 40 (variable -> CLASSVAR .)
    COMA            reduce using rule 40 (variable -> CLASSVAR .)
    IN              reduce using rule 40 (variable -> CLASSVAR .)
    EQUAL           reduce using rule 40 (variable -> CLASSVAR .)
    NOTEQ           reduce using rule 40 (variable -> CLASSVAR .)
    GREATHER        reduce using rule 40 (variable -> CLASSVAR .)
    LOWER           reduce using rule 40 (variable -> CLASSVAR .)
    GREATHEREQ      reduce using rule 40 (variable -> CLASSVAR .)
    LOWEREQ         reduce using rule 40 (variable -> CLASSVAR .)
    $end            reduce using rule 40 (variable -> CLASSVAR .)
    ELSE            reduce using rule 40 (variable -> CLASSVAR .)
    ELSIF           reduce using rule 40 (variable -> CLASSVAR .)


state 6

    (51) expr -> variable .
    (30) assign -> variable . ASS expr
    (31) assign -> variable . ASS sexpr
    (32) assign -> variable . ASS array
    (35) math -> variable . asig term
    (96) slice -> variable . LBRACK defslice RBRACK
    (95) index -> variable . LBRACK INT RBRACK
    (41) asig -> . ASS
    (42) asig -> . ADDASS
    (43) asig -> . SUBASS
    (44) asig -> . MULASS
    (45) asig -> . DIVASS
    (46) asig -> . MODASS
    (47) asig -> . EXPASS

    IF              reduce using rule 51 (expr -> variable .)
    WHILE           reduce using rule 51 (expr -> variable .)
    BEGIN           reduce using rule 51 (expr -> variable .)
    FOR             reduce using rule 51 (expr -> variable .)
    NUMBER          reduce using rule 51 (expr -> variable .)
    STRING          reduce using rule 51 (expr -> variable .)
    LOCAL           reduce using rule 51 (expr -> variable .)
    GLOBAL          reduce using rule 51 (expr -> variable .)
    CONSTANTS       reduce using rule 51 (expr -> variable .)
    INSTANCEVAR     reduce using rule 51 (expr -> variable .)
    CLASSVAR        reduce using rule 51 (expr -> variable .)
    $end            reduce using rule 51 (expr -> variable .)
    END             reduce using rule 51 (expr -> variable .)
    ELSE            reduce using rule 51 (expr -> variable .)
    ELSIF           reduce using rule 51 (expr -> variable .)
    NEWLINE         reduce using rule 51 (expr -> variable .)
    ASS             shift and go to state 31
    LBRACK          shift and go to state 34
    ADDASS          shift and go to state 35
    SUBASS          shift and go to state 37
    MULASS          shift and go to state 36
    DIVASS          shift and go to state 29
    MODASS          shift and go to state 32
    EXPASS          shift and go to state 33

    asig                           shift and go to state 30

state 7

    (38) variable -> CONSTANTS .

    ASS             reduce using rule 38 (variable -> CONSTANTS .)
    LBRACK          reduce using rule 38 (variable -> CONSTANTS .)
    ADDASS          reduce using rule 38 (variable -> CONSTANTS .)
    SUBASS          reduce using rule 38 (variable -> CONSTANTS .)
    MULASS          reduce using rule 38 (variable -> CONSTANTS .)
    DIVASS          reduce using rule 38 (variable -> CONSTANTS .)
    MODASS          reduce using rule 38 (variable -> CONSTANTS .)
    EXPASS          reduce using rule 38 (variable -> CONSTANTS .)
    IF              reduce using rule 38 (variable -> CONSTANTS .)
    WHILE           reduce using rule 38 (variable -> CONSTANTS .)
    BEGIN           reduce using rule 38 (variable -> CONSTANTS .)
    FOR             reduce using rule 38 (variable -> CONSTANTS .)
    NUMBER          reduce using rule 38 (variable -> CONSTANTS .)
    STRING          reduce using rule 38 (variable -> CONSTANTS .)
    LOCAL           reduce using rule 38 (variable -> CONSTANTS .)
    GLOBAL          reduce using rule 38 (variable -> CONSTANTS .)
    CONSTANTS       reduce using rule 38 (variable -> CONSTANTS .)
    INSTANCEVAR     reduce using rule 38 (variable -> CONSTANTS .)
    CLASSVAR        reduce using rule 38 (variable -> CONSTANTS .)
    END             reduce using rule 38 (variable -> CONSTANTS .)
    NEWLINE         reduce using rule 38 (variable -> CONSTANTS .)
    COMA            reduce using rule 38 (variable -> CONSTANTS .)
    IN              reduce using rule 38 (variable -> CONSTANTS .)
    EQUAL           reduce using rule 38 (variable -> CONSTANTS .)
    NOTEQ           reduce using rule 38 (variable -> CONSTANTS .)
    GREATHER        reduce using rule 38 (variable -> CONSTANTS .)
    LOWER           reduce using rule 38 (variable -> CONSTANTS .)
    GREATHEREQ      reduce using rule 38 (variable -> CONSTANTS .)
    LOWEREQ         reduce using rule 38 (variable -> CONSTANTS .)
    $end            reduce using rule 38 (variable -> CONSTANTS .)
    ELSE            reduce using rule 38 (variable -> CONSTANTS .)
    ELSIF           reduce using rule 38 (variable -> CONSTANTS .)


state 8

    (4) code -> expresiones .

    IF              reduce using rule 4 (code -> expresiones .)
    WHILE           reduce using rule 4 (code -> expresiones .)
    BEGIN           reduce using rule 4 (code -> expresiones .)
    FOR             reduce using rule 4 (code -> expresiones .)
    NUMBER          reduce using rule 4 (code -> expresiones .)
    STRING          reduce using rule 4 (code -> expresiones .)
    LOCAL           reduce using rule 4 (code -> expresiones .)
    GLOBAL          reduce using rule 4 (code -> expresiones .)
    CONSTANTS       reduce using rule 4 (code -> expresiones .)
    INSTANCEVAR     reduce using rule 4 (code -> expresiones .)
    CLASSVAR        reduce using rule 4 (code -> expresiones .)
    $end            reduce using rule 4 (code -> expresiones .)
    END             reduce using rule 4 (code -> expresiones .)
    ELSE            reduce using rule 4 (code -> expresiones .)
    ELSIF           reduce using rule 4 (code -> expresiones .)
    NEWLINE         reduce using rule 4 (code -> expresiones .)


state 9

    (53) expr -> index .

    IF              reduce using rule 53 (expr -> index .)
    WHILE           reduce using rule 53 (expr -> index .)
    BEGIN           reduce using rule 53 (expr -> index .)
    FOR             reduce using rule 53 (expr -> index .)
    NUMBER          reduce using rule 53 (expr -> index .)
    STRING          reduce using rule 53 (expr -> index .)
    LOCAL           reduce using rule 53 (expr -> index .)
    GLOBAL          reduce using rule 53 (expr -> index .)
    CONSTANTS       reduce using rule 53 (expr -> index .)
    INSTANCEVAR     reduce using rule 53 (expr -> index .)
    CLASSVAR        reduce using rule 53 (expr -> index .)
    $end            reduce using rule 53 (expr -> index .)
    END             reduce using rule 53 (expr -> index .)
    ELSE            reduce using rule 53 (expr -> index .)
    ELSIF           reduce using rule 53 (expr -> index .)
    NEWLINE         reduce using rule 53 (expr -> index .)


state 10

    (39) variable -> INSTANCEVAR .

    ASS             reduce using rule 39 (variable -> INSTANCEVAR .)
    LBRACK          reduce using rule 39 (variable -> INSTANCEVAR .)
    ADDASS          reduce using rule 39 (variable -> INSTANCEVAR .)
    SUBASS          reduce using rule 39 (variable -> INSTANCEVAR .)
    MULASS          reduce using rule 39 (variable -> INSTANCEVAR .)
    DIVASS          reduce using rule 39 (variable -> INSTANCEVAR .)
    MODASS          reduce using rule 39 (variable -> INSTANCEVAR .)
    EXPASS          reduce using rule 39 (variable -> INSTANCEVAR .)
    IF              reduce using rule 39 (variable -> INSTANCEVAR .)
    WHILE           reduce using rule 39 (variable -> INSTANCEVAR .)
    BEGIN           reduce using rule 39 (variable -> INSTANCEVAR .)
    FOR             reduce using rule 39 (variable -> INSTANCEVAR .)
    NUMBER          reduce using rule 39 (variable -> INSTANCEVAR .)
    STRING          reduce using rule 39 (variable -> INSTANCEVAR .)
    LOCAL           reduce using rule 39 (variable -> INSTANCEVAR .)
    GLOBAL          reduce using rule 39 (variable -> INSTANCEVAR .)
    CONSTANTS       reduce using rule 39 (variable -> INSTANCEVAR .)
    INSTANCEVAR     reduce using rule 39 (variable -> INSTANCEVAR .)
    CLASSVAR        reduce using rule 39 (variable -> INSTANCEVAR .)
    END             reduce using rule 39 (variable -> INSTANCEVAR .)
    NEWLINE         reduce using rule 39 (variable -> INSTANCEVAR .)
    COMA            reduce using rule 39 (variable -> INSTANCEVAR .)
    IN              reduce using rule 39 (variable -> INSTANCEVAR .)
    EQUAL           reduce using rule 39 (variable -> INSTANCEVAR .)
    NOTEQ           reduce using rule 39 (variable -> INSTANCEVAR .)
    GREATHER        reduce using rule 39 (variable -> INSTANCEVAR .)
    LOWER           reduce using rule 39 (variable -> INSTANCEVAR .)
    GREATHEREQ      reduce using rule 39 (variable -> INSTANCEVAR .)
    LOWEREQ         reduce using rule 39 (variable -> INSTANCEVAR .)
    $end            reduce using rule 39 (variable -> INSTANCEVAR .)
    ELSE            reduce using rule 39 (variable -> INSTANCEVAR .)
    ELSIF           reduce using rule 39 (variable -> INSTANCEVAR .)


state 11

    (48) expr -> math .

    IF              reduce using rule 48 (expr -> math .)
    WHILE           reduce using rule 48 (expr -> math .)
    BEGIN           reduce using rule 48 (expr -> math .)
    FOR             reduce using rule 48 (expr -> math .)
    NUMBER          reduce using rule 48 (expr -> math .)
    STRING          reduce using rule 48 (expr -> math .)
    LOCAL           reduce using rule 48 (expr -> math .)
    GLOBAL          reduce using rule 48 (expr -> math .)
    CONSTANTS       reduce using rule 48 (expr -> math .)
    INSTANCEVAR     reduce using rule 48 (expr -> math .)
    CLASSVAR        reduce using rule 48 (expr -> math .)
    $end            reduce using rule 48 (expr -> math .)
    END             reduce using rule 48 (expr -> math .)
    ELSE            reduce using rule 48 (expr -> math .)
    ELSIF           reduce using rule 48 (expr -> math .)
    NEWLINE         reduce using rule 48 (expr -> math .)


state 12

    (6) code -> assign .

    IF              reduce using rule 6 (code -> assign .)
    WHILE           reduce using rule 6 (code -> assign .)
    BEGIN           reduce using rule 6 (code -> assign .)
    FOR             reduce using rule 6 (code -> assign .)
    NUMBER          reduce using rule 6 (code -> assign .)
    STRING          reduce using rule 6 (code -> assign .)
    LOCAL           reduce using rule 6 (code -> assign .)
    GLOBAL          reduce using rule 6 (code -> assign .)
    CONSTANTS       reduce using rule 6 (code -> assign .)
    INSTANCEVAR     reduce using rule 6 (code -> assign .)
    CLASSVAR        reduce using rule 6 (code -> assign .)
    $end            reduce using rule 6 (code -> assign .)
    END             reduce using rule 6 (code -> assign .)
    ELSE            reduce using rule 6 (code -> assign .)
    ELSIF           reduce using rule 6 (code -> assign .)
    NEWLINE         reduce using rule 6 (code -> assign .)


state 13

    (50) expr -> sterm .

    IF              reduce using rule 50 (expr -> sterm .)
    WHILE           reduce using rule 50 (expr -> sterm .)
    BEGIN           reduce using rule 50 (expr -> sterm .)
    FOR             reduce using rule 50 (expr -> sterm .)
    NUMBER          reduce using rule 50 (expr -> sterm .)
    STRING          reduce using rule 50 (expr -> sterm .)
    LOCAL           reduce using rule 50 (expr -> sterm .)
    GLOBAL          reduce using rule 50 (expr -> sterm .)
    CONSTANTS       reduce using rule 50 (expr -> sterm .)
    INSTANCEVAR     reduce using rule 50 (expr -> sterm .)
    CLASSVAR        reduce using rule 50 (expr -> sterm .)
    $end            reduce using rule 50 (expr -> sterm .)
    END             reduce using rule 50 (expr -> sterm .)
    ELSE            reduce using rule 50 (expr -> sterm .)
    ELSIF           reduce using rule 50 (expr -> sterm .)
    NEWLINE         reduce using rule 50 (expr -> sterm .)


state 14

    (69) if -> IF . logical expr END
    (70) if -> IF . logical THEN expr END
    (71) if -> IF . logical
    (72) if -> IF . logical THEN
    (12) logical -> . term comparison term
    (13) logical -> . term comparison logical
    (14) logical -> . variable comparison term
    (15) logical -> . variable comparison boolean
    (16) logical -> . logical logcompare logical
    (17) logical -> . boolean
    (56) term -> . NUMBER
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (100) boolean -> . TRUE
    (101) boolean -> . FALSE

    NUMBER          shift and go to state 17
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5
    TRUE            shift and go to state 41
    FALSE           shift and go to state 43

    term                           shift and go to state 38
    variable                       shift and go to state 39
    logical                        shift and go to state 40
    boolean                        shift and go to state 42

state 15

    (49) expr -> term .
    (83) expresiones -> term . DOUBLESECUENCEPOINT term
    (33) math -> term . arith term
    (34) math -> term . arith math
    (58) arith -> . EXP
    (59) arith -> . MUL
    (60) arith -> . DIV
    (61) arith -> . MOD
    (62) arith -> . ADD
    (63) arith -> . SUB

    IF              reduce using rule 49 (expr -> term .)
    WHILE           reduce using rule 49 (expr -> term .)
    BEGIN           reduce using rule 49 (expr -> term .)
    FOR             reduce using rule 49 (expr -> term .)
    NUMBER          reduce using rule 49 (expr -> term .)
    STRING          reduce using rule 49 (expr -> term .)
    LOCAL           reduce using rule 49 (expr -> term .)
    GLOBAL          reduce using rule 49 (expr -> term .)
    CONSTANTS       reduce using rule 49 (expr -> term .)
    INSTANCEVAR     reduce using rule 49 (expr -> term .)
    CLASSVAR        reduce using rule 49 (expr -> term .)
    $end            reduce using rule 49 (expr -> term .)
    END             reduce using rule 49 (expr -> term .)
    ELSE            reduce using rule 49 (expr -> term .)
    ELSIF           reduce using rule 49 (expr -> term .)
    NEWLINE         reduce using rule 49 (expr -> term .)
    DOUBLESECUENCEPOINT shift and go to state 44
    EXP             shift and go to state 47
    MUL             shift and go to state 45
    DIV             shift and go to state 51
    MOD             shift and go to state 46
    ADD             shift and go to state 49
    SUB             shift and go to state 48

    arith                          shift and go to state 50

state 16

    (36) variable -> LOCAL .

    ASS             reduce using rule 36 (variable -> LOCAL .)
    LBRACK          reduce using rule 36 (variable -> LOCAL .)
    ADDASS          reduce using rule 36 (variable -> LOCAL .)
    SUBASS          reduce using rule 36 (variable -> LOCAL .)
    MULASS          reduce using rule 36 (variable -> LOCAL .)
    DIVASS          reduce using rule 36 (variable -> LOCAL .)
    MODASS          reduce using rule 36 (variable -> LOCAL .)
    EXPASS          reduce using rule 36 (variable -> LOCAL .)
    IF              reduce using rule 36 (variable -> LOCAL .)
    WHILE           reduce using rule 36 (variable -> LOCAL .)
    BEGIN           reduce using rule 36 (variable -> LOCAL .)
    FOR             reduce using rule 36 (variable -> LOCAL .)
    NUMBER          reduce using rule 36 (variable -> LOCAL .)
    STRING          reduce using rule 36 (variable -> LOCAL .)
    LOCAL           reduce using rule 36 (variable -> LOCAL .)
    GLOBAL          reduce using rule 36 (variable -> LOCAL .)
    CONSTANTS       reduce using rule 36 (variable -> LOCAL .)
    INSTANCEVAR     reduce using rule 36 (variable -> LOCAL .)
    CLASSVAR        reduce using rule 36 (variable -> LOCAL .)
    END             reduce using rule 36 (variable -> LOCAL .)
    NEWLINE         reduce using rule 36 (variable -> LOCAL .)
    COMA            reduce using rule 36 (variable -> LOCAL .)
    IN              reduce using rule 36 (variable -> LOCAL .)
    EQUAL           reduce using rule 36 (variable -> LOCAL .)
    NOTEQ           reduce using rule 36 (variable -> LOCAL .)
    GREATHER        reduce using rule 36 (variable -> LOCAL .)
    LOWER           reduce using rule 36 (variable -> LOCAL .)
    GREATHEREQ      reduce using rule 36 (variable -> LOCAL .)
    LOWEREQ         reduce using rule 36 (variable -> LOCAL .)
    $end            reduce using rule 36 (variable -> LOCAL .)
    ELSE            reduce using rule 36 (variable -> LOCAL .)
    ELSIF           reduce using rule 36 (variable -> LOCAL .)


state 17

    (56) term -> NUMBER .

    THEN            reduce using rule 56 (term -> NUMBER .)
    ANDLOG          reduce using rule 56 (term -> NUMBER .)
    ORLOG           reduce using rule 56 (term -> NUMBER .)
    NOTLOG          reduce using rule 56 (term -> NUMBER .)
    AND             reduce using rule 56 (term -> NUMBER .)
    OR              reduce using rule 56 (term -> NUMBER .)
    NOT             reduce using rule 56 (term -> NUMBER .)
    NUMBER          reduce using rule 56 (term -> NUMBER .)
    STRING          reduce using rule 56 (term -> NUMBER .)
    LOCAL           reduce using rule 56 (term -> NUMBER .)
    GLOBAL          reduce using rule 56 (term -> NUMBER .)
    CONSTANTS       reduce using rule 56 (term -> NUMBER .)
    INSTANCEVAR     reduce using rule 56 (term -> NUMBER .)
    CLASSVAR        reduce using rule 56 (term -> NUMBER .)
    ELSE            reduce using rule 56 (term -> NUMBER .)
    ELSIF           reduce using rule 56 (term -> NUMBER .)
    IF              reduce using rule 56 (term -> NUMBER .)
    WHILE           reduce using rule 56 (term -> NUMBER .)
    BEGIN           reduce using rule 56 (term -> NUMBER .)
    FOR             reduce using rule 56 (term -> NUMBER .)
    $end            reduce using rule 56 (term -> NUMBER .)
    END             reduce using rule 56 (term -> NUMBER .)
    NEWLINE         reduce using rule 56 (term -> NUMBER .)
    DO              reduce using rule 56 (term -> NUMBER .)
    DOBLEPOINT      reduce using rule 56 (term -> NUMBER .)
    EQUAL           reduce using rule 56 (term -> NUMBER .)
    NOTEQ           reduce using rule 56 (term -> NUMBER .)
    GREATHER        reduce using rule 56 (term -> NUMBER .)
    LOWER           reduce using rule 56 (term -> NUMBER .)
    GREATHEREQ      reduce using rule 56 (term -> NUMBER .)
    LOWEREQ         reduce using rule 56 (term -> NUMBER .)
    DOUBLESECUENCEPOINT reduce using rule 56 (term -> NUMBER .)
    EXP             reduce using rule 56 (term -> NUMBER .)
    MUL             reduce using rule 56 (term -> NUMBER .)
    DIV             reduce using rule 56 (term -> NUMBER .)
    MOD             reduce using rule 56 (term -> NUMBER .)
    ADD             reduce using rule 56 (term -> NUMBER .)
    SUB             reduce using rule 56 (term -> NUMBER .)


state 18

    (5) code -> for .

    IF              reduce using rule 5 (code -> for .)
    WHILE           reduce using rule 5 (code -> for .)
    BEGIN           reduce using rule 5 (code -> for .)
    FOR             reduce using rule 5 (code -> for .)
    NUMBER          reduce using rule 5 (code -> for .)
    STRING          reduce using rule 5 (code -> for .)
    LOCAL           reduce using rule 5 (code -> for .)
    GLOBAL          reduce using rule 5 (code -> for .)
    CONSTANTS       reduce using rule 5 (code -> for .)
    INSTANCEVAR     reduce using rule 5 (code -> for .)
    CLASSVAR        reduce using rule 5 (code -> for .)
    $end            reduce using rule 5 (code -> for .)
    END             reduce using rule 5 (code -> for .)
    ELSE            reduce using rule 5 (code -> for .)
    ELSIF           reduce using rule 5 (code -> for .)
    NEWLINE         reduce using rule 5 (code -> for .)


state 19

    (64) for -> FOR . iterador IN expresiones code END
    (65) for -> FOR . iterador IN expresiones DO code END
    (66) for -> FOR . iterador IN array code END
    (67) for -> FOR . iterador IN array DO code END
    (81) iterador -> . variable
    (82) iterador -> . variable COMA variable
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR

    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5

    variable                       shift and go to state 52
    iterador                       shift and go to state 53

state 20

    (11) while -> BEGIN . code END WHILE logical
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 14
    WHILE           shift and go to state 24
    BEGIN           shift and go to state 20
    FOR             shift and go to state 19
    NUMBER          shift and go to state 17
    STRING          shift and go to state 22
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5

    term                           shift and go to state 15
    slice                          shift and go to state 1
    if                             shift and go to state 3
    expr                           shift and go to state 4
    for                            shift and go to state 18
    variable                       shift and go to state 6
    expresiones                    shift and go to state 8
    index                          shift and go to state 9
    while                          shift and go to state 21
    code                           shift and go to state 54
    math                           shift and go to state 11
    assign                         shift and go to state 12
    sterm                          shift and go to state 13

state 21

    (3) code -> while .

    IF              reduce using rule 3 (code -> while .)
    WHILE           reduce using rule 3 (code -> while .)
    BEGIN           reduce using rule 3 (code -> while .)
    FOR             reduce using rule 3 (code -> while .)
    NUMBER          reduce using rule 3 (code -> while .)
    STRING          reduce using rule 3 (code -> while .)
    LOCAL           reduce using rule 3 (code -> while .)
    GLOBAL          reduce using rule 3 (code -> while .)
    CONSTANTS       reduce using rule 3 (code -> while .)
    INSTANCEVAR     reduce using rule 3 (code -> while .)
    CLASSVAR        reduce using rule 3 (code -> while .)
    $end            reduce using rule 3 (code -> while .)
    END             reduce using rule 3 (code -> while .)
    ELSE            reduce using rule 3 (code -> while .)
    ELSIF           reduce using rule 3 (code -> while .)
    NEWLINE         reduce using rule 3 (code -> while .)


state 22

    (57) sterm -> STRING .

    END             reduce using rule 57 (sterm -> STRING .)
    IF              reduce using rule 57 (sterm -> STRING .)
    WHILE           reduce using rule 57 (sterm -> STRING .)
    BEGIN           reduce using rule 57 (sterm -> STRING .)
    FOR             reduce using rule 57 (sterm -> STRING .)
    NUMBER          reduce using rule 57 (sterm -> STRING .)
    STRING          reduce using rule 57 (sterm -> STRING .)
    LOCAL           reduce using rule 57 (sterm -> STRING .)
    GLOBAL          reduce using rule 57 (sterm -> STRING .)
    CONSTANTS       reduce using rule 57 (sterm -> STRING .)
    INSTANCEVAR     reduce using rule 57 (sterm -> STRING .)
    CLASSVAR        reduce using rule 57 (sterm -> STRING .)
    $end            reduce using rule 57 (sterm -> STRING .)
    ELSE            reduce using rule 57 (sterm -> STRING .)
    ELSIF           reduce using rule 57 (sterm -> STRING .)
    NEWLINE         reduce using rule 57 (sterm -> STRING .)
    MUL             reduce using rule 57 (sterm -> STRING .)
    ADD             reduce using rule 57 (sterm -> STRING .)


state 23

    (0) S' -> code .
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 14
    WHILE           shift and go to state 24
    BEGIN           shift and go to state 20
    FOR             shift and go to state 19
    NUMBER          shift and go to state 17
    STRING          shift and go to state 22
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5

    term                           shift and go to state 15
    slice                          shift and go to state 1
    if                             shift and go to state 3
    expr                           shift and go to state 4
    for                            shift and go to state 18
    variable                       shift and go to state 6
    expresiones                    shift and go to state 8
    index                          shift and go to state 9
    while                          shift and go to state 21
    code                           shift and go to state 55
    math                           shift and go to state 11
    assign                         shift and go to state 12
    sterm                          shift and go to state 13

state 24

    (8) while -> WHILE . logical code END
    (9) while -> WHILE . logical DO salto code salto END
    (10) while -> WHILE . logical DOBLEPOINT salto code salto END
    (12) logical -> . term comparison term
    (13) logical -> . term comparison logical
    (14) logical -> . variable comparison term
    (15) logical -> . variable comparison boolean
    (16) logical -> . logical logcompare logical
    (17) logical -> . boolean
    (56) term -> . NUMBER
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (100) boolean -> . TRUE
    (101) boolean -> . FALSE

    NUMBER          shift and go to state 17
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5
    TRUE            shift and go to state 41
    FALSE           shift and go to state 43

    term                           shift and go to state 38
    logical                        shift and go to state 56
    boolean                        shift and go to state 42
    variable                       shift and go to state 39

state 25

    (76) elsif -> ELSIF . logical final
    (12) logical -> . term comparison term
    (13) logical -> . term comparison logical
    (14) logical -> . variable comparison term
    (15) logical -> . variable comparison boolean
    (16) logical -> . logical logcompare logical
    (17) logical -> . boolean
    (56) term -> . NUMBER
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (100) boolean -> . TRUE
    (101) boolean -> . FALSE

    NUMBER          shift and go to state 17
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5
    TRUE            shift and go to state 41
    FALSE           shift and go to state 43

    term                           shift and go to state 38
    variable                       shift and go to state 39
    logical                        shift and go to state 57
    boolean                        shift and go to state 42

state 26

    (74) if -> if elsif . END

    END             shift and go to state 58


state 27

    (75) else -> ELSE . code END
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 14
    WHILE           shift and go to state 24
    BEGIN           shift and go to state 20
    FOR             shift and go to state 19
    NUMBER          shift and go to state 17
    STRING          shift and go to state 22
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5

    term                           shift and go to state 15
    slice                          shift and go to state 1
    if                             shift and go to state 3
    expr                           shift and go to state 4
    for                            shift and go to state 18
    variable                       shift and go to state 6
    expresiones                    shift and go to state 8
    index                          shift and go to state 9
    while                          shift and go to state 21
    code                           shift and go to state 59
    math                           shift and go to state 11
    assign                         shift and go to state 12
    sterm                          shift and go to state 13

state 28

    (73) if -> if else .

    ELSE            reduce using rule 73 (if -> if else .)
    ELSIF           reduce using rule 73 (if -> if else .)
    IF              reduce using rule 73 (if -> if else .)
    WHILE           reduce using rule 73 (if -> if else .)
    BEGIN           reduce using rule 73 (if -> if else .)
    FOR             reduce using rule 73 (if -> if else .)
    NUMBER          reduce using rule 73 (if -> if else .)
    STRING          reduce using rule 73 (if -> if else .)
    LOCAL           reduce using rule 73 (if -> if else .)
    GLOBAL          reduce using rule 73 (if -> if else .)
    CONSTANTS       reduce using rule 73 (if -> if else .)
    INSTANCEVAR     reduce using rule 73 (if -> if else .)
    CLASSVAR        reduce using rule 73 (if -> if else .)
    END             reduce using rule 73 (if -> if else .)
    NEWLINE         reduce using rule 73 (if -> if else .)
    $end            reduce using rule 73 (if -> if else .)


state 29

    (45) asig -> DIVASS .

    NUMBER          reduce using rule 45 (asig -> DIVASS .)


state 30

    (35) math -> variable asig . term
    (56) term -> . NUMBER

    NUMBER          shift and go to state 17

    term                           shift and go to state 60

state 31

    (30) assign -> variable ASS . expr
    (31) assign -> variable ASS . sexpr
    (32) assign -> variable ASS . array
    (41) asig -> ASS .
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (54) sexpr -> . sterm MUL term
    (55) sexpr -> . sterm ADD sexpr
    (84) array -> . LBRACK defarray RBRACK
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

  ! shift/reduce conflict for NUMBER resolved as shift
    LBRACK          shift and go to state 62
    NUMBER          shift and go to state 17
    STRING          shift and go to state 22
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5

  ! NUMBER          [ reduce using rule 41 (asig -> ASS .) ]

    term                           shift and go to state 61
    slice                          shift and go to state 1
    variable                       shift and go to state 65
    array                          shift and go to state 66
    sexpr                          shift and go to state 63
    sterm                          shift and go to state 67
    expr                           shift and go to state 64
    math                           shift and go to state 11
    index                          shift and go to state 9

state 32

    (46) asig -> MODASS .

    NUMBER          reduce using rule 46 (asig -> MODASS .)


state 33

    (47) asig -> EXPASS .

    NUMBER          reduce using rule 47 (asig -> EXPASS .)


state 34

    (96) slice -> variable LBRACK . defslice RBRACK
    (95) index -> variable LBRACK . INT RBRACK
    (97) defslice -> . INT DOBLEPOINT INT
    (98) defslice -> . INT DOBLEPOINT
    (99) defslice -> . DOBLEPOINT INT

    INT             shift and go to state 68
    DOBLEPOINT      shift and go to state 69

    defslice                       shift and go to state 70

state 35

    (42) asig -> ADDASS .

    NUMBER          reduce using rule 42 (asig -> ADDASS .)


state 36

    (44) asig -> MULASS .

    NUMBER          reduce using rule 44 (asig -> MULASS .)


state 37

    (43) asig -> SUBASS .

    NUMBER          reduce using rule 43 (asig -> SUBASS .)


state 38

    (12) logical -> term . comparison term
    (13) logical -> term . comparison logical
    (18) comparison -> . EQUAL
    (19) comparison -> . NOTEQ
    (20) comparison -> . GREATHER
    (21) comparison -> . LOWER
    (22) comparison -> . GREATHEREQ
    (23) comparison -> . LOWEREQ

    EQUAL           shift and go to state 77
    NOTEQ           shift and go to state 74
    GREATHER        shift and go to state 73
    LOWER           shift and go to state 76
    GREATHEREQ      shift and go to state 75
    LOWEREQ         shift and go to state 72

    comparison                     shift and go to state 71

state 39

    (14) logical -> variable . comparison term
    (15) logical -> variable . comparison boolean
    (18) comparison -> . EQUAL
    (19) comparison -> . NOTEQ
    (20) comparison -> . GREATHER
    (21) comparison -> . LOWER
    (22) comparison -> . GREATHEREQ
    (23) comparison -> . LOWEREQ

    EQUAL           shift and go to state 77
    NOTEQ           shift and go to state 74
    GREATHER        shift and go to state 73
    LOWER           shift and go to state 76
    GREATHEREQ      shift and go to state 75
    LOWEREQ         shift and go to state 72

    comparison                     shift and go to state 78

state 40

    (69) if -> IF logical . expr END
    (70) if -> IF logical . THEN expr END
    (71) if -> IF logical .
    (72) if -> IF logical . THEN
    (16) logical -> logical . logcompare logical
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (24) logcompare -> . ANDLOG
    (25) logcompare -> . ORLOG
    (26) logcompare -> . NOTLOG
    (27) logcompare -> . AND
    (28) logcompare -> . OR
    (29) logcompare -> . NOT
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for LOCAL resolved as shift
  ! shift/reduce conflict for GLOBAL resolved as shift
  ! shift/reduce conflict for CONSTANTS resolved as shift
  ! shift/reduce conflict for INSTANCEVAR resolved as shift
  ! shift/reduce conflict for CLASSVAR resolved as shift
    THEN            shift and go to state 82
    ELSE            reduce using rule 71 (if -> IF logical .)
    ELSIF           reduce using rule 71 (if -> IF logical .)
    IF              reduce using rule 71 (if -> IF logical .)
    WHILE           reduce using rule 71 (if -> IF logical .)
    BEGIN           reduce using rule 71 (if -> IF logical .)
    FOR             reduce using rule 71 (if -> IF logical .)
    END             reduce using rule 71 (if -> IF logical .)
    NEWLINE         reduce using rule 71 (if -> IF logical .)
    $end            reduce using rule 71 (if -> IF logical .)
    ANDLOG          shift and go to state 81
    ORLOG           shift and go to state 85
    NOTLOG          shift and go to state 87
    AND             shift and go to state 79
    OR              shift and go to state 84
    NOT             shift and go to state 86
    NUMBER          shift and go to state 17
    STRING          shift and go to state 22
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5

  ! NUMBER          [ reduce using rule 71 (if -> IF logical .) ]
  ! STRING          [ reduce using rule 71 (if -> IF logical .) ]
  ! LOCAL           [ reduce using rule 71 (if -> IF logical .) ]
  ! GLOBAL          [ reduce using rule 71 (if -> IF logical .) ]
  ! CONSTANTS       [ reduce using rule 71 (if -> IF logical .) ]
  ! INSTANCEVAR     [ reduce using rule 71 (if -> IF logical .) ]
  ! CLASSVAR        [ reduce using rule 71 (if -> IF logical .) ]

    term                           shift and go to state 61
    slice                          shift and go to state 1
    variable                       shift and go to state 65
    index                          shift and go to state 9
    math                           shift and go to state 11
    logcompare                     shift and go to state 80
    expr                           shift and go to state 83
    sterm                          shift and go to state 13

state 41

    (100) boolean -> TRUE .

    COMA            reduce using rule 100 (boolean -> TRUE .)
    RBRACK          reduce using rule 100 (boolean -> TRUE .)
    THEN            reduce using rule 100 (boolean -> TRUE .)
    ANDLOG          reduce using rule 100 (boolean -> TRUE .)
    ORLOG           reduce using rule 100 (boolean -> TRUE .)
    NOTLOG          reduce using rule 100 (boolean -> TRUE .)
    AND             reduce using rule 100 (boolean -> TRUE .)
    OR              reduce using rule 100 (boolean -> TRUE .)
    NOT             reduce using rule 100 (boolean -> TRUE .)
    NUMBER          reduce using rule 100 (boolean -> TRUE .)
    STRING          reduce using rule 100 (boolean -> TRUE .)
    LOCAL           reduce using rule 100 (boolean -> TRUE .)
    GLOBAL          reduce using rule 100 (boolean -> TRUE .)
    CONSTANTS       reduce using rule 100 (boolean -> TRUE .)
    INSTANCEVAR     reduce using rule 100 (boolean -> TRUE .)
    CLASSVAR        reduce using rule 100 (boolean -> TRUE .)
    ELSE            reduce using rule 100 (boolean -> TRUE .)
    ELSIF           reduce using rule 100 (boolean -> TRUE .)
    IF              reduce using rule 100 (boolean -> TRUE .)
    WHILE           reduce using rule 100 (boolean -> TRUE .)
    BEGIN           reduce using rule 100 (boolean -> TRUE .)
    FOR             reduce using rule 100 (boolean -> TRUE .)
    $end            reduce using rule 100 (boolean -> TRUE .)
    END             reduce using rule 100 (boolean -> TRUE .)
    NEWLINE         reduce using rule 100 (boolean -> TRUE .)
    DO              reduce using rule 100 (boolean -> TRUE .)
    DOBLEPOINT      reduce using rule 100 (boolean -> TRUE .)


state 42

    (17) logical -> boolean .

    ANDLOG          reduce using rule 17 (logical -> boolean .)
    ORLOG           reduce using rule 17 (logical -> boolean .)
    NOTLOG          reduce using rule 17 (logical -> boolean .)
    AND             reduce using rule 17 (logical -> boolean .)
    OR              reduce using rule 17 (logical -> boolean .)
    NOT             reduce using rule 17 (logical -> boolean .)
    THEN            reduce using rule 17 (logical -> boolean .)
    NUMBER          reduce using rule 17 (logical -> boolean .)
    STRING          reduce using rule 17 (logical -> boolean .)
    LOCAL           reduce using rule 17 (logical -> boolean .)
    GLOBAL          reduce using rule 17 (logical -> boolean .)
    CONSTANTS       reduce using rule 17 (logical -> boolean .)
    INSTANCEVAR     reduce using rule 17 (logical -> boolean .)
    CLASSVAR        reduce using rule 17 (logical -> boolean .)
    ELSE            reduce using rule 17 (logical -> boolean .)
    ELSIF           reduce using rule 17 (logical -> boolean .)
    IF              reduce using rule 17 (logical -> boolean .)
    WHILE           reduce using rule 17 (logical -> boolean .)
    BEGIN           reduce using rule 17 (logical -> boolean .)
    FOR             reduce using rule 17 (logical -> boolean .)
    $end            reduce using rule 17 (logical -> boolean .)
    END             reduce using rule 17 (logical -> boolean .)
    NEWLINE         reduce using rule 17 (logical -> boolean .)
    DO              reduce using rule 17 (logical -> boolean .)
    DOBLEPOINT      reduce using rule 17 (logical -> boolean .)


state 43

    (101) boolean -> FALSE .

    COMA            reduce using rule 101 (boolean -> FALSE .)
    RBRACK          reduce using rule 101 (boolean -> FALSE .)
    THEN            reduce using rule 101 (boolean -> FALSE .)
    ANDLOG          reduce using rule 101 (boolean -> FALSE .)
    ORLOG           reduce using rule 101 (boolean -> FALSE .)
    NOTLOG          reduce using rule 101 (boolean -> FALSE .)
    AND             reduce using rule 101 (boolean -> FALSE .)
    OR              reduce using rule 101 (boolean -> FALSE .)
    NOT             reduce using rule 101 (boolean -> FALSE .)
    NUMBER          reduce using rule 101 (boolean -> FALSE .)
    STRING          reduce using rule 101 (boolean -> FALSE .)
    LOCAL           reduce using rule 101 (boolean -> FALSE .)
    GLOBAL          reduce using rule 101 (boolean -> FALSE .)
    CONSTANTS       reduce using rule 101 (boolean -> FALSE .)
    INSTANCEVAR     reduce using rule 101 (boolean -> FALSE .)
    CLASSVAR        reduce using rule 101 (boolean -> FALSE .)
    ELSE            reduce using rule 101 (boolean -> FALSE .)
    ELSIF           reduce using rule 101 (boolean -> FALSE .)
    IF              reduce using rule 101 (boolean -> FALSE .)
    WHILE           reduce using rule 101 (boolean -> FALSE .)
    BEGIN           reduce using rule 101 (boolean -> FALSE .)
    FOR             reduce using rule 101 (boolean -> FALSE .)
    $end            reduce using rule 101 (boolean -> FALSE .)
    END             reduce using rule 101 (boolean -> FALSE .)
    NEWLINE         reduce using rule 101 (boolean -> FALSE .)
    DO              reduce using rule 101 (boolean -> FALSE .)
    DOBLEPOINT      reduce using rule 101 (boolean -> FALSE .)


state 44

    (83) expresiones -> term DOUBLESECUENCEPOINT . term
    (56) term -> . NUMBER

    NUMBER          shift and go to state 17

    term                           shift and go to state 88

state 45

    (59) arith -> MUL .

    NUMBER          reduce using rule 59 (arith -> MUL .)
    LOCAL           reduce using rule 59 (arith -> MUL .)
    GLOBAL          reduce using rule 59 (arith -> MUL .)
    CONSTANTS       reduce using rule 59 (arith -> MUL .)
    INSTANCEVAR     reduce using rule 59 (arith -> MUL .)
    CLASSVAR        reduce using rule 59 (arith -> MUL .)


state 46

    (61) arith -> MOD .

    NUMBER          reduce using rule 61 (arith -> MOD .)
    LOCAL           reduce using rule 61 (arith -> MOD .)
    GLOBAL          reduce using rule 61 (arith -> MOD .)
    CONSTANTS       reduce using rule 61 (arith -> MOD .)
    INSTANCEVAR     reduce using rule 61 (arith -> MOD .)
    CLASSVAR        reduce using rule 61 (arith -> MOD .)


state 47

    (58) arith -> EXP .

    NUMBER          reduce using rule 58 (arith -> EXP .)
    LOCAL           reduce using rule 58 (arith -> EXP .)
    GLOBAL          reduce using rule 58 (arith -> EXP .)
    CONSTANTS       reduce using rule 58 (arith -> EXP .)
    INSTANCEVAR     reduce using rule 58 (arith -> EXP .)
    CLASSVAR        reduce using rule 58 (arith -> EXP .)


state 48

    (63) arith -> SUB .

    NUMBER          reduce using rule 63 (arith -> SUB .)
    LOCAL           reduce using rule 63 (arith -> SUB .)
    GLOBAL          reduce using rule 63 (arith -> SUB .)
    CONSTANTS       reduce using rule 63 (arith -> SUB .)
    INSTANCEVAR     reduce using rule 63 (arith -> SUB .)
    CLASSVAR        reduce using rule 63 (arith -> SUB .)


state 49

    (62) arith -> ADD .

    NUMBER          reduce using rule 62 (arith -> ADD .)
    LOCAL           reduce using rule 62 (arith -> ADD .)
    GLOBAL          reduce using rule 62 (arith -> ADD .)
    CONSTANTS       reduce using rule 62 (arith -> ADD .)
    INSTANCEVAR     reduce using rule 62 (arith -> ADD .)
    CLASSVAR        reduce using rule 62 (arith -> ADD .)


state 50

    (33) math -> term arith . term
    (34) math -> term arith . math
    (56) term -> . NUMBER
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR

    NUMBER          shift and go to state 17
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5

    term                           shift and go to state 89
    variable                       shift and go to state 90
    math                           shift and go to state 91

state 51

    (60) arith -> DIV .

    NUMBER          reduce using rule 60 (arith -> DIV .)
    LOCAL           reduce using rule 60 (arith -> DIV .)
    GLOBAL          reduce using rule 60 (arith -> DIV .)
    CONSTANTS       reduce using rule 60 (arith -> DIV .)
    INSTANCEVAR     reduce using rule 60 (arith -> DIV .)
    CLASSVAR        reduce using rule 60 (arith -> DIV .)


state 52

    (81) iterador -> variable .
    (82) iterador -> variable . COMA variable

    IN              reduce using rule 81 (iterador -> variable .)
    COMA            shift and go to state 92


state 53

    (64) for -> FOR iterador . IN expresiones code END
    (65) for -> FOR iterador . IN expresiones DO code END
    (66) for -> FOR iterador . IN array code END
    (67) for -> FOR iterador . IN array DO code END

    IN              shift and go to state 93


state 54

    (11) while -> BEGIN code . END WHILE logical
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    END             shift and go to state 94
    IF              shift and go to state 14
    WHILE           shift and go to state 24
    BEGIN           shift and go to state 20
    FOR             shift and go to state 19
    NUMBER          shift and go to state 17
    STRING          shift and go to state 22
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5

    term                           shift and go to state 15
    slice                          shift and go to state 1
    if                             shift and go to state 3
    expr                           shift and go to state 4
    for                            shift and go to state 18
    variable                       shift and go to state 6
    expresiones                    shift and go to state 8
    index                          shift and go to state 9
    while                          shift and go to state 21
    code                           shift and go to state 55
    math                           shift and go to state 11
    assign                         shift and go to state 12
    sterm                          shift and go to state 13

state 55

    (7) code -> code code .
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for LOCAL resolved as shift
  ! shift/reduce conflict for GLOBAL resolved as shift
  ! shift/reduce conflict for CONSTANTS resolved as shift
  ! shift/reduce conflict for INSTANCEVAR resolved as shift
  ! shift/reduce conflict for CLASSVAR resolved as shift
    $end            reduce using rule 7 (code -> code code .)
    END             reduce using rule 7 (code -> code code .)
    ELSE            reduce using rule 7 (code -> code code .)
    ELSIF           reduce using rule 7 (code -> code code .)
    NEWLINE         reduce using rule 7 (code -> code code .)
    IF              shift and go to state 14
    WHILE           shift and go to state 24
    BEGIN           shift and go to state 20
    FOR             shift and go to state 19
    NUMBER          shift and go to state 17
    STRING          shift and go to state 22
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5

  ! IF              [ reduce using rule 7 (code -> code code .) ]
  ! WHILE           [ reduce using rule 7 (code -> code code .) ]
  ! BEGIN           [ reduce using rule 7 (code -> code code .) ]
  ! FOR             [ reduce using rule 7 (code -> code code .) ]
  ! NUMBER          [ reduce using rule 7 (code -> code code .) ]
  ! STRING          [ reduce using rule 7 (code -> code code .) ]
  ! LOCAL           [ reduce using rule 7 (code -> code code .) ]
  ! GLOBAL          [ reduce using rule 7 (code -> code code .) ]
  ! CONSTANTS       [ reduce using rule 7 (code -> code code .) ]
  ! INSTANCEVAR     [ reduce using rule 7 (code -> code code .) ]
  ! CLASSVAR        [ reduce using rule 7 (code -> code code .) ]

    term                           shift and go to state 15
    slice                          shift and go to state 1
    if                             shift and go to state 3
    expr                           shift and go to state 4
    for                            shift and go to state 18
    variable                       shift and go to state 6
    expresiones                    shift and go to state 8
    index                          shift and go to state 9
    while                          shift and go to state 21
    code                           shift and go to state 55
    math                           shift and go to state 11
    assign                         shift and go to state 12
    sterm                          shift and go to state 13

state 56

    (8) while -> WHILE logical . code END
    (9) while -> WHILE logical . DO salto code salto END
    (10) while -> WHILE logical . DOBLEPOINT salto code salto END
    (16) logical -> logical . logcompare logical
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (24) logcompare -> . ANDLOG
    (25) logcompare -> . ORLOG
    (26) logcompare -> . NOTLOG
    (27) logcompare -> . AND
    (28) logcompare -> . OR
    (29) logcompare -> . NOT
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    DO              shift and go to state 95
    DOBLEPOINT      shift and go to state 96
    ANDLOG          shift and go to state 81
    ORLOG           shift and go to state 85
    NOTLOG          shift and go to state 87
    AND             shift and go to state 79
    OR              shift and go to state 84
    NOT             shift and go to state 86
    IF              shift and go to state 14
    WHILE           shift and go to state 24
    BEGIN           shift and go to state 20
    FOR             shift and go to state 19
    NUMBER          shift and go to state 17
    STRING          shift and go to state 22
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5

    term                           shift and go to state 15
    slice                          shift and go to state 1
    if                             shift and go to state 3
    logcompare                     shift and go to state 80
    expr                           shift and go to state 4
    for                            shift and go to state 18
    variable                       shift and go to state 6
    expresiones                    shift and go to state 8
    index                          shift and go to state 9
    while                          shift and go to state 21
    code                           shift and go to state 97
    math                           shift and go to state 11
    assign                         shift and go to state 12
    sterm                          shift and go to state 13

state 57

    (76) elsif -> ELSIF logical . final
    (16) logical -> logical . logcompare logical
    (77) final -> . code
    (78) final -> . THEN code
    (79) final -> . code else
    (80) final -> . code elsif
    (24) logcompare -> . ANDLOG
    (25) logcompare -> . ORLOG
    (26) logcompare -> . NOTLOG
    (27) logcompare -> . AND
    (28) logcompare -> . OR
    (29) logcompare -> . NOT
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    THEN            shift and go to state 99
    ANDLOG          shift and go to state 81
    ORLOG           shift and go to state 85
    NOTLOG          shift and go to state 87
    AND             shift and go to state 79
    OR              shift and go to state 84
    NOT             shift and go to state 86
    IF              shift and go to state 14
    WHILE           shift and go to state 24
    BEGIN           shift and go to state 20
    FOR             shift and go to state 19
    NUMBER          shift and go to state 17
    STRING          shift and go to state 22
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5

    term                           shift and go to state 15
    slice                          shift and go to state 1
    logcompare                     shift and go to state 80
    final                          shift and go to state 98
    if                             shift and go to state 3
    expr                           shift and go to state 4
    for                            shift and go to state 18
    variable                       shift and go to state 6
    expresiones                    shift and go to state 8
    index                          shift and go to state 9
    while                          shift and go to state 21
    code                           shift and go to state 100
    math                           shift and go to state 11
    assign                         shift and go to state 12
    sterm                          shift and go to state 13

state 58

    (74) if -> if elsif END .

    ELSE            reduce using rule 74 (if -> if elsif END .)
    ELSIF           reduce using rule 74 (if -> if elsif END .)
    IF              reduce using rule 74 (if -> if elsif END .)
    WHILE           reduce using rule 74 (if -> if elsif END .)
    BEGIN           reduce using rule 74 (if -> if elsif END .)
    FOR             reduce using rule 74 (if -> if elsif END .)
    NUMBER          reduce using rule 74 (if -> if elsif END .)
    STRING          reduce using rule 74 (if -> if elsif END .)
    LOCAL           reduce using rule 74 (if -> if elsif END .)
    GLOBAL          reduce using rule 74 (if -> if elsif END .)
    CONSTANTS       reduce using rule 74 (if -> if elsif END .)
    INSTANCEVAR     reduce using rule 74 (if -> if elsif END .)
    CLASSVAR        reduce using rule 74 (if -> if elsif END .)
    END             reduce using rule 74 (if -> if elsif END .)
    NEWLINE         reduce using rule 74 (if -> if elsif END .)
    $end            reduce using rule 74 (if -> if elsif END .)


state 59

    (75) else -> ELSE code . END
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    END             shift and go to state 101
    IF              shift and go to state 14
    WHILE           shift and go to state 24
    BEGIN           shift and go to state 20
    FOR             shift and go to state 19
    NUMBER          shift and go to state 17
    STRING          shift and go to state 22
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5

    term                           shift and go to state 15
    slice                          shift and go to state 1
    if                             shift and go to state 3
    expr                           shift and go to state 4
    for                            shift and go to state 18
    variable                       shift and go to state 6
    expresiones                    shift and go to state 8
    index                          shift and go to state 9
    while                          shift and go to state 21
    code                           shift and go to state 55
    math                           shift and go to state 11
    assign                         shift and go to state 12
    sterm                          shift and go to state 13

state 60

    (35) math -> variable asig term .

    NEWLINE         reduce using rule 35 (math -> variable asig term .)
    IF              reduce using rule 35 (math -> variable asig term .)
    WHILE           reduce using rule 35 (math -> variable asig term .)
    BEGIN           reduce using rule 35 (math -> variable asig term .)
    FOR             reduce using rule 35 (math -> variable asig term .)
    NUMBER          reduce using rule 35 (math -> variable asig term .)
    STRING          reduce using rule 35 (math -> variable asig term .)
    LOCAL           reduce using rule 35 (math -> variable asig term .)
    GLOBAL          reduce using rule 35 (math -> variable asig term .)
    CONSTANTS       reduce using rule 35 (math -> variable asig term .)
    INSTANCEVAR     reduce using rule 35 (math -> variable asig term .)
    CLASSVAR        reduce using rule 35 (math -> variable asig term .)
    END             reduce using rule 35 (math -> variable asig term .)
    $end            reduce using rule 35 (math -> variable asig term .)
    ELSE            reduce using rule 35 (math -> variable asig term .)
    ELSIF           reduce using rule 35 (math -> variable asig term .)


state 61

    (49) expr -> term .
    (33) math -> term . arith term
    (34) math -> term . arith math
    (58) arith -> . EXP
    (59) arith -> . MUL
    (60) arith -> . DIV
    (61) arith -> . MOD
    (62) arith -> . ADD
    (63) arith -> . SUB

    END             reduce using rule 49 (expr -> term .)
    IF              reduce using rule 49 (expr -> term .)
    WHILE           reduce using rule 49 (expr -> term .)
    BEGIN           reduce using rule 49 (expr -> term .)
    FOR             reduce using rule 49 (expr -> term .)
    NUMBER          reduce using rule 49 (expr -> term .)
    STRING          reduce using rule 49 (expr -> term .)
    LOCAL           reduce using rule 49 (expr -> term .)
    GLOBAL          reduce using rule 49 (expr -> term .)
    CONSTANTS       reduce using rule 49 (expr -> term .)
    INSTANCEVAR     reduce using rule 49 (expr -> term .)
    CLASSVAR        reduce using rule 49 (expr -> term .)
    $end            reduce using rule 49 (expr -> term .)
    ELSE            reduce using rule 49 (expr -> term .)
    ELSIF           reduce using rule 49 (expr -> term .)
    NEWLINE         reduce using rule 49 (expr -> term .)
    EXP             shift and go to state 47
    MUL             shift and go to state 45
    DIV             shift and go to state 51
    MOD             shift and go to state 46
    ADD             shift and go to state 49
    SUB             shift and go to state 48

    arith                          shift and go to state 50

state 62

    (84) array -> LBRACK . defarray RBRACK
    (85) defarray -> . NUMBER
    (86) defarray -> . NUMBER COMA defarray
    (87) defarray -> . STRING
    (88) defarray -> . STRING COMA defarray
    (89) defarray -> . INT
    (90) defarray -> . INT COMA defarray
    (91) defarray -> . FLOAT
    (92) defarray -> . FLOAT COMA defarray
    (93) defarray -> . boolean
    (94) defarray -> . boolean COMA defarray
    (100) boolean -> . TRUE
    (101) boolean -> . FALSE

    NUMBER          shift and go to state 105
    STRING          shift and go to state 107
    INT             shift and go to state 102
    FLOAT           shift and go to state 106
    TRUE            shift and go to state 41
    FALSE           shift and go to state 43

    defarray                       shift and go to state 103
    boolean                        shift and go to state 104

state 63

    (31) assign -> variable ASS sexpr .

    END             reduce using rule 31 (assign -> variable ASS sexpr .)
    IF              reduce using rule 31 (assign -> variable ASS sexpr .)
    WHILE           reduce using rule 31 (assign -> variable ASS sexpr .)
    BEGIN           reduce using rule 31 (assign -> variable ASS sexpr .)
    FOR             reduce using rule 31 (assign -> variable ASS sexpr .)
    NUMBER          reduce using rule 31 (assign -> variable ASS sexpr .)
    STRING          reduce using rule 31 (assign -> variable ASS sexpr .)
    LOCAL           reduce using rule 31 (assign -> variable ASS sexpr .)
    GLOBAL          reduce using rule 31 (assign -> variable ASS sexpr .)
    CONSTANTS       reduce using rule 31 (assign -> variable ASS sexpr .)
    INSTANCEVAR     reduce using rule 31 (assign -> variable ASS sexpr .)
    CLASSVAR        reduce using rule 31 (assign -> variable ASS sexpr .)
    $end            reduce using rule 31 (assign -> variable ASS sexpr .)
    ELSE            reduce using rule 31 (assign -> variable ASS sexpr .)
    ELSIF           reduce using rule 31 (assign -> variable ASS sexpr .)
    NEWLINE         reduce using rule 31 (assign -> variable ASS sexpr .)


state 64

    (30) assign -> variable ASS expr .

    END             reduce using rule 30 (assign -> variable ASS expr .)
    IF              reduce using rule 30 (assign -> variable ASS expr .)
    WHILE           reduce using rule 30 (assign -> variable ASS expr .)
    BEGIN           reduce using rule 30 (assign -> variable ASS expr .)
    FOR             reduce using rule 30 (assign -> variable ASS expr .)
    NUMBER          reduce using rule 30 (assign -> variable ASS expr .)
    STRING          reduce using rule 30 (assign -> variable ASS expr .)
    LOCAL           reduce using rule 30 (assign -> variable ASS expr .)
    GLOBAL          reduce using rule 30 (assign -> variable ASS expr .)
    CONSTANTS       reduce using rule 30 (assign -> variable ASS expr .)
    INSTANCEVAR     reduce using rule 30 (assign -> variable ASS expr .)
    CLASSVAR        reduce using rule 30 (assign -> variable ASS expr .)
    $end            reduce using rule 30 (assign -> variable ASS expr .)
    ELSE            reduce using rule 30 (assign -> variable ASS expr .)
    ELSIF           reduce using rule 30 (assign -> variable ASS expr .)
    NEWLINE         reduce using rule 30 (assign -> variable ASS expr .)


state 65

    (51) expr -> variable .
    (35) math -> variable . asig term
    (96) slice -> variable . LBRACK defslice RBRACK
    (95) index -> variable . LBRACK INT RBRACK
    (41) asig -> . ASS
    (42) asig -> . ADDASS
    (43) asig -> . SUBASS
    (44) asig -> . MULASS
    (45) asig -> . DIVASS
    (46) asig -> . MODASS
    (47) asig -> . EXPASS

    END             reduce using rule 51 (expr -> variable .)
    IF              reduce using rule 51 (expr -> variable .)
    WHILE           reduce using rule 51 (expr -> variable .)
    BEGIN           reduce using rule 51 (expr -> variable .)
    FOR             reduce using rule 51 (expr -> variable .)
    NUMBER          reduce using rule 51 (expr -> variable .)
    STRING          reduce using rule 51 (expr -> variable .)
    LOCAL           reduce using rule 51 (expr -> variable .)
    GLOBAL          reduce using rule 51 (expr -> variable .)
    CONSTANTS       reduce using rule 51 (expr -> variable .)
    INSTANCEVAR     reduce using rule 51 (expr -> variable .)
    CLASSVAR        reduce using rule 51 (expr -> variable .)
    $end            reduce using rule 51 (expr -> variable .)
    ELSE            reduce using rule 51 (expr -> variable .)
    ELSIF           reduce using rule 51 (expr -> variable .)
    NEWLINE         reduce using rule 51 (expr -> variable .)
    LBRACK          shift and go to state 34
    ASS             shift and go to state 108
    ADDASS          shift and go to state 35
    SUBASS          shift and go to state 37
    MULASS          shift and go to state 36
    DIVASS          shift and go to state 29
    MODASS          shift and go to state 32
    EXPASS          shift and go to state 33

    asig                           shift and go to state 30

state 66

    (32) assign -> variable ASS array .

    END             reduce using rule 32 (assign -> variable ASS array .)
    IF              reduce using rule 32 (assign -> variable ASS array .)
    WHILE           reduce using rule 32 (assign -> variable ASS array .)
    BEGIN           reduce using rule 32 (assign -> variable ASS array .)
    FOR             reduce using rule 32 (assign -> variable ASS array .)
    NUMBER          reduce using rule 32 (assign -> variable ASS array .)
    STRING          reduce using rule 32 (assign -> variable ASS array .)
    LOCAL           reduce using rule 32 (assign -> variable ASS array .)
    GLOBAL          reduce using rule 32 (assign -> variable ASS array .)
    CONSTANTS       reduce using rule 32 (assign -> variable ASS array .)
    INSTANCEVAR     reduce using rule 32 (assign -> variable ASS array .)
    CLASSVAR        reduce using rule 32 (assign -> variable ASS array .)
    $end            reduce using rule 32 (assign -> variable ASS array .)
    ELSE            reduce using rule 32 (assign -> variable ASS array .)
    ELSIF           reduce using rule 32 (assign -> variable ASS array .)
    NEWLINE         reduce using rule 32 (assign -> variable ASS array .)


state 67

    (50) expr -> sterm .
    (54) sexpr -> sterm . MUL term
    (55) sexpr -> sterm . ADD sexpr

    IF              reduce using rule 50 (expr -> sterm .)
    WHILE           reduce using rule 50 (expr -> sterm .)
    BEGIN           reduce using rule 50 (expr -> sterm .)
    FOR             reduce using rule 50 (expr -> sterm .)
    NUMBER          reduce using rule 50 (expr -> sterm .)
    STRING          reduce using rule 50 (expr -> sterm .)
    LOCAL           reduce using rule 50 (expr -> sterm .)
    GLOBAL          reduce using rule 50 (expr -> sterm .)
    CONSTANTS       reduce using rule 50 (expr -> sterm .)
    INSTANCEVAR     reduce using rule 50 (expr -> sterm .)
    CLASSVAR        reduce using rule 50 (expr -> sterm .)
    $end            reduce using rule 50 (expr -> sterm .)
    END             reduce using rule 50 (expr -> sterm .)
    ELSE            reduce using rule 50 (expr -> sterm .)
    ELSIF           reduce using rule 50 (expr -> sterm .)
    NEWLINE         reduce using rule 50 (expr -> sterm .)
    MUL             shift and go to state 109
    ADD             shift and go to state 110


state 68

    (95) index -> variable LBRACK INT . RBRACK
    (97) defslice -> INT . DOBLEPOINT INT
    (98) defslice -> INT . DOBLEPOINT

    RBRACK          shift and go to state 111
    DOBLEPOINT      shift and go to state 112


state 69

    (99) defslice -> DOBLEPOINT . INT

    INT             shift and go to state 113


state 70

    (96) slice -> variable LBRACK defslice . RBRACK

    RBRACK          shift and go to state 114


state 71

    (12) logical -> term comparison . term
    (13) logical -> term comparison . logical
    (56) term -> . NUMBER
    (12) logical -> . term comparison term
    (13) logical -> . term comparison logical
    (14) logical -> . variable comparison term
    (15) logical -> . variable comparison boolean
    (16) logical -> . logical logcompare logical
    (17) logical -> . boolean
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (100) boolean -> . TRUE
    (101) boolean -> . FALSE

    NUMBER          shift and go to state 17
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5
    TRUE            shift and go to state 41
    FALSE           shift and go to state 43

    term                           shift and go to state 115
    variable                       shift and go to state 39
    logical                        shift and go to state 116
    boolean                        shift and go to state 42

state 72

    (23) comparison -> LOWEREQ .

    NUMBER          reduce using rule 23 (comparison -> LOWEREQ .)
    LOCAL           reduce using rule 23 (comparison -> LOWEREQ .)
    GLOBAL          reduce using rule 23 (comparison -> LOWEREQ .)
    CONSTANTS       reduce using rule 23 (comparison -> LOWEREQ .)
    INSTANCEVAR     reduce using rule 23 (comparison -> LOWEREQ .)
    CLASSVAR        reduce using rule 23 (comparison -> LOWEREQ .)
    TRUE            reduce using rule 23 (comparison -> LOWEREQ .)
    FALSE           reduce using rule 23 (comparison -> LOWEREQ .)


state 73

    (20) comparison -> GREATHER .

    NUMBER          reduce using rule 20 (comparison -> GREATHER .)
    LOCAL           reduce using rule 20 (comparison -> GREATHER .)
    GLOBAL          reduce using rule 20 (comparison -> GREATHER .)
    CONSTANTS       reduce using rule 20 (comparison -> GREATHER .)
    INSTANCEVAR     reduce using rule 20 (comparison -> GREATHER .)
    CLASSVAR        reduce using rule 20 (comparison -> GREATHER .)
    TRUE            reduce using rule 20 (comparison -> GREATHER .)
    FALSE           reduce using rule 20 (comparison -> GREATHER .)


state 74

    (19) comparison -> NOTEQ .

    NUMBER          reduce using rule 19 (comparison -> NOTEQ .)
    LOCAL           reduce using rule 19 (comparison -> NOTEQ .)
    GLOBAL          reduce using rule 19 (comparison -> NOTEQ .)
    CONSTANTS       reduce using rule 19 (comparison -> NOTEQ .)
    INSTANCEVAR     reduce using rule 19 (comparison -> NOTEQ .)
    CLASSVAR        reduce using rule 19 (comparison -> NOTEQ .)
    TRUE            reduce using rule 19 (comparison -> NOTEQ .)
    FALSE           reduce using rule 19 (comparison -> NOTEQ .)


state 75

    (22) comparison -> GREATHEREQ .

    NUMBER          reduce using rule 22 (comparison -> GREATHEREQ .)
    LOCAL           reduce using rule 22 (comparison -> GREATHEREQ .)
    GLOBAL          reduce using rule 22 (comparison -> GREATHEREQ .)
    CONSTANTS       reduce using rule 22 (comparison -> GREATHEREQ .)
    INSTANCEVAR     reduce using rule 22 (comparison -> GREATHEREQ .)
    CLASSVAR        reduce using rule 22 (comparison -> GREATHEREQ .)
    TRUE            reduce using rule 22 (comparison -> GREATHEREQ .)
    FALSE           reduce using rule 22 (comparison -> GREATHEREQ .)


state 76

    (21) comparison -> LOWER .

    NUMBER          reduce using rule 21 (comparison -> LOWER .)
    LOCAL           reduce using rule 21 (comparison -> LOWER .)
    GLOBAL          reduce using rule 21 (comparison -> LOWER .)
    CONSTANTS       reduce using rule 21 (comparison -> LOWER .)
    INSTANCEVAR     reduce using rule 21 (comparison -> LOWER .)
    CLASSVAR        reduce using rule 21 (comparison -> LOWER .)
    TRUE            reduce using rule 21 (comparison -> LOWER .)
    FALSE           reduce using rule 21 (comparison -> LOWER .)


state 77

    (18) comparison -> EQUAL .

    NUMBER          reduce using rule 18 (comparison -> EQUAL .)
    LOCAL           reduce using rule 18 (comparison -> EQUAL .)
    GLOBAL          reduce using rule 18 (comparison -> EQUAL .)
    CONSTANTS       reduce using rule 18 (comparison -> EQUAL .)
    INSTANCEVAR     reduce using rule 18 (comparison -> EQUAL .)
    CLASSVAR        reduce using rule 18 (comparison -> EQUAL .)
    TRUE            reduce using rule 18 (comparison -> EQUAL .)
    FALSE           reduce using rule 18 (comparison -> EQUAL .)


state 78

    (14) logical -> variable comparison . term
    (15) logical -> variable comparison . boolean
    (56) term -> . NUMBER
    (100) boolean -> . TRUE
    (101) boolean -> . FALSE

    NUMBER          shift and go to state 17
    TRUE            shift and go to state 41
    FALSE           shift and go to state 43

    term                           shift and go to state 117
    boolean                        shift and go to state 118

state 79

    (27) logcompare -> AND .

    NUMBER          reduce using rule 27 (logcompare -> AND .)
    LOCAL           reduce using rule 27 (logcompare -> AND .)
    GLOBAL          reduce using rule 27 (logcompare -> AND .)
    CONSTANTS       reduce using rule 27 (logcompare -> AND .)
    INSTANCEVAR     reduce using rule 27 (logcompare -> AND .)
    CLASSVAR        reduce using rule 27 (logcompare -> AND .)
    TRUE            reduce using rule 27 (logcompare -> AND .)
    FALSE           reduce using rule 27 (logcompare -> AND .)


state 80

    (16) logical -> logical logcompare . logical
    (12) logical -> . term comparison term
    (13) logical -> . term comparison logical
    (14) logical -> . variable comparison term
    (15) logical -> . variable comparison boolean
    (16) logical -> . logical logcompare logical
    (17) logical -> . boolean
    (56) term -> . NUMBER
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (100) boolean -> . TRUE
    (101) boolean -> . FALSE

    NUMBER          shift and go to state 17
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5
    TRUE            shift and go to state 41
    FALSE           shift and go to state 43

    term                           shift and go to state 38
    variable                       shift and go to state 39
    logical                        shift and go to state 119
    boolean                        shift and go to state 42

state 81

    (24) logcompare -> ANDLOG .

    NUMBER          reduce using rule 24 (logcompare -> ANDLOG .)
    LOCAL           reduce using rule 24 (logcompare -> ANDLOG .)
    GLOBAL          reduce using rule 24 (logcompare -> ANDLOG .)
    CONSTANTS       reduce using rule 24 (logcompare -> ANDLOG .)
    INSTANCEVAR     reduce using rule 24 (logcompare -> ANDLOG .)
    CLASSVAR        reduce using rule 24 (logcompare -> ANDLOG .)
    TRUE            reduce using rule 24 (logcompare -> ANDLOG .)
    FALSE           reduce using rule 24 (logcompare -> ANDLOG .)


state 82

    (70) if -> IF logical THEN . expr END
    (72) if -> IF logical THEN .
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for LOCAL resolved as shift
  ! shift/reduce conflict for GLOBAL resolved as shift
  ! shift/reduce conflict for CONSTANTS resolved as shift
  ! shift/reduce conflict for INSTANCEVAR resolved as shift
  ! shift/reduce conflict for CLASSVAR resolved as shift
    ELSE            reduce using rule 72 (if -> IF logical THEN .)
    ELSIF           reduce using rule 72 (if -> IF logical THEN .)
    IF              reduce using rule 72 (if -> IF logical THEN .)
    WHILE           reduce using rule 72 (if -> IF logical THEN .)
    BEGIN           reduce using rule 72 (if -> IF logical THEN .)
    FOR             reduce using rule 72 (if -> IF logical THEN .)
    END             reduce using rule 72 (if -> IF logical THEN .)
    NEWLINE         reduce using rule 72 (if -> IF logical THEN .)
    $end            reduce using rule 72 (if -> IF logical THEN .)
    NUMBER          shift and go to state 17
    STRING          shift and go to state 22
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5

  ! NUMBER          [ reduce using rule 72 (if -> IF logical THEN .) ]
  ! STRING          [ reduce using rule 72 (if -> IF logical THEN .) ]
  ! LOCAL           [ reduce using rule 72 (if -> IF logical THEN .) ]
  ! GLOBAL          [ reduce using rule 72 (if -> IF logical THEN .) ]
  ! CONSTANTS       [ reduce using rule 72 (if -> IF logical THEN .) ]
  ! INSTANCEVAR     [ reduce using rule 72 (if -> IF logical THEN .) ]
  ! CLASSVAR        [ reduce using rule 72 (if -> IF logical THEN .) ]

    term                           shift and go to state 61
    slice                          shift and go to state 1
    variable                       shift and go to state 65
    expr                           shift and go to state 120
    math                           shift and go to state 11
    index                          shift and go to state 9
    sterm                          shift and go to state 13

state 83

    (69) if -> IF logical expr . END

    END             shift and go to state 121


state 84

    (28) logcompare -> OR .

    NUMBER          reduce using rule 28 (logcompare -> OR .)
    LOCAL           reduce using rule 28 (logcompare -> OR .)
    GLOBAL          reduce using rule 28 (logcompare -> OR .)
    CONSTANTS       reduce using rule 28 (logcompare -> OR .)
    INSTANCEVAR     reduce using rule 28 (logcompare -> OR .)
    CLASSVAR        reduce using rule 28 (logcompare -> OR .)
    TRUE            reduce using rule 28 (logcompare -> OR .)
    FALSE           reduce using rule 28 (logcompare -> OR .)


state 85

    (25) logcompare -> ORLOG .

    NUMBER          reduce using rule 25 (logcompare -> ORLOG .)
    LOCAL           reduce using rule 25 (logcompare -> ORLOG .)
    GLOBAL          reduce using rule 25 (logcompare -> ORLOG .)
    CONSTANTS       reduce using rule 25 (logcompare -> ORLOG .)
    INSTANCEVAR     reduce using rule 25 (logcompare -> ORLOG .)
    CLASSVAR        reduce using rule 25 (logcompare -> ORLOG .)
    TRUE            reduce using rule 25 (logcompare -> ORLOG .)
    FALSE           reduce using rule 25 (logcompare -> ORLOG .)


state 86

    (29) logcompare -> NOT .

    NUMBER          reduce using rule 29 (logcompare -> NOT .)
    LOCAL           reduce using rule 29 (logcompare -> NOT .)
    GLOBAL          reduce using rule 29 (logcompare -> NOT .)
    CONSTANTS       reduce using rule 29 (logcompare -> NOT .)
    INSTANCEVAR     reduce using rule 29 (logcompare -> NOT .)
    CLASSVAR        reduce using rule 29 (logcompare -> NOT .)
    TRUE            reduce using rule 29 (logcompare -> NOT .)
    FALSE           reduce using rule 29 (logcompare -> NOT .)


state 87

    (26) logcompare -> NOTLOG .

    NUMBER          reduce using rule 26 (logcompare -> NOTLOG .)
    LOCAL           reduce using rule 26 (logcompare -> NOTLOG .)
    GLOBAL          reduce using rule 26 (logcompare -> NOTLOG .)
    CONSTANTS       reduce using rule 26 (logcompare -> NOTLOG .)
    INSTANCEVAR     reduce using rule 26 (logcompare -> NOTLOG .)
    CLASSVAR        reduce using rule 26 (logcompare -> NOTLOG .)
    TRUE            reduce using rule 26 (logcompare -> NOTLOG .)
    FALSE           reduce using rule 26 (logcompare -> NOTLOG .)


state 88

    (83) expresiones -> term DOUBLESECUENCEPOINT term .

    IF              reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    WHILE           reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    BEGIN           reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    FOR             reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    NUMBER          reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    STRING          reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    LOCAL           reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    GLOBAL          reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    CONSTANTS       reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    INSTANCEVAR     reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    CLASSVAR        reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    END             reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    $end            reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    NEWLINE         reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    DO              reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    ELSE            reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    ELSIF           reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)


state 89

    (33) math -> term arith term .
    (33) math -> term . arith term
    (34) math -> term . arith math
    (58) arith -> . EXP
    (59) arith -> . MUL
    (60) arith -> . DIV
    (61) arith -> . MOD
    (62) arith -> . ADD
    (63) arith -> . SUB

    NEWLINE         reduce using rule 33 (math -> term arith term .)
    IF              reduce using rule 33 (math -> term arith term .)
    WHILE           reduce using rule 33 (math -> term arith term .)
    BEGIN           reduce using rule 33 (math -> term arith term .)
    FOR             reduce using rule 33 (math -> term arith term .)
    NUMBER          reduce using rule 33 (math -> term arith term .)
    STRING          reduce using rule 33 (math -> term arith term .)
    LOCAL           reduce using rule 33 (math -> term arith term .)
    GLOBAL          reduce using rule 33 (math -> term arith term .)
    CONSTANTS       reduce using rule 33 (math -> term arith term .)
    INSTANCEVAR     reduce using rule 33 (math -> term arith term .)
    CLASSVAR        reduce using rule 33 (math -> term arith term .)
    END             reduce using rule 33 (math -> term arith term .)
    $end            reduce using rule 33 (math -> term arith term .)
    ELSE            reduce using rule 33 (math -> term arith term .)
    ELSIF           reduce using rule 33 (math -> term arith term .)
    EXP             shift and go to state 47
    MUL             shift and go to state 45
    DIV             shift and go to state 51
    MOD             shift and go to state 46
    ADD             shift and go to state 49
    SUB             shift and go to state 48

    arith                          shift and go to state 50

state 90

    (35) math -> variable . asig term
    (41) asig -> . ASS
    (42) asig -> . ADDASS
    (43) asig -> . SUBASS
    (44) asig -> . MULASS
    (45) asig -> . DIVASS
    (46) asig -> . MODASS
    (47) asig -> . EXPASS

    ASS             shift and go to state 108
    ADDASS          shift and go to state 35
    SUBASS          shift and go to state 37
    MULASS          shift and go to state 36
    DIVASS          shift and go to state 29
    MODASS          shift and go to state 32
    EXPASS          shift and go to state 33

    asig                           shift and go to state 30

state 91

    (34) math -> term arith math .

    NEWLINE         reduce using rule 34 (math -> term arith math .)
    IF              reduce using rule 34 (math -> term arith math .)
    WHILE           reduce using rule 34 (math -> term arith math .)
    BEGIN           reduce using rule 34 (math -> term arith math .)
    FOR             reduce using rule 34 (math -> term arith math .)
    NUMBER          reduce using rule 34 (math -> term arith math .)
    STRING          reduce using rule 34 (math -> term arith math .)
    LOCAL           reduce using rule 34 (math -> term arith math .)
    GLOBAL          reduce using rule 34 (math -> term arith math .)
    CONSTANTS       reduce using rule 34 (math -> term arith math .)
    INSTANCEVAR     reduce using rule 34 (math -> term arith math .)
    CLASSVAR        reduce using rule 34 (math -> term arith math .)
    END             reduce using rule 34 (math -> term arith math .)
    $end            reduce using rule 34 (math -> term arith math .)
    ELSE            reduce using rule 34 (math -> term arith math .)
    ELSIF           reduce using rule 34 (math -> term arith math .)


state 92

    (82) iterador -> variable COMA . variable
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR

    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5

    variable                       shift and go to state 122

state 93

    (64) for -> FOR iterador IN . expresiones code END
    (65) for -> FOR iterador IN . expresiones DO code END
    (66) for -> FOR iterador IN . array code END
    (67) for -> FOR iterador IN . array DO code END
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (84) array -> . LBRACK defarray RBRACK
    (56) term -> . NUMBER

    LBRACK          shift and go to state 62
    NUMBER          shift and go to state 17

    term                           shift and go to state 123
    expresiones                    shift and go to state 124
    array                          shift and go to state 125

state 94

    (11) while -> BEGIN code END . WHILE logical

    WHILE           shift and go to state 126


state 95

    (9) while -> WHILE logical DO . salto code salto END
    (68) salto -> . NEWLINE

    NEWLINE         shift and go to state 128

    salto                          shift and go to state 127

state 96

    (10) while -> WHILE logical DOBLEPOINT . salto code salto END
    (68) salto -> . NEWLINE

    NEWLINE         shift and go to state 128

    salto                          shift and go to state 129

state 97

    (8) while -> WHILE logical code . END
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    END             shift and go to state 130
    IF              shift and go to state 14
    WHILE           shift and go to state 24
    BEGIN           shift and go to state 20
    FOR             shift and go to state 19
    NUMBER          shift and go to state 17
    STRING          shift and go to state 22
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5

    term                           shift and go to state 15
    slice                          shift and go to state 1
    if                             shift and go to state 3
    expr                           shift and go to state 4
    for                            shift and go to state 18
    variable                       shift and go to state 6
    expresiones                    shift and go to state 8
    index                          shift and go to state 9
    while                          shift and go to state 21
    code                           shift and go to state 55
    math                           shift and go to state 11
    assign                         shift and go to state 12
    sterm                          shift and go to state 13

state 98

    (76) elsif -> ELSIF logical final .

    END             reduce using rule 76 (elsif -> ELSIF logical final .)


state 99

    (78) final -> THEN . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 14
    WHILE           shift and go to state 24
    BEGIN           shift and go to state 20
    FOR             shift and go to state 19
    NUMBER          shift and go to state 17
    STRING          shift and go to state 22
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5

    term                           shift and go to state 15
    slice                          shift and go to state 1
    if                             shift and go to state 3
    expr                           shift and go to state 4
    for                            shift and go to state 18
    variable                       shift and go to state 6
    expresiones                    shift and go to state 8
    index                          shift and go to state 9
    while                          shift and go to state 21
    code                           shift and go to state 131
    math                           shift and go to state 11
    assign                         shift and go to state 12
    sterm                          shift and go to state 13

state 100

    (77) final -> code .
    (79) final -> code . else
    (80) final -> code . elsif
    (7) code -> code . code
    (75) else -> . ELSE code END
    (76) elsif -> . ELSIF logical final
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    END             reduce using rule 77 (final -> code .)
    ELSE            shift and go to state 27
    ELSIF           shift and go to state 25
    IF              shift and go to state 14
    WHILE           shift and go to state 24
    BEGIN           shift and go to state 20
    FOR             shift and go to state 19
    NUMBER          shift and go to state 17
    STRING          shift and go to state 22
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5

    term                           shift and go to state 15
    slice                          shift and go to state 1
    else                           shift and go to state 132
    if                             shift and go to state 3
    expr                           shift and go to state 4
    for                            shift and go to state 18
    variable                       shift and go to state 6
    expresiones                    shift and go to state 8
    index                          shift and go to state 9
    while                          shift and go to state 21
    code                           shift and go to state 55
    elsif                          shift and go to state 133
    math                           shift and go to state 11
    assign                         shift and go to state 12
    sterm                          shift and go to state 13

state 101

    (75) else -> ELSE code END .

    END             reduce using rule 75 (else -> ELSE code END .)
    ELSE            reduce using rule 75 (else -> ELSE code END .)
    ELSIF           reduce using rule 75 (else -> ELSE code END .)
    IF              reduce using rule 75 (else -> ELSE code END .)
    WHILE           reduce using rule 75 (else -> ELSE code END .)
    BEGIN           reduce using rule 75 (else -> ELSE code END .)
    FOR             reduce using rule 75 (else -> ELSE code END .)
    NUMBER          reduce using rule 75 (else -> ELSE code END .)
    STRING          reduce using rule 75 (else -> ELSE code END .)
    LOCAL           reduce using rule 75 (else -> ELSE code END .)
    GLOBAL          reduce using rule 75 (else -> ELSE code END .)
    CONSTANTS       reduce using rule 75 (else -> ELSE code END .)
    INSTANCEVAR     reduce using rule 75 (else -> ELSE code END .)
    CLASSVAR        reduce using rule 75 (else -> ELSE code END .)
    $end            reduce using rule 75 (else -> ELSE code END .)
    NEWLINE         reduce using rule 75 (else -> ELSE code END .)


state 102

    (89) defarray -> INT .
    (90) defarray -> INT . COMA defarray

    RBRACK          reduce using rule 89 (defarray -> INT .)
    COMA            shift and go to state 134


state 103

    (84) array -> LBRACK defarray . RBRACK

    RBRACK          shift and go to state 135


state 104

    (93) defarray -> boolean .
    (94) defarray -> boolean . COMA defarray

    RBRACK          reduce using rule 93 (defarray -> boolean .)
    COMA            shift and go to state 136


state 105

    (85) defarray -> NUMBER .
    (86) defarray -> NUMBER . COMA defarray

    RBRACK          reduce using rule 85 (defarray -> NUMBER .)
    COMA            shift and go to state 137


state 106

    (91) defarray -> FLOAT .
    (92) defarray -> FLOAT . COMA defarray

    RBRACK          reduce using rule 91 (defarray -> FLOAT .)
    COMA            shift and go to state 138


state 107

    (87) defarray -> STRING .
    (88) defarray -> STRING . COMA defarray

    RBRACK          reduce using rule 87 (defarray -> STRING .)
    COMA            shift and go to state 139


state 108

    (41) asig -> ASS .

    NUMBER          reduce using rule 41 (asig -> ASS .)


state 109

    (54) sexpr -> sterm MUL . term
    (56) term -> . NUMBER

    NUMBER          shift and go to state 17

    term                           shift and go to state 140

state 110

    (55) sexpr -> sterm ADD . sexpr
    (54) sexpr -> . sterm MUL term
    (55) sexpr -> . sterm ADD sexpr
    (57) sterm -> . STRING

    STRING          shift and go to state 22

    sexpr                          shift and go to state 141
    sterm                          shift and go to state 142

state 111

    (95) index -> variable LBRACK INT RBRACK .

    IF              reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    WHILE           reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    BEGIN           reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    FOR             reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    NUMBER          reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    STRING          reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    LOCAL           reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    GLOBAL          reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    CONSTANTS       reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    INSTANCEVAR     reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    CLASSVAR        reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    END             reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    NEWLINE         reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    $end            reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    ELSE            reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    ELSIF           reduce using rule 95 (index -> variable LBRACK INT RBRACK .)


state 112

    (97) defslice -> INT DOBLEPOINT . INT
    (98) defslice -> INT DOBLEPOINT .

    INT             shift and go to state 143
    RBRACK          reduce using rule 98 (defslice -> INT DOBLEPOINT .)


state 113

    (99) defslice -> DOBLEPOINT INT .

    RBRACK          reduce using rule 99 (defslice -> DOBLEPOINT INT .)


state 114

    (96) slice -> variable LBRACK defslice RBRACK .

    END             reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    IF              reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    WHILE           reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    BEGIN           reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    FOR             reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    NUMBER          reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    STRING          reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    LOCAL           reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    GLOBAL          reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    CONSTANTS       reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    INSTANCEVAR     reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    CLASSVAR        reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    NEWLINE         reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    $end            reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    ELSE            reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    ELSIF           reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)


state 115

    (12) logical -> term comparison term .
    (12) logical -> term . comparison term
    (13) logical -> term . comparison logical
    (18) comparison -> . EQUAL
    (19) comparison -> . NOTEQ
    (20) comparison -> . GREATHER
    (21) comparison -> . LOWER
    (22) comparison -> . GREATHEREQ
    (23) comparison -> . LOWEREQ

    ANDLOG          reduce using rule 12 (logical -> term comparison term .)
    ORLOG           reduce using rule 12 (logical -> term comparison term .)
    NOTLOG          reduce using rule 12 (logical -> term comparison term .)
    AND             reduce using rule 12 (logical -> term comparison term .)
    OR              reduce using rule 12 (logical -> term comparison term .)
    NOT             reduce using rule 12 (logical -> term comparison term .)
    THEN            reduce using rule 12 (logical -> term comparison term .)
    NUMBER          reduce using rule 12 (logical -> term comparison term .)
    STRING          reduce using rule 12 (logical -> term comparison term .)
    LOCAL           reduce using rule 12 (logical -> term comparison term .)
    GLOBAL          reduce using rule 12 (logical -> term comparison term .)
    CONSTANTS       reduce using rule 12 (logical -> term comparison term .)
    INSTANCEVAR     reduce using rule 12 (logical -> term comparison term .)
    CLASSVAR        reduce using rule 12 (logical -> term comparison term .)
    ELSE            reduce using rule 12 (logical -> term comparison term .)
    ELSIF           reduce using rule 12 (logical -> term comparison term .)
    IF              reduce using rule 12 (logical -> term comparison term .)
    WHILE           reduce using rule 12 (logical -> term comparison term .)
    BEGIN           reduce using rule 12 (logical -> term comparison term .)
    FOR             reduce using rule 12 (logical -> term comparison term .)
    $end            reduce using rule 12 (logical -> term comparison term .)
    END             reduce using rule 12 (logical -> term comparison term .)
    NEWLINE         reduce using rule 12 (logical -> term comparison term .)
    DO              reduce using rule 12 (logical -> term comparison term .)
    DOBLEPOINT      reduce using rule 12 (logical -> term comparison term .)
    EQUAL           shift and go to state 77
    NOTEQ           shift and go to state 74
    GREATHER        shift and go to state 73
    LOWER           shift and go to state 76
    GREATHEREQ      shift and go to state 75
    LOWEREQ         shift and go to state 72

    comparison                     shift and go to state 71

state 116

    (13) logical -> term comparison logical .
    (16) logical -> logical . logcompare logical
    (24) logcompare -> . ANDLOG
    (25) logcompare -> . ORLOG
    (26) logcompare -> . NOTLOG
    (27) logcompare -> . AND
    (28) logcompare -> . OR
    (29) logcompare -> . NOT

  ! shift/reduce conflict for ANDLOG resolved as shift
  ! shift/reduce conflict for ORLOG resolved as shift
  ! shift/reduce conflict for NOTLOG resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    THEN            reduce using rule 13 (logical -> term comparison logical .)
    NUMBER          reduce using rule 13 (logical -> term comparison logical .)
    STRING          reduce using rule 13 (logical -> term comparison logical .)
    LOCAL           reduce using rule 13 (logical -> term comparison logical .)
    GLOBAL          reduce using rule 13 (logical -> term comparison logical .)
    CONSTANTS       reduce using rule 13 (logical -> term comparison logical .)
    INSTANCEVAR     reduce using rule 13 (logical -> term comparison logical .)
    CLASSVAR        reduce using rule 13 (logical -> term comparison logical .)
    ELSE            reduce using rule 13 (logical -> term comparison logical .)
    ELSIF           reduce using rule 13 (logical -> term comparison logical .)
    IF              reduce using rule 13 (logical -> term comparison logical .)
    WHILE           reduce using rule 13 (logical -> term comparison logical .)
    BEGIN           reduce using rule 13 (logical -> term comparison logical .)
    FOR             reduce using rule 13 (logical -> term comparison logical .)
    $end            reduce using rule 13 (logical -> term comparison logical .)
    END             reduce using rule 13 (logical -> term comparison logical .)
    NEWLINE         reduce using rule 13 (logical -> term comparison logical .)
    DO              reduce using rule 13 (logical -> term comparison logical .)
    DOBLEPOINT      reduce using rule 13 (logical -> term comparison logical .)
    ANDLOG          shift and go to state 81
    ORLOG           shift and go to state 85
    NOTLOG          shift and go to state 87
    AND             shift and go to state 79
    OR              shift and go to state 84
    NOT             shift and go to state 86

  ! ANDLOG          [ reduce using rule 13 (logical -> term comparison logical .) ]
  ! ORLOG           [ reduce using rule 13 (logical -> term comparison logical .) ]
  ! NOTLOG          [ reduce using rule 13 (logical -> term comparison logical .) ]
  ! AND             [ reduce using rule 13 (logical -> term comparison logical .) ]
  ! OR              [ reduce using rule 13 (logical -> term comparison logical .) ]
  ! NOT             [ reduce using rule 13 (logical -> term comparison logical .) ]

    logcompare                     shift and go to state 80

state 117

    (14) logical -> variable comparison term .

    ANDLOG          reduce using rule 14 (logical -> variable comparison term .)
    ORLOG           reduce using rule 14 (logical -> variable comparison term .)
    NOTLOG          reduce using rule 14 (logical -> variable comparison term .)
    AND             reduce using rule 14 (logical -> variable comparison term .)
    OR              reduce using rule 14 (logical -> variable comparison term .)
    NOT             reduce using rule 14 (logical -> variable comparison term .)
    THEN            reduce using rule 14 (logical -> variable comparison term .)
    NUMBER          reduce using rule 14 (logical -> variable comparison term .)
    STRING          reduce using rule 14 (logical -> variable comparison term .)
    LOCAL           reduce using rule 14 (logical -> variable comparison term .)
    GLOBAL          reduce using rule 14 (logical -> variable comparison term .)
    CONSTANTS       reduce using rule 14 (logical -> variable comparison term .)
    INSTANCEVAR     reduce using rule 14 (logical -> variable comparison term .)
    CLASSVAR        reduce using rule 14 (logical -> variable comparison term .)
    ELSE            reduce using rule 14 (logical -> variable comparison term .)
    ELSIF           reduce using rule 14 (logical -> variable comparison term .)
    IF              reduce using rule 14 (logical -> variable comparison term .)
    WHILE           reduce using rule 14 (logical -> variable comparison term .)
    BEGIN           reduce using rule 14 (logical -> variable comparison term .)
    FOR             reduce using rule 14 (logical -> variable comparison term .)
    $end            reduce using rule 14 (logical -> variable comparison term .)
    END             reduce using rule 14 (logical -> variable comparison term .)
    NEWLINE         reduce using rule 14 (logical -> variable comparison term .)
    DO              reduce using rule 14 (logical -> variable comparison term .)
    DOBLEPOINT      reduce using rule 14 (logical -> variable comparison term .)


state 118

    (15) logical -> variable comparison boolean .

    ANDLOG          reduce using rule 15 (logical -> variable comparison boolean .)
    ORLOG           reduce using rule 15 (logical -> variable comparison boolean .)
    NOTLOG          reduce using rule 15 (logical -> variable comparison boolean .)
    AND             reduce using rule 15 (logical -> variable comparison boolean .)
    OR              reduce using rule 15 (logical -> variable comparison boolean .)
    NOT             reduce using rule 15 (logical -> variable comparison boolean .)
    THEN            reduce using rule 15 (logical -> variable comparison boolean .)
    NUMBER          reduce using rule 15 (logical -> variable comparison boolean .)
    STRING          reduce using rule 15 (logical -> variable comparison boolean .)
    LOCAL           reduce using rule 15 (logical -> variable comparison boolean .)
    GLOBAL          reduce using rule 15 (logical -> variable comparison boolean .)
    CONSTANTS       reduce using rule 15 (logical -> variable comparison boolean .)
    INSTANCEVAR     reduce using rule 15 (logical -> variable comparison boolean .)
    CLASSVAR        reduce using rule 15 (logical -> variable comparison boolean .)
    ELSE            reduce using rule 15 (logical -> variable comparison boolean .)
    ELSIF           reduce using rule 15 (logical -> variable comparison boolean .)
    IF              reduce using rule 15 (logical -> variable comparison boolean .)
    WHILE           reduce using rule 15 (logical -> variable comparison boolean .)
    BEGIN           reduce using rule 15 (logical -> variable comparison boolean .)
    FOR             reduce using rule 15 (logical -> variable comparison boolean .)
    $end            reduce using rule 15 (logical -> variable comparison boolean .)
    END             reduce using rule 15 (logical -> variable comparison boolean .)
    NEWLINE         reduce using rule 15 (logical -> variable comparison boolean .)
    DO              reduce using rule 15 (logical -> variable comparison boolean .)
    DOBLEPOINT      reduce using rule 15 (logical -> variable comparison boolean .)


state 119

    (16) logical -> logical logcompare logical .
    (16) logical -> logical . logcompare logical
    (24) logcompare -> . ANDLOG
    (25) logcompare -> . ORLOG
    (26) logcompare -> . NOTLOG
    (27) logcompare -> . AND
    (28) logcompare -> . OR
    (29) logcompare -> . NOT

  ! shift/reduce conflict for ANDLOG resolved as shift
  ! shift/reduce conflict for ORLOG resolved as shift
  ! shift/reduce conflict for NOTLOG resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    THEN            reduce using rule 16 (logical -> logical logcompare logical .)
    NUMBER          reduce using rule 16 (logical -> logical logcompare logical .)
    STRING          reduce using rule 16 (logical -> logical logcompare logical .)
    LOCAL           reduce using rule 16 (logical -> logical logcompare logical .)
    GLOBAL          reduce using rule 16 (logical -> logical logcompare logical .)
    CONSTANTS       reduce using rule 16 (logical -> logical logcompare logical .)
    INSTANCEVAR     reduce using rule 16 (logical -> logical logcompare logical .)
    CLASSVAR        reduce using rule 16 (logical -> logical logcompare logical .)
    ELSE            reduce using rule 16 (logical -> logical logcompare logical .)
    ELSIF           reduce using rule 16 (logical -> logical logcompare logical .)
    IF              reduce using rule 16 (logical -> logical logcompare logical .)
    WHILE           reduce using rule 16 (logical -> logical logcompare logical .)
    BEGIN           reduce using rule 16 (logical -> logical logcompare logical .)
    FOR             reduce using rule 16 (logical -> logical logcompare logical .)
    $end            reduce using rule 16 (logical -> logical logcompare logical .)
    END             reduce using rule 16 (logical -> logical logcompare logical .)
    NEWLINE         reduce using rule 16 (logical -> logical logcompare logical .)
    DO              reduce using rule 16 (logical -> logical logcompare logical .)
    DOBLEPOINT      reduce using rule 16 (logical -> logical logcompare logical .)
    ANDLOG          shift and go to state 81
    ORLOG           shift and go to state 85
    NOTLOG          shift and go to state 87
    AND             shift and go to state 79
    OR              shift and go to state 84
    NOT             shift and go to state 86

  ! ANDLOG          [ reduce using rule 16 (logical -> logical logcompare logical .) ]
  ! ORLOG           [ reduce using rule 16 (logical -> logical logcompare logical .) ]
  ! NOTLOG          [ reduce using rule 16 (logical -> logical logcompare logical .) ]
  ! AND             [ reduce using rule 16 (logical -> logical logcompare logical .) ]
  ! OR              [ reduce using rule 16 (logical -> logical logcompare logical .) ]
  ! NOT             [ reduce using rule 16 (logical -> logical logcompare logical .) ]

    logcompare                     shift and go to state 80

state 120

    (70) if -> IF logical THEN expr . END

    END             shift and go to state 144


state 121

    (69) if -> IF logical expr END .

    ELSE            reduce using rule 69 (if -> IF logical expr END .)
    ELSIF           reduce using rule 69 (if -> IF logical expr END .)
    IF              reduce using rule 69 (if -> IF logical expr END .)
    WHILE           reduce using rule 69 (if -> IF logical expr END .)
    BEGIN           reduce using rule 69 (if -> IF logical expr END .)
    FOR             reduce using rule 69 (if -> IF logical expr END .)
    NUMBER          reduce using rule 69 (if -> IF logical expr END .)
    STRING          reduce using rule 69 (if -> IF logical expr END .)
    LOCAL           reduce using rule 69 (if -> IF logical expr END .)
    GLOBAL          reduce using rule 69 (if -> IF logical expr END .)
    CONSTANTS       reduce using rule 69 (if -> IF logical expr END .)
    INSTANCEVAR     reduce using rule 69 (if -> IF logical expr END .)
    CLASSVAR        reduce using rule 69 (if -> IF logical expr END .)
    END             reduce using rule 69 (if -> IF logical expr END .)
    NEWLINE         reduce using rule 69 (if -> IF logical expr END .)
    $end            reduce using rule 69 (if -> IF logical expr END .)


state 122

    (82) iterador -> variable COMA variable .

    IN              reduce using rule 82 (iterador -> variable COMA variable .)


state 123

    (83) expresiones -> term . DOUBLESECUENCEPOINT term

    DOUBLESECUENCEPOINT shift and go to state 44


state 124

    (64) for -> FOR iterador IN expresiones . code END
    (65) for -> FOR iterador IN expresiones . DO code END
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    DO              shift and go to state 145
    IF              shift and go to state 14
    WHILE           shift and go to state 24
    BEGIN           shift and go to state 20
    FOR             shift and go to state 19
    NUMBER          shift and go to state 17
    STRING          shift and go to state 22
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5

    term                           shift and go to state 15
    slice                          shift and go to state 1
    if                             shift and go to state 3
    expr                           shift and go to state 4
    for                            shift and go to state 18
    variable                       shift and go to state 6
    expresiones                    shift and go to state 8
    index                          shift and go to state 9
    while                          shift and go to state 21
    code                           shift and go to state 146
    math                           shift and go to state 11
    assign                         shift and go to state 12
    sterm                          shift and go to state 13

state 125

    (66) for -> FOR iterador IN array . code END
    (67) for -> FOR iterador IN array . DO code END
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    DO              shift and go to state 147
    IF              shift and go to state 14
    WHILE           shift and go to state 24
    BEGIN           shift and go to state 20
    FOR             shift and go to state 19
    NUMBER          shift and go to state 17
    STRING          shift and go to state 22
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5

    term                           shift and go to state 15
    slice                          shift and go to state 1
    if                             shift and go to state 3
    expr                           shift and go to state 4
    for                            shift and go to state 18
    variable                       shift and go to state 6
    expresiones                    shift and go to state 8
    index                          shift and go to state 9
    while                          shift and go to state 21
    code                           shift and go to state 148
    math                           shift and go to state 11
    assign                         shift and go to state 12
    sterm                          shift and go to state 13

state 126

    (11) while -> BEGIN code END WHILE . logical
    (12) logical -> . term comparison term
    (13) logical -> . term comparison logical
    (14) logical -> . variable comparison term
    (15) logical -> . variable comparison boolean
    (16) logical -> . logical logcompare logical
    (17) logical -> . boolean
    (56) term -> . NUMBER
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (100) boolean -> . TRUE
    (101) boolean -> . FALSE

    NUMBER          shift and go to state 17
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5
    TRUE            shift and go to state 41
    FALSE           shift and go to state 43

    term                           shift and go to state 38
    logical                        shift and go to state 149
    boolean                        shift and go to state 42
    variable                       shift and go to state 39

state 127

    (9) while -> WHILE logical DO salto . code salto END
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 14
    WHILE           shift and go to state 24
    BEGIN           shift and go to state 20
    FOR             shift and go to state 19
    NUMBER          shift and go to state 17
    STRING          shift and go to state 22
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5

    term                           shift and go to state 15
    slice                          shift and go to state 1
    if                             shift and go to state 3
    expr                           shift and go to state 4
    for                            shift and go to state 18
    variable                       shift and go to state 6
    expresiones                    shift and go to state 8
    index                          shift and go to state 9
    while                          shift and go to state 21
    code                           shift and go to state 150
    math                           shift and go to state 11
    assign                         shift and go to state 12
    sterm                          shift and go to state 13

state 128

    (68) salto -> NEWLINE .

    IF              reduce using rule 68 (salto -> NEWLINE .)
    WHILE           reduce using rule 68 (salto -> NEWLINE .)
    BEGIN           reduce using rule 68 (salto -> NEWLINE .)
    FOR             reduce using rule 68 (salto -> NEWLINE .)
    NUMBER          reduce using rule 68 (salto -> NEWLINE .)
    STRING          reduce using rule 68 (salto -> NEWLINE .)
    LOCAL           reduce using rule 68 (salto -> NEWLINE .)
    GLOBAL          reduce using rule 68 (salto -> NEWLINE .)
    CONSTANTS       reduce using rule 68 (salto -> NEWLINE .)
    INSTANCEVAR     reduce using rule 68 (salto -> NEWLINE .)
    CLASSVAR        reduce using rule 68 (salto -> NEWLINE .)
    END             reduce using rule 68 (salto -> NEWLINE .)


state 129

    (10) while -> WHILE logical DOBLEPOINT salto . code salto END
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 14
    WHILE           shift and go to state 24
    BEGIN           shift and go to state 20
    FOR             shift and go to state 19
    NUMBER          shift and go to state 17
    STRING          shift and go to state 22
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5

    term                           shift and go to state 15
    slice                          shift and go to state 1
    if                             shift and go to state 3
    expr                           shift and go to state 4
    for                            shift and go to state 18
    variable                       shift and go to state 6
    expresiones                    shift and go to state 8
    index                          shift and go to state 9
    while                          shift and go to state 21
    code                           shift and go to state 151
    math                           shift and go to state 11
    assign                         shift and go to state 12
    sterm                          shift and go to state 13

state 130

    (8) while -> WHILE logical code END .

    END             reduce using rule 8 (while -> WHILE logical code END .)
    IF              reduce using rule 8 (while -> WHILE logical code END .)
    WHILE           reduce using rule 8 (while -> WHILE logical code END .)
    BEGIN           reduce using rule 8 (while -> WHILE logical code END .)
    FOR             reduce using rule 8 (while -> WHILE logical code END .)
    NUMBER          reduce using rule 8 (while -> WHILE logical code END .)
    STRING          reduce using rule 8 (while -> WHILE logical code END .)
    LOCAL           reduce using rule 8 (while -> WHILE logical code END .)
    GLOBAL          reduce using rule 8 (while -> WHILE logical code END .)
    CONSTANTS       reduce using rule 8 (while -> WHILE logical code END .)
    INSTANCEVAR     reduce using rule 8 (while -> WHILE logical code END .)
    CLASSVAR        reduce using rule 8 (while -> WHILE logical code END .)
    $end            reduce using rule 8 (while -> WHILE logical code END .)
    ELSE            reduce using rule 8 (while -> WHILE logical code END .)
    ELSIF           reduce using rule 8 (while -> WHILE logical code END .)
    NEWLINE         reduce using rule 8 (while -> WHILE logical code END .)


state 131

    (78) final -> THEN code .
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    END             reduce using rule 78 (final -> THEN code .)
    IF              shift and go to state 14
    WHILE           shift and go to state 24
    BEGIN           shift and go to state 20
    FOR             shift and go to state 19
    NUMBER          shift and go to state 17
    STRING          shift and go to state 22
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5

    term                           shift and go to state 15
    slice                          shift and go to state 1
    if                             shift and go to state 3
    expr                           shift and go to state 4
    for                            shift and go to state 18
    variable                       shift and go to state 6
    expresiones                    shift and go to state 8
    index                          shift and go to state 9
    while                          shift and go to state 21
    code                           shift and go to state 55
    math                           shift and go to state 11
    assign                         shift and go to state 12
    sterm                          shift and go to state 13

state 132

    (79) final -> code else .

    END             reduce using rule 79 (final -> code else .)


state 133

    (80) final -> code elsif .

    END             reduce using rule 80 (final -> code elsif .)


state 134

    (90) defarray -> INT COMA . defarray
    (85) defarray -> . NUMBER
    (86) defarray -> . NUMBER COMA defarray
    (87) defarray -> . STRING
    (88) defarray -> . STRING COMA defarray
    (89) defarray -> . INT
    (90) defarray -> . INT COMA defarray
    (91) defarray -> . FLOAT
    (92) defarray -> . FLOAT COMA defarray
    (93) defarray -> . boolean
    (94) defarray -> . boolean COMA defarray
    (100) boolean -> . TRUE
    (101) boolean -> . FALSE

    NUMBER          shift and go to state 105
    STRING          shift and go to state 107
    INT             shift and go to state 102
    FLOAT           shift and go to state 106
    TRUE            shift and go to state 41
    FALSE           shift and go to state 43

    defarray                       shift and go to state 152
    boolean                        shift and go to state 104

state 135

    (84) array -> LBRACK defarray RBRACK .

    DO              reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    IF              reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    WHILE           reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    BEGIN           reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    FOR             reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    NUMBER          reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    STRING          reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    LOCAL           reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    GLOBAL          reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    CONSTANTS       reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    INSTANCEVAR     reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    CLASSVAR        reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    $end            reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    END             reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    ELSE            reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    ELSIF           reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    NEWLINE         reduce using rule 84 (array -> LBRACK defarray RBRACK .)


state 136

    (94) defarray -> boolean COMA . defarray
    (85) defarray -> . NUMBER
    (86) defarray -> . NUMBER COMA defarray
    (87) defarray -> . STRING
    (88) defarray -> . STRING COMA defarray
    (89) defarray -> . INT
    (90) defarray -> . INT COMA defarray
    (91) defarray -> . FLOAT
    (92) defarray -> . FLOAT COMA defarray
    (93) defarray -> . boolean
    (94) defarray -> . boolean COMA defarray
    (100) boolean -> . TRUE
    (101) boolean -> . FALSE

    NUMBER          shift and go to state 105
    STRING          shift and go to state 107
    INT             shift and go to state 102
    FLOAT           shift and go to state 106
    TRUE            shift and go to state 41
    FALSE           shift and go to state 43

    defarray                       shift and go to state 153
    boolean                        shift and go to state 104

state 137

    (86) defarray -> NUMBER COMA . defarray
    (85) defarray -> . NUMBER
    (86) defarray -> . NUMBER COMA defarray
    (87) defarray -> . STRING
    (88) defarray -> . STRING COMA defarray
    (89) defarray -> . INT
    (90) defarray -> . INT COMA defarray
    (91) defarray -> . FLOAT
    (92) defarray -> . FLOAT COMA defarray
    (93) defarray -> . boolean
    (94) defarray -> . boolean COMA defarray
    (100) boolean -> . TRUE
    (101) boolean -> . FALSE

    NUMBER          shift and go to state 105
    STRING          shift and go to state 107
    INT             shift and go to state 102
    FLOAT           shift and go to state 106
    TRUE            shift and go to state 41
    FALSE           shift and go to state 43

    defarray                       shift and go to state 154
    boolean                        shift and go to state 104

state 138

    (92) defarray -> FLOAT COMA . defarray
    (85) defarray -> . NUMBER
    (86) defarray -> . NUMBER COMA defarray
    (87) defarray -> . STRING
    (88) defarray -> . STRING COMA defarray
    (89) defarray -> . INT
    (90) defarray -> . INT COMA defarray
    (91) defarray -> . FLOAT
    (92) defarray -> . FLOAT COMA defarray
    (93) defarray -> . boolean
    (94) defarray -> . boolean COMA defarray
    (100) boolean -> . TRUE
    (101) boolean -> . FALSE

    NUMBER          shift and go to state 105
    STRING          shift and go to state 107
    INT             shift and go to state 102
    FLOAT           shift and go to state 106
    TRUE            shift and go to state 41
    FALSE           shift and go to state 43

    defarray                       shift and go to state 155
    boolean                        shift and go to state 104

state 139

    (88) defarray -> STRING COMA . defarray
    (85) defarray -> . NUMBER
    (86) defarray -> . NUMBER COMA defarray
    (87) defarray -> . STRING
    (88) defarray -> . STRING COMA defarray
    (89) defarray -> . INT
    (90) defarray -> . INT COMA defarray
    (91) defarray -> . FLOAT
    (92) defarray -> . FLOAT COMA defarray
    (93) defarray -> . boolean
    (94) defarray -> . boolean COMA defarray
    (100) boolean -> . TRUE
    (101) boolean -> . FALSE

    NUMBER          shift and go to state 105
    STRING          shift and go to state 107
    INT             shift and go to state 102
    FLOAT           shift and go to state 106
    TRUE            shift and go to state 41
    FALSE           shift and go to state 43

    defarray                       shift and go to state 156
    boolean                        shift and go to state 104

state 140

    (54) sexpr -> sterm MUL term .

    IF              reduce using rule 54 (sexpr -> sterm MUL term .)
    WHILE           reduce using rule 54 (sexpr -> sterm MUL term .)
    BEGIN           reduce using rule 54 (sexpr -> sterm MUL term .)
    FOR             reduce using rule 54 (sexpr -> sterm MUL term .)
    NUMBER          reduce using rule 54 (sexpr -> sterm MUL term .)
    STRING          reduce using rule 54 (sexpr -> sterm MUL term .)
    LOCAL           reduce using rule 54 (sexpr -> sterm MUL term .)
    GLOBAL          reduce using rule 54 (sexpr -> sterm MUL term .)
    CONSTANTS       reduce using rule 54 (sexpr -> sterm MUL term .)
    INSTANCEVAR     reduce using rule 54 (sexpr -> sterm MUL term .)
    CLASSVAR        reduce using rule 54 (sexpr -> sterm MUL term .)
    $end            reduce using rule 54 (sexpr -> sterm MUL term .)
    END             reduce using rule 54 (sexpr -> sterm MUL term .)
    ELSE            reduce using rule 54 (sexpr -> sterm MUL term .)
    ELSIF           reduce using rule 54 (sexpr -> sterm MUL term .)
    NEWLINE         reduce using rule 54 (sexpr -> sterm MUL term .)


state 141

    (55) sexpr -> sterm ADD sexpr .

    IF              reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    WHILE           reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    BEGIN           reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    FOR             reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    NUMBER          reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    STRING          reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    LOCAL           reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    GLOBAL          reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    CONSTANTS       reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    INSTANCEVAR     reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    CLASSVAR        reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    $end            reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    END             reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    ELSE            reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    ELSIF           reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    NEWLINE         reduce using rule 55 (sexpr -> sterm ADD sexpr .)


state 142

    (54) sexpr -> sterm . MUL term
    (55) sexpr -> sterm . ADD sexpr

    MUL             shift and go to state 109
    ADD             shift and go to state 110


state 143

    (97) defslice -> INT DOBLEPOINT INT .

    RBRACK          reduce using rule 97 (defslice -> INT DOBLEPOINT INT .)


state 144

    (70) if -> IF logical THEN expr END .

    ELSE            reduce using rule 70 (if -> IF logical THEN expr END .)
    ELSIF           reduce using rule 70 (if -> IF logical THEN expr END .)
    IF              reduce using rule 70 (if -> IF logical THEN expr END .)
    WHILE           reduce using rule 70 (if -> IF logical THEN expr END .)
    BEGIN           reduce using rule 70 (if -> IF logical THEN expr END .)
    FOR             reduce using rule 70 (if -> IF logical THEN expr END .)
    NUMBER          reduce using rule 70 (if -> IF logical THEN expr END .)
    STRING          reduce using rule 70 (if -> IF logical THEN expr END .)
    LOCAL           reduce using rule 70 (if -> IF logical THEN expr END .)
    GLOBAL          reduce using rule 70 (if -> IF logical THEN expr END .)
    CONSTANTS       reduce using rule 70 (if -> IF logical THEN expr END .)
    INSTANCEVAR     reduce using rule 70 (if -> IF logical THEN expr END .)
    CLASSVAR        reduce using rule 70 (if -> IF logical THEN expr END .)
    END             reduce using rule 70 (if -> IF logical THEN expr END .)
    NEWLINE         reduce using rule 70 (if -> IF logical THEN expr END .)
    $end            reduce using rule 70 (if -> IF logical THEN expr END .)


state 145

    (65) for -> FOR iterador IN expresiones DO . code END
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 14
    WHILE           shift and go to state 24
    BEGIN           shift and go to state 20
    FOR             shift and go to state 19
    NUMBER          shift and go to state 17
    STRING          shift and go to state 22
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5

    term                           shift and go to state 15
    slice                          shift and go to state 1
    if                             shift and go to state 3
    expr                           shift and go to state 4
    for                            shift and go to state 18
    variable                       shift and go to state 6
    expresiones                    shift and go to state 8
    index                          shift and go to state 9
    while                          shift and go to state 21
    code                           shift and go to state 157
    math                           shift and go to state 11
    assign                         shift and go to state 12
    sterm                          shift and go to state 13

state 146

    (64) for -> FOR iterador IN expresiones code . END
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    END             shift and go to state 158
    IF              shift and go to state 14
    WHILE           shift and go to state 24
    BEGIN           shift and go to state 20
    FOR             shift and go to state 19
    NUMBER          shift and go to state 17
    STRING          shift and go to state 22
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5

    term                           shift and go to state 15
    slice                          shift and go to state 1
    if                             shift and go to state 3
    expr                           shift and go to state 4
    for                            shift and go to state 18
    variable                       shift and go to state 6
    expresiones                    shift and go to state 8
    index                          shift and go to state 9
    while                          shift and go to state 21
    code                           shift and go to state 55
    math                           shift and go to state 11
    assign                         shift and go to state 12
    sterm                          shift and go to state 13

state 147

    (67) for -> FOR iterador IN array DO . code END
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 14
    WHILE           shift and go to state 24
    BEGIN           shift and go to state 20
    FOR             shift and go to state 19
    NUMBER          shift and go to state 17
    STRING          shift and go to state 22
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5

    term                           shift and go to state 15
    slice                          shift and go to state 1
    if                             shift and go to state 3
    expr                           shift and go to state 4
    for                            shift and go to state 18
    variable                       shift and go to state 6
    expresiones                    shift and go to state 8
    index                          shift and go to state 9
    while                          shift and go to state 21
    code                           shift and go to state 159
    math                           shift and go to state 11
    assign                         shift and go to state 12
    sterm                          shift and go to state 13

state 148

    (66) for -> FOR iterador IN array code . END
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    END             shift and go to state 160
    IF              shift and go to state 14
    WHILE           shift and go to state 24
    BEGIN           shift and go to state 20
    FOR             shift and go to state 19
    NUMBER          shift and go to state 17
    STRING          shift and go to state 22
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5

    term                           shift and go to state 15
    slice                          shift and go to state 1
    if                             shift and go to state 3
    expr                           shift and go to state 4
    for                            shift and go to state 18
    variable                       shift and go to state 6
    expresiones                    shift and go to state 8
    index                          shift and go to state 9
    while                          shift and go to state 21
    code                           shift and go to state 55
    math                           shift and go to state 11
    assign                         shift and go to state 12
    sterm                          shift and go to state 13

state 149

    (11) while -> BEGIN code END WHILE logical .
    (16) logical -> logical . logcompare logical
    (24) logcompare -> . ANDLOG
    (25) logcompare -> . ORLOG
    (26) logcompare -> . NOTLOG
    (27) logcompare -> . AND
    (28) logcompare -> . OR
    (29) logcompare -> . NOT

    END             reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    IF              reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    WHILE           reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    BEGIN           reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    FOR             reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    NUMBER          reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    STRING          reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    LOCAL           reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    GLOBAL          reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    CONSTANTS       reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    INSTANCEVAR     reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    CLASSVAR        reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    $end            reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    ELSE            reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    ELSIF           reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    NEWLINE         reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    ANDLOG          shift and go to state 81
    ORLOG           shift and go to state 85
    NOTLOG          shift and go to state 87
    AND             shift and go to state 79
    OR              shift and go to state 84
    NOT             shift and go to state 86

    logcompare                     shift and go to state 80

state 150

    (9) while -> WHILE logical DO salto code . salto END
    (7) code -> code . code
    (68) salto -> . NEWLINE
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    NEWLINE         shift and go to state 128
    IF              shift and go to state 14
    WHILE           shift and go to state 24
    BEGIN           shift and go to state 20
    FOR             shift and go to state 19
    NUMBER          shift and go to state 17
    STRING          shift and go to state 22
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5

    term                           shift and go to state 15
    slice                          shift and go to state 1
    if                             shift and go to state 3
    salto                          shift and go to state 161
    expr                           shift and go to state 4
    for                            shift and go to state 18
    variable                       shift and go to state 6
    expresiones                    shift and go to state 8
    index                          shift and go to state 9
    while                          shift and go to state 21
    code                           shift and go to state 55
    math                           shift and go to state 11
    assign                         shift and go to state 12
    sterm                          shift and go to state 13

state 151

    (10) while -> WHILE logical DOBLEPOINT salto code . salto END
    (7) code -> code . code
    (68) salto -> . NEWLINE
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    NEWLINE         shift and go to state 128
    IF              shift and go to state 14
    WHILE           shift and go to state 24
    BEGIN           shift and go to state 20
    FOR             shift and go to state 19
    NUMBER          shift and go to state 17
    STRING          shift and go to state 22
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5

    term                           shift and go to state 15
    slice                          shift and go to state 1
    if                             shift and go to state 3
    salto                          shift and go to state 162
    expr                           shift and go to state 4
    for                            shift and go to state 18
    variable                       shift and go to state 6
    expresiones                    shift and go to state 8
    index                          shift and go to state 9
    while                          shift and go to state 21
    code                           shift and go to state 55
    math                           shift and go to state 11
    assign                         shift and go to state 12
    sterm                          shift and go to state 13

state 152

    (90) defarray -> INT COMA defarray .

    RBRACK          reduce using rule 90 (defarray -> INT COMA defarray .)


state 153

    (94) defarray -> boolean COMA defarray .

    RBRACK          reduce using rule 94 (defarray -> boolean COMA defarray .)


state 154

    (86) defarray -> NUMBER COMA defarray .

    RBRACK          reduce using rule 86 (defarray -> NUMBER COMA defarray .)


state 155

    (92) defarray -> FLOAT COMA defarray .

    RBRACK          reduce using rule 92 (defarray -> FLOAT COMA defarray .)


state 156

    (88) defarray -> STRING COMA defarray .

    RBRACK          reduce using rule 88 (defarray -> STRING COMA defarray .)


state 157

    (65) for -> FOR iterador IN expresiones DO code . END
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    END             shift and go to state 163
    IF              shift and go to state 14
    WHILE           shift and go to state 24
    BEGIN           shift and go to state 20
    FOR             shift and go to state 19
    NUMBER          shift and go to state 17
    STRING          shift and go to state 22
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5

    term                           shift and go to state 15
    slice                          shift and go to state 1
    if                             shift and go to state 3
    expr                           shift and go to state 4
    for                            shift and go to state 18
    variable                       shift and go to state 6
    expresiones                    shift and go to state 8
    index                          shift and go to state 9
    while                          shift and go to state 21
    code                           shift and go to state 55
    math                           shift and go to state 11
    assign                         shift and go to state 12
    sterm                          shift and go to state 13

state 158

    (64) for -> FOR iterador IN expresiones code END .

    IF              reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    WHILE           reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    BEGIN           reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    FOR             reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    NUMBER          reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    STRING          reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    LOCAL           reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    GLOBAL          reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    CONSTANTS       reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    INSTANCEVAR     reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    CLASSVAR        reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    END             reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    NEWLINE         reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    $end            reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    ELSE            reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    ELSIF           reduce using rule 64 (for -> FOR iterador IN expresiones code END .)


state 159

    (67) for -> FOR iterador IN array DO code . END
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    END             shift and go to state 164
    IF              shift and go to state 14
    WHILE           shift and go to state 24
    BEGIN           shift and go to state 20
    FOR             shift and go to state 19
    NUMBER          shift and go to state 17
    STRING          shift and go to state 22
    LOCAL           shift and go to state 16
    GLOBAL          shift and go to state 2
    CONSTANTS       shift and go to state 7
    INSTANCEVAR     shift and go to state 10
    CLASSVAR        shift and go to state 5

    term                           shift and go to state 15
    slice                          shift and go to state 1
    if                             shift and go to state 3
    expr                           shift and go to state 4
    for                            shift and go to state 18
    variable                       shift and go to state 6
    expresiones                    shift and go to state 8
    index                          shift and go to state 9
    while                          shift and go to state 21
    code                           shift and go to state 55
    math                           shift and go to state 11
    assign                         shift and go to state 12
    sterm                          shift and go to state 13

state 160

    (66) for -> FOR iterador IN array code END .

    IF              reduce using rule 66 (for -> FOR iterador IN array code END .)
    WHILE           reduce using rule 66 (for -> FOR iterador IN array code END .)
    BEGIN           reduce using rule 66 (for -> FOR iterador IN array code END .)
    FOR             reduce using rule 66 (for -> FOR iterador IN array code END .)
    NUMBER          reduce using rule 66 (for -> FOR iterador IN array code END .)
    STRING          reduce using rule 66 (for -> FOR iterador IN array code END .)
    LOCAL           reduce using rule 66 (for -> FOR iterador IN array code END .)
    GLOBAL          reduce using rule 66 (for -> FOR iterador IN array code END .)
    CONSTANTS       reduce using rule 66 (for -> FOR iterador IN array code END .)
    INSTANCEVAR     reduce using rule 66 (for -> FOR iterador IN array code END .)
    CLASSVAR        reduce using rule 66 (for -> FOR iterador IN array code END .)
    END             reduce using rule 66 (for -> FOR iterador IN array code END .)
    NEWLINE         reduce using rule 66 (for -> FOR iterador IN array code END .)
    $end            reduce using rule 66 (for -> FOR iterador IN array code END .)
    ELSE            reduce using rule 66 (for -> FOR iterador IN array code END .)
    ELSIF           reduce using rule 66 (for -> FOR iterador IN array code END .)


state 161

    (9) while -> WHILE logical DO salto code salto . END

    END             shift and go to state 165


state 162

    (10) while -> WHILE logical DOBLEPOINT salto code salto . END

    END             shift and go to state 166


state 163

    (65) for -> FOR iterador IN expresiones DO code END .

    IF              reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    WHILE           reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    BEGIN           reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    FOR             reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    NUMBER          reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    STRING          reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    LOCAL           reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    GLOBAL          reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    CONSTANTS       reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    INSTANCEVAR     reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    CLASSVAR        reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    END             reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    NEWLINE         reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    $end            reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    ELSE            reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    ELSIF           reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)


state 164

    (67) for -> FOR iterador IN array DO code END .

    IF              reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    WHILE           reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    BEGIN           reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    FOR             reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    NUMBER          reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    STRING          reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    LOCAL           reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    GLOBAL          reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    CONSTANTS       reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    INSTANCEVAR     reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    CLASSVAR        reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    END             reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    NEWLINE         reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    $end            reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    ELSE            reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    ELSIF           reduce using rule 67 (for -> FOR iterador IN array DO code END .)


state 165

    (9) while -> WHILE logical DO salto code salto END .

    END             reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    IF              reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    WHILE           reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    BEGIN           reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    FOR             reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    NUMBER          reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    STRING          reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    LOCAL           reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    GLOBAL          reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    CONSTANTS       reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    INSTANCEVAR     reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    CLASSVAR        reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    $end            reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    ELSE            reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    ELSIF           reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    NEWLINE         reduce using rule 9 (while -> WHILE logical DO salto code salto END .)


state 166

    (10) while -> WHILE logical DOBLEPOINT salto code salto END .

    END             reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    IF              reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    WHILE           reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    BEGIN           reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    FOR             reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    NUMBER          reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    STRING          reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    LOCAL           reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    GLOBAL          reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    CONSTANTS       reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    INSTANCEVAR     reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    CLASSVAR        reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    $end            reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    ELSE            reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    ELSIF           reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    NEWLINE         reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 3 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 3 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 31 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 40 resolved as shift
WARNING: shift/reduce conflict for STRING in state 40 resolved as shift
WARNING: shift/reduce conflict for LOCAL in state 40 resolved as shift
WARNING: shift/reduce conflict for GLOBAL in state 40 resolved as shift
WARNING: shift/reduce conflict for CONSTANTS in state 40 resolved as shift
WARNING: shift/reduce conflict for INSTANCEVAR in state 40 resolved as shift
WARNING: shift/reduce conflict for CLASSVAR in state 40 resolved as shift
WARNING: shift/reduce conflict for IF in state 55 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 55 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 55 resolved as shift
WARNING: shift/reduce conflict for FOR in state 55 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 55 resolved as shift
WARNING: shift/reduce conflict for STRING in state 55 resolved as shift
WARNING: shift/reduce conflict for LOCAL in state 55 resolved as shift
WARNING: shift/reduce conflict for GLOBAL in state 55 resolved as shift
WARNING: shift/reduce conflict for CONSTANTS in state 55 resolved as shift
WARNING: shift/reduce conflict for INSTANCEVAR in state 55 resolved as shift
WARNING: shift/reduce conflict for CLASSVAR in state 55 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 82 resolved as shift
WARNING: shift/reduce conflict for STRING in state 82 resolved as shift
WARNING: shift/reduce conflict for LOCAL in state 82 resolved as shift
WARNING: shift/reduce conflict for GLOBAL in state 82 resolved as shift
WARNING: shift/reduce conflict for CONSTANTS in state 82 resolved as shift
WARNING: shift/reduce conflict for INSTANCEVAR in state 82 resolved as shift
WARNING: shift/reduce conflict for CLASSVAR in state 82 resolved as shift
WARNING: shift/reduce conflict for ANDLOG in state 116 resolved as shift
WARNING: shift/reduce conflict for ORLOG in state 116 resolved as shift
WARNING: shift/reduce conflict for NOTLOG in state 116 resolved as shift
WARNING: shift/reduce conflict for AND in state 116 resolved as shift
WARNING: shift/reduce conflict for OR in state 116 resolved as shift
WARNING: shift/reduce conflict for NOT in state 116 resolved as shift
WARNING: shift/reduce conflict for ANDLOG in state 119 resolved as shift
WARNING: shift/reduce conflict for ORLOG in state 119 resolved as shift
WARNING: shift/reduce conflict for NOTLOG in state 119 resolved as shift
WARNING: shift/reduce conflict for AND in state 119 resolved as shift
WARNING: shift/reduce conflict for OR in state 119 resolved as shift
WARNING: shift/reduce conflict for NOT in state 119 resolved as shift
