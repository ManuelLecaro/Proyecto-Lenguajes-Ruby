Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ALIAS
    BREAK
    CASE
    CLASS
    DEF
    DEFINED
    ENSURE
    ERROR
    FALSE
    FILE
    LINE
    MODULE
    NEXT
    NIL
    PSEUDO
    REDO
    RESCUE
    RETRY
    RETURN
    SELF
    SUPER
    TRUE
    UNDEF
    UNLESS
    UNTIL
    WHEN
    YIELD

Grammar

Rule 0     S' -> code
Rule 1     code -> expr
Rule 2     code -> if
Rule 3     code -> while
Rule 4     code -> expresiones
Rule 5     code -> for
Rule 6     code -> assign
Rule 7     code -> code code
Rule 8     while -> WHILE logical code END
Rule 9     while -> WHILE logical DO salto code salto END
Rule 10    while -> WHILE logical DOBLEPOINT salto code salto END
Rule 11    while -> BEGIN code END WHILE logical
Rule 12    logical -> term comparison term
Rule 13    logical -> term comparison logical
Rule 14    logical -> variable comparison term
Rule 15    logical -> variable comparison BOOLEAN
Rule 16    logical -> logical logcompare logical
Rule 17    logical -> BOOLEAN
Rule 18    comparison -> EQUAL
Rule 19    comparison -> NOTEQ
Rule 20    comparison -> GREATHER
Rule 21    comparison -> LOWER
Rule 22    comparison -> GREATHEREQ
Rule 23    comparison -> LOWEREQ
Rule 24    logcompare -> ANDLOG
Rule 25    logcompare -> ORLOG
Rule 26    logcompare -> NOTLOG
Rule 27    logcompare -> AND
Rule 28    logcompare -> OR
Rule 29    logcompare -> NOT
Rule 30    assign -> variable ASS expr
Rule 31    assign -> variable ASS sexpr
Rule 32    assign -> variable ASS array
Rule 33    math -> term arith term
Rule 34    math -> term arith math
Rule 35    math -> variable asig term
Rule 36    variable -> LOCAL
Rule 37    variable -> GLOBAL
Rule 38    variable -> CONSTANTS
Rule 39    variable -> INSTANCEVAR
Rule 40    variable -> CLASSVAR
Rule 41    asig -> ASS
Rule 42    asig -> ADDASS
Rule 43    asig -> SUBASS
Rule 44    asig -> MULASS
Rule 45    asig -> DIVASS
Rule 46    asig -> MODASS
Rule 47    asig -> EXPASS
Rule 48    expr -> math
Rule 49    expr -> term
Rule 50    expr -> sterm
Rule 51    expr -> variable
Rule 52    expr -> slice
Rule 53    expr -> index
Rule 54    sexpr -> sterm MUL term
Rule 55    sexpr -> sterm ADD sexpr
Rule 56    term -> NUMBER
Rule 57    sterm -> STRING
Rule 58    arith -> EXP
Rule 59    arith -> MUL
Rule 60    arith -> DIV
Rule 61    arith -> MOD
Rule 62    arith -> ADD
Rule 63    arith -> SUB
Rule 64    for -> FOR iterador IN expresiones code END
Rule 65    for -> FOR iterador IN expresiones DO code END
Rule 66    for -> FOR iterador IN array code END
Rule 67    for -> FOR iterador IN array DO code END
Rule 68    salto -> NEWLINE
Rule 69    if -> IF logical expr END
Rule 70    if -> IF logical THEN expr END
Rule 71    if -> IF logical
Rule 72    if -> IF logical THEN
Rule 73    if -> if else
Rule 74    if -> if elsif END
Rule 75    else -> ELSE code END
Rule 76    elsif -> ELSIF logical final
Rule 77    final -> code
Rule 78    final -> THEN code
Rule 79    final -> code else
Rule 80    final -> code elsif
Rule 81    iterador -> variable
Rule 82    iterador -> variable COMA variable
Rule 83    expresiones -> term DOUBLESECUENCEPOINT term
Rule 84    array -> LBRACK defarray RBRACK
Rule 85    defarray -> NUMBER
Rule 86    defarray -> NUMBER COMA defarray
Rule 87    defarray -> STRING
Rule 88    defarray -> STRING COMA defarray
Rule 89    defarray -> INT
Rule 90    defarray -> INT COMA defarray
Rule 91    defarray -> FLOAT
Rule 92    defarray -> FLOAT COMA defarray
Rule 93    defarray -> BOOLEAN
Rule 94    defarray -> BOOLEAN COMA defarray
Rule 95    index -> variable LBRACK INT RBRACK
Rule 96    slice -> variable LBRACK defslice RBRACK
Rule 97    defslice -> INT DOBLEPOINT INT
Rule 98    defslice -> INT DOBLEPOINT
Rule 99    defslice -> DOBLEPOINT INT

Terminals, with rules where they appear

ADD                  : 55 62
ADDASS               : 42
ALIAS                : 
AND                  : 27
ANDLOG               : 24
ASS                  : 30 31 32 41
BEGIN                : 11
BOOLEAN              : 15 17 93 94
BREAK                : 
CASE                 : 
CLASS                : 
CLASSVAR             : 40
COMA                 : 82 86 88 90 92 94
CONSTANTS            : 38
DEF                  : 
DEFINED              : 
DIV                  : 60
DIVASS               : 45
DO                   : 9 65 67
DOBLEPOINT           : 10 97 98 99
DOUBLESECUENCEPOINT  : 83
ELSE                 : 75
ELSIF                : 76
END                  : 8 9 10 11 64 65 66 67 69 70 74 75
ENSURE               : 
EQUAL                : 18
ERROR                : 
EXP                  : 58
EXPASS               : 47
FALSE                : 
FILE                 : 
FLOAT                : 91 92
FOR                  : 64 65 66 67
GLOBAL               : 37
GREATHER             : 20
GREATHEREQ           : 22
IF                   : 69 70 71 72
IN                   : 64 65 66 67
INSTANCEVAR          : 39
INT                  : 89 90 95 97 97 98 99
LBRACK               : 84 95 96
LINE                 : 
LOCAL                : 36
LOWER                : 21
LOWEREQ              : 23
MOD                  : 61
MODASS               : 46
MODULE               : 
MUL                  : 54 59
MULASS               : 44
NEWLINE              : 68
NEXT                 : 
NIL                  : 
NOT                  : 29
NOTEQ                : 19
NOTLOG               : 26
NUMBER               : 56 85 86
OR                   : 28
ORLOG                : 25
PSEUDO               : 
RBRACK               : 84 95 96
REDO                 : 
RESCUE               : 
RETRY                : 
RETURN               : 
SELF                 : 
STRING               : 57 87 88
SUB                  : 63
SUBASS               : 43
SUPER                : 
THEN                 : 70 72 78
TRUE                 : 
UNDEF                : 
UNLESS               : 
UNTIL                : 
WHEN                 : 
WHILE                : 8 9 10 11
YIELD                : 
error                : 

Nonterminals, with rules where they appear

arith                : 33 34
array                : 32 66 67
asig                 : 35
assign               : 6
code                 : 7 7 8 9 10 11 64 65 66 67 75 77 78 79 80 0
comparison           : 12 13 14 15
defarray             : 84 86 88 90 92 94
defslice             : 96
else                 : 73 79
elsif                : 74 80
expr                 : 1 30 69 70
expresiones          : 4 64 65
final                : 76
for                  : 5
if                   : 2 73 74
index                : 53
iterador             : 64 65 66 67
logcompare           : 16
logical              : 8 9 10 11 13 16 16 69 70 71 72 76
math                 : 34 48
salto                : 9 9 10 10
sexpr                : 31 55
slice                : 52
sterm                : 50 54 55
term                 : 12 12 13 14 33 33 34 35 49 54 83 83
variable             : 14 15 30 31 32 35 51 81 82 82 95 96
while                : 3

Parsing method: LALR

state 0

    (0) S' -> . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 14
    WHILE           shift and go to state 15
    BEGIN           shift and go to state 16
    FOR             shift and go to state 17
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

    code                           shift and go to state 1
    expr                           shift and go to state 2
    if                             shift and go to state 3
    while                          shift and go to state 4
    expresiones                    shift and go to state 5
    for                            shift and go to state 6
    assign                         shift and go to state 7
    math                           shift and go to state 8
    term                           shift and go to state 9
    sterm                          shift and go to state 10
    variable                       shift and go to state 11
    slice                          shift and go to state 12
    index                          shift and go to state 13

state 1

    (0) S' -> code .
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 14
    WHILE           shift and go to state 15
    BEGIN           shift and go to state 16
    FOR             shift and go to state 17
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

    code                           shift and go to state 25
    expr                           shift and go to state 2
    if                             shift and go to state 3
    while                          shift and go to state 4
    expresiones                    shift and go to state 5
    for                            shift and go to state 6
    assign                         shift and go to state 7
    math                           shift and go to state 8
    term                           shift and go to state 9
    sterm                          shift and go to state 10
    variable                       shift and go to state 11
    slice                          shift and go to state 12
    index                          shift and go to state 13

state 2

    (1) code -> expr .

    IF              reduce using rule 1 (code -> expr .)
    WHILE           reduce using rule 1 (code -> expr .)
    BEGIN           reduce using rule 1 (code -> expr .)
    FOR             reduce using rule 1 (code -> expr .)
    NUMBER          reduce using rule 1 (code -> expr .)
    STRING          reduce using rule 1 (code -> expr .)
    LOCAL           reduce using rule 1 (code -> expr .)
    GLOBAL          reduce using rule 1 (code -> expr .)
    CONSTANTS       reduce using rule 1 (code -> expr .)
    INSTANCEVAR     reduce using rule 1 (code -> expr .)
    CLASSVAR        reduce using rule 1 (code -> expr .)
    $end            reduce using rule 1 (code -> expr .)
    END             reduce using rule 1 (code -> expr .)
    ELSE            reduce using rule 1 (code -> expr .)
    ELSIF           reduce using rule 1 (code -> expr .)
    NEWLINE         reduce using rule 1 (code -> expr .)


state 3

    (2) code -> if .
    (73) if -> if . else
    (74) if -> if . elsif END
    (75) else -> . ELSE code END
    (76) elsif -> . ELSIF logical final

  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
    IF              reduce using rule 2 (code -> if .)
    WHILE           reduce using rule 2 (code -> if .)
    BEGIN           reduce using rule 2 (code -> if .)
    FOR             reduce using rule 2 (code -> if .)
    NUMBER          reduce using rule 2 (code -> if .)
    STRING          reduce using rule 2 (code -> if .)
    LOCAL           reduce using rule 2 (code -> if .)
    GLOBAL          reduce using rule 2 (code -> if .)
    CONSTANTS       reduce using rule 2 (code -> if .)
    INSTANCEVAR     reduce using rule 2 (code -> if .)
    CLASSVAR        reduce using rule 2 (code -> if .)
    $end            reduce using rule 2 (code -> if .)
    END             reduce using rule 2 (code -> if .)
    NEWLINE         reduce using rule 2 (code -> if .)
    ELSE            shift and go to state 28
    ELSIF           shift and go to state 29

  ! ELSE            [ reduce using rule 2 (code -> if .) ]
  ! ELSIF           [ reduce using rule 2 (code -> if .) ]

    else                           shift and go to state 26
    elsif                          shift and go to state 27

state 4

    (3) code -> while .

    IF              reduce using rule 3 (code -> while .)
    WHILE           reduce using rule 3 (code -> while .)
    BEGIN           reduce using rule 3 (code -> while .)
    FOR             reduce using rule 3 (code -> while .)
    NUMBER          reduce using rule 3 (code -> while .)
    STRING          reduce using rule 3 (code -> while .)
    LOCAL           reduce using rule 3 (code -> while .)
    GLOBAL          reduce using rule 3 (code -> while .)
    CONSTANTS       reduce using rule 3 (code -> while .)
    INSTANCEVAR     reduce using rule 3 (code -> while .)
    CLASSVAR        reduce using rule 3 (code -> while .)
    $end            reduce using rule 3 (code -> while .)
    END             reduce using rule 3 (code -> while .)
    ELSE            reduce using rule 3 (code -> while .)
    ELSIF           reduce using rule 3 (code -> while .)
    NEWLINE         reduce using rule 3 (code -> while .)


state 5

    (4) code -> expresiones .

    IF              reduce using rule 4 (code -> expresiones .)
    WHILE           reduce using rule 4 (code -> expresiones .)
    BEGIN           reduce using rule 4 (code -> expresiones .)
    FOR             reduce using rule 4 (code -> expresiones .)
    NUMBER          reduce using rule 4 (code -> expresiones .)
    STRING          reduce using rule 4 (code -> expresiones .)
    LOCAL           reduce using rule 4 (code -> expresiones .)
    GLOBAL          reduce using rule 4 (code -> expresiones .)
    CONSTANTS       reduce using rule 4 (code -> expresiones .)
    INSTANCEVAR     reduce using rule 4 (code -> expresiones .)
    CLASSVAR        reduce using rule 4 (code -> expresiones .)
    $end            reduce using rule 4 (code -> expresiones .)
    END             reduce using rule 4 (code -> expresiones .)
    ELSE            reduce using rule 4 (code -> expresiones .)
    ELSIF           reduce using rule 4 (code -> expresiones .)
    NEWLINE         reduce using rule 4 (code -> expresiones .)


state 6

    (5) code -> for .

    IF              reduce using rule 5 (code -> for .)
    WHILE           reduce using rule 5 (code -> for .)
    BEGIN           reduce using rule 5 (code -> for .)
    FOR             reduce using rule 5 (code -> for .)
    NUMBER          reduce using rule 5 (code -> for .)
    STRING          reduce using rule 5 (code -> for .)
    LOCAL           reduce using rule 5 (code -> for .)
    GLOBAL          reduce using rule 5 (code -> for .)
    CONSTANTS       reduce using rule 5 (code -> for .)
    INSTANCEVAR     reduce using rule 5 (code -> for .)
    CLASSVAR        reduce using rule 5 (code -> for .)
    $end            reduce using rule 5 (code -> for .)
    END             reduce using rule 5 (code -> for .)
    ELSE            reduce using rule 5 (code -> for .)
    ELSIF           reduce using rule 5 (code -> for .)
    NEWLINE         reduce using rule 5 (code -> for .)


state 7

    (6) code -> assign .

    IF              reduce using rule 6 (code -> assign .)
    WHILE           reduce using rule 6 (code -> assign .)
    BEGIN           reduce using rule 6 (code -> assign .)
    FOR             reduce using rule 6 (code -> assign .)
    NUMBER          reduce using rule 6 (code -> assign .)
    STRING          reduce using rule 6 (code -> assign .)
    LOCAL           reduce using rule 6 (code -> assign .)
    GLOBAL          reduce using rule 6 (code -> assign .)
    CONSTANTS       reduce using rule 6 (code -> assign .)
    INSTANCEVAR     reduce using rule 6 (code -> assign .)
    CLASSVAR        reduce using rule 6 (code -> assign .)
    $end            reduce using rule 6 (code -> assign .)
    END             reduce using rule 6 (code -> assign .)
    ELSE            reduce using rule 6 (code -> assign .)
    ELSIF           reduce using rule 6 (code -> assign .)
    NEWLINE         reduce using rule 6 (code -> assign .)


state 8

    (48) expr -> math .

    IF              reduce using rule 48 (expr -> math .)
    WHILE           reduce using rule 48 (expr -> math .)
    BEGIN           reduce using rule 48 (expr -> math .)
    FOR             reduce using rule 48 (expr -> math .)
    NUMBER          reduce using rule 48 (expr -> math .)
    STRING          reduce using rule 48 (expr -> math .)
    LOCAL           reduce using rule 48 (expr -> math .)
    GLOBAL          reduce using rule 48 (expr -> math .)
    CONSTANTS       reduce using rule 48 (expr -> math .)
    INSTANCEVAR     reduce using rule 48 (expr -> math .)
    CLASSVAR        reduce using rule 48 (expr -> math .)
    $end            reduce using rule 48 (expr -> math .)
    END             reduce using rule 48 (expr -> math .)
    ELSE            reduce using rule 48 (expr -> math .)
    ELSIF           reduce using rule 48 (expr -> math .)
    NEWLINE         reduce using rule 48 (expr -> math .)


state 9

    (49) expr -> term .
    (83) expresiones -> term . DOUBLESECUENCEPOINT term
    (33) math -> term . arith term
    (34) math -> term . arith math
    (58) arith -> . EXP
    (59) arith -> . MUL
    (60) arith -> . DIV
    (61) arith -> . MOD
    (62) arith -> . ADD
    (63) arith -> . SUB

    IF              reduce using rule 49 (expr -> term .)
    WHILE           reduce using rule 49 (expr -> term .)
    BEGIN           reduce using rule 49 (expr -> term .)
    FOR             reduce using rule 49 (expr -> term .)
    NUMBER          reduce using rule 49 (expr -> term .)
    STRING          reduce using rule 49 (expr -> term .)
    LOCAL           reduce using rule 49 (expr -> term .)
    GLOBAL          reduce using rule 49 (expr -> term .)
    CONSTANTS       reduce using rule 49 (expr -> term .)
    INSTANCEVAR     reduce using rule 49 (expr -> term .)
    CLASSVAR        reduce using rule 49 (expr -> term .)
    $end            reduce using rule 49 (expr -> term .)
    END             reduce using rule 49 (expr -> term .)
    ELSE            reduce using rule 49 (expr -> term .)
    ELSIF           reduce using rule 49 (expr -> term .)
    NEWLINE         reduce using rule 49 (expr -> term .)
    DOUBLESECUENCEPOINT shift and go to state 30
    EXP             shift and go to state 32
    MUL             shift and go to state 33
    DIV             shift and go to state 34
    MOD             shift and go to state 35
    ADD             shift and go to state 36
    SUB             shift and go to state 37

    arith                          shift and go to state 31

state 10

    (50) expr -> sterm .

    IF              reduce using rule 50 (expr -> sterm .)
    WHILE           reduce using rule 50 (expr -> sterm .)
    BEGIN           reduce using rule 50 (expr -> sterm .)
    FOR             reduce using rule 50 (expr -> sterm .)
    NUMBER          reduce using rule 50 (expr -> sterm .)
    STRING          reduce using rule 50 (expr -> sterm .)
    LOCAL           reduce using rule 50 (expr -> sterm .)
    GLOBAL          reduce using rule 50 (expr -> sterm .)
    CONSTANTS       reduce using rule 50 (expr -> sterm .)
    INSTANCEVAR     reduce using rule 50 (expr -> sterm .)
    CLASSVAR        reduce using rule 50 (expr -> sterm .)
    $end            reduce using rule 50 (expr -> sterm .)
    END             reduce using rule 50 (expr -> sterm .)
    ELSE            reduce using rule 50 (expr -> sterm .)
    ELSIF           reduce using rule 50 (expr -> sterm .)
    NEWLINE         reduce using rule 50 (expr -> sterm .)


state 11

    (51) expr -> variable .
    (30) assign -> variable . ASS expr
    (31) assign -> variable . ASS sexpr
    (32) assign -> variable . ASS array
    (35) math -> variable . asig term
    (96) slice -> variable . LBRACK defslice RBRACK
    (95) index -> variable . LBRACK INT RBRACK
    (41) asig -> . ASS
    (42) asig -> . ADDASS
    (43) asig -> . SUBASS
    (44) asig -> . MULASS
    (45) asig -> . DIVASS
    (46) asig -> . MODASS
    (47) asig -> . EXPASS

    IF              reduce using rule 51 (expr -> variable .)
    WHILE           reduce using rule 51 (expr -> variable .)
    BEGIN           reduce using rule 51 (expr -> variable .)
    FOR             reduce using rule 51 (expr -> variable .)
    NUMBER          reduce using rule 51 (expr -> variable .)
    STRING          reduce using rule 51 (expr -> variable .)
    LOCAL           reduce using rule 51 (expr -> variable .)
    GLOBAL          reduce using rule 51 (expr -> variable .)
    CONSTANTS       reduce using rule 51 (expr -> variable .)
    INSTANCEVAR     reduce using rule 51 (expr -> variable .)
    CLASSVAR        reduce using rule 51 (expr -> variable .)
    $end            reduce using rule 51 (expr -> variable .)
    END             reduce using rule 51 (expr -> variable .)
    ELSE            reduce using rule 51 (expr -> variable .)
    ELSIF           reduce using rule 51 (expr -> variable .)
    NEWLINE         reduce using rule 51 (expr -> variable .)
    ASS             shift and go to state 38
    LBRACK          shift and go to state 40
    ADDASS          shift and go to state 41
    SUBASS          shift and go to state 42
    MULASS          shift and go to state 43
    DIVASS          shift and go to state 44
    MODASS          shift and go to state 45
    EXPASS          shift and go to state 46

    asig                           shift and go to state 39

state 12

    (52) expr -> slice .

    IF              reduce using rule 52 (expr -> slice .)
    WHILE           reduce using rule 52 (expr -> slice .)
    BEGIN           reduce using rule 52 (expr -> slice .)
    FOR             reduce using rule 52 (expr -> slice .)
    NUMBER          reduce using rule 52 (expr -> slice .)
    STRING          reduce using rule 52 (expr -> slice .)
    LOCAL           reduce using rule 52 (expr -> slice .)
    GLOBAL          reduce using rule 52 (expr -> slice .)
    CONSTANTS       reduce using rule 52 (expr -> slice .)
    INSTANCEVAR     reduce using rule 52 (expr -> slice .)
    CLASSVAR        reduce using rule 52 (expr -> slice .)
    $end            reduce using rule 52 (expr -> slice .)
    END             reduce using rule 52 (expr -> slice .)
    ELSE            reduce using rule 52 (expr -> slice .)
    ELSIF           reduce using rule 52 (expr -> slice .)
    NEWLINE         reduce using rule 52 (expr -> slice .)


state 13

    (53) expr -> index .

    IF              reduce using rule 53 (expr -> index .)
    WHILE           reduce using rule 53 (expr -> index .)
    BEGIN           reduce using rule 53 (expr -> index .)
    FOR             reduce using rule 53 (expr -> index .)
    NUMBER          reduce using rule 53 (expr -> index .)
    STRING          reduce using rule 53 (expr -> index .)
    LOCAL           reduce using rule 53 (expr -> index .)
    GLOBAL          reduce using rule 53 (expr -> index .)
    CONSTANTS       reduce using rule 53 (expr -> index .)
    INSTANCEVAR     reduce using rule 53 (expr -> index .)
    CLASSVAR        reduce using rule 53 (expr -> index .)
    $end            reduce using rule 53 (expr -> index .)
    END             reduce using rule 53 (expr -> index .)
    ELSE            reduce using rule 53 (expr -> index .)
    ELSIF           reduce using rule 53 (expr -> index .)
    NEWLINE         reduce using rule 53 (expr -> index .)


state 14

    (69) if -> IF . logical expr END
    (70) if -> IF . logical THEN expr END
    (71) if -> IF . logical
    (72) if -> IF . logical THEN
    (12) logical -> . term comparison term
    (13) logical -> . term comparison logical
    (14) logical -> . variable comparison term
    (15) logical -> . variable comparison BOOLEAN
    (16) logical -> . logical logcompare logical
    (17) logical -> . BOOLEAN
    (56) term -> . NUMBER
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR

    BOOLEAN         shift and go to state 50
    NUMBER          shift and go to state 18
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

    logical                        shift and go to state 47
    term                           shift and go to state 48
    variable                       shift and go to state 49

state 15

    (8) while -> WHILE . logical code END
    (9) while -> WHILE . logical DO salto code salto END
    (10) while -> WHILE . logical DOBLEPOINT salto code salto END
    (12) logical -> . term comparison term
    (13) logical -> . term comparison logical
    (14) logical -> . variable comparison term
    (15) logical -> . variable comparison BOOLEAN
    (16) logical -> . logical logcompare logical
    (17) logical -> . BOOLEAN
    (56) term -> . NUMBER
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR

    BOOLEAN         shift and go to state 50
    NUMBER          shift and go to state 18
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

    logical                        shift and go to state 51
    term                           shift and go to state 48
    variable                       shift and go to state 49

state 16

    (11) while -> BEGIN . code END WHILE logical
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 14
    WHILE           shift and go to state 15
    BEGIN           shift and go to state 16
    FOR             shift and go to state 17
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

    code                           shift and go to state 52
    expr                           shift and go to state 2
    if                             shift and go to state 3
    while                          shift and go to state 4
    expresiones                    shift and go to state 5
    for                            shift and go to state 6
    assign                         shift and go to state 7
    math                           shift and go to state 8
    term                           shift and go to state 9
    sterm                          shift and go to state 10
    variable                       shift and go to state 11
    slice                          shift and go to state 12
    index                          shift and go to state 13

state 17

    (64) for -> FOR . iterador IN expresiones code END
    (65) for -> FOR . iterador IN expresiones DO code END
    (66) for -> FOR . iterador IN array code END
    (67) for -> FOR . iterador IN array DO code END
    (81) iterador -> . variable
    (82) iterador -> . variable COMA variable
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR

    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

    iterador                       shift and go to state 53
    variable                       shift and go to state 54

state 18

    (56) term -> NUMBER .

    DOUBLESECUENCEPOINT reduce using rule 56 (term -> NUMBER .)
    EXP             reduce using rule 56 (term -> NUMBER .)
    MUL             reduce using rule 56 (term -> NUMBER .)
    DIV             reduce using rule 56 (term -> NUMBER .)
    MOD             reduce using rule 56 (term -> NUMBER .)
    ADD             reduce using rule 56 (term -> NUMBER .)
    SUB             reduce using rule 56 (term -> NUMBER .)
    IF              reduce using rule 56 (term -> NUMBER .)
    WHILE           reduce using rule 56 (term -> NUMBER .)
    BEGIN           reduce using rule 56 (term -> NUMBER .)
    FOR             reduce using rule 56 (term -> NUMBER .)
    NUMBER          reduce using rule 56 (term -> NUMBER .)
    STRING          reduce using rule 56 (term -> NUMBER .)
    LOCAL           reduce using rule 56 (term -> NUMBER .)
    GLOBAL          reduce using rule 56 (term -> NUMBER .)
    CONSTANTS       reduce using rule 56 (term -> NUMBER .)
    INSTANCEVAR     reduce using rule 56 (term -> NUMBER .)
    CLASSVAR        reduce using rule 56 (term -> NUMBER .)
    $end            reduce using rule 56 (term -> NUMBER .)
    EQUAL           reduce using rule 56 (term -> NUMBER .)
    NOTEQ           reduce using rule 56 (term -> NUMBER .)
    GREATHER        reduce using rule 56 (term -> NUMBER .)
    LOWER           reduce using rule 56 (term -> NUMBER .)
    GREATHEREQ      reduce using rule 56 (term -> NUMBER .)
    LOWEREQ         reduce using rule 56 (term -> NUMBER .)
    END             reduce using rule 56 (term -> NUMBER .)
    ELSE            reduce using rule 56 (term -> NUMBER .)
    ELSIF           reduce using rule 56 (term -> NUMBER .)
    NEWLINE         reduce using rule 56 (term -> NUMBER .)
    DO              reduce using rule 56 (term -> NUMBER .)
    THEN            reduce using rule 56 (term -> NUMBER .)
    ANDLOG          reduce using rule 56 (term -> NUMBER .)
    ORLOG           reduce using rule 56 (term -> NUMBER .)
    NOTLOG          reduce using rule 56 (term -> NUMBER .)
    AND             reduce using rule 56 (term -> NUMBER .)
    OR              reduce using rule 56 (term -> NUMBER .)
    NOT             reduce using rule 56 (term -> NUMBER .)
    DOBLEPOINT      reduce using rule 56 (term -> NUMBER .)


state 19

    (57) sterm -> STRING .

    IF              reduce using rule 57 (sterm -> STRING .)
    WHILE           reduce using rule 57 (sterm -> STRING .)
    BEGIN           reduce using rule 57 (sterm -> STRING .)
    FOR             reduce using rule 57 (sterm -> STRING .)
    NUMBER          reduce using rule 57 (sterm -> STRING .)
    STRING          reduce using rule 57 (sterm -> STRING .)
    LOCAL           reduce using rule 57 (sterm -> STRING .)
    GLOBAL          reduce using rule 57 (sterm -> STRING .)
    CONSTANTS       reduce using rule 57 (sterm -> STRING .)
    INSTANCEVAR     reduce using rule 57 (sterm -> STRING .)
    CLASSVAR        reduce using rule 57 (sterm -> STRING .)
    $end            reduce using rule 57 (sterm -> STRING .)
    END             reduce using rule 57 (sterm -> STRING .)
    ELSE            reduce using rule 57 (sterm -> STRING .)
    ELSIF           reduce using rule 57 (sterm -> STRING .)
    NEWLINE         reduce using rule 57 (sterm -> STRING .)
    MUL             reduce using rule 57 (sterm -> STRING .)
    ADD             reduce using rule 57 (sterm -> STRING .)


state 20

    (36) variable -> LOCAL .

    ASS             reduce using rule 36 (variable -> LOCAL .)
    LBRACK          reduce using rule 36 (variable -> LOCAL .)
    ADDASS          reduce using rule 36 (variable -> LOCAL .)
    SUBASS          reduce using rule 36 (variable -> LOCAL .)
    MULASS          reduce using rule 36 (variable -> LOCAL .)
    DIVASS          reduce using rule 36 (variable -> LOCAL .)
    MODASS          reduce using rule 36 (variable -> LOCAL .)
    EXPASS          reduce using rule 36 (variable -> LOCAL .)
    IF              reduce using rule 36 (variable -> LOCAL .)
    WHILE           reduce using rule 36 (variable -> LOCAL .)
    BEGIN           reduce using rule 36 (variable -> LOCAL .)
    FOR             reduce using rule 36 (variable -> LOCAL .)
    NUMBER          reduce using rule 36 (variable -> LOCAL .)
    STRING          reduce using rule 36 (variable -> LOCAL .)
    LOCAL           reduce using rule 36 (variable -> LOCAL .)
    GLOBAL          reduce using rule 36 (variable -> LOCAL .)
    CONSTANTS       reduce using rule 36 (variable -> LOCAL .)
    INSTANCEVAR     reduce using rule 36 (variable -> LOCAL .)
    CLASSVAR        reduce using rule 36 (variable -> LOCAL .)
    $end            reduce using rule 36 (variable -> LOCAL .)
    EQUAL           reduce using rule 36 (variable -> LOCAL .)
    NOTEQ           reduce using rule 36 (variable -> LOCAL .)
    GREATHER        reduce using rule 36 (variable -> LOCAL .)
    LOWER           reduce using rule 36 (variable -> LOCAL .)
    GREATHEREQ      reduce using rule 36 (variable -> LOCAL .)
    LOWEREQ         reduce using rule 36 (variable -> LOCAL .)
    END             reduce using rule 36 (variable -> LOCAL .)
    COMA            reduce using rule 36 (variable -> LOCAL .)
    IN              reduce using rule 36 (variable -> LOCAL .)
    ELSE            reduce using rule 36 (variable -> LOCAL .)
    ELSIF           reduce using rule 36 (variable -> LOCAL .)
    NEWLINE         reduce using rule 36 (variable -> LOCAL .)


state 21

    (37) variable -> GLOBAL .

    ASS             reduce using rule 37 (variable -> GLOBAL .)
    LBRACK          reduce using rule 37 (variable -> GLOBAL .)
    ADDASS          reduce using rule 37 (variable -> GLOBAL .)
    SUBASS          reduce using rule 37 (variable -> GLOBAL .)
    MULASS          reduce using rule 37 (variable -> GLOBAL .)
    DIVASS          reduce using rule 37 (variable -> GLOBAL .)
    MODASS          reduce using rule 37 (variable -> GLOBAL .)
    EXPASS          reduce using rule 37 (variable -> GLOBAL .)
    IF              reduce using rule 37 (variable -> GLOBAL .)
    WHILE           reduce using rule 37 (variable -> GLOBAL .)
    BEGIN           reduce using rule 37 (variable -> GLOBAL .)
    FOR             reduce using rule 37 (variable -> GLOBAL .)
    NUMBER          reduce using rule 37 (variable -> GLOBAL .)
    STRING          reduce using rule 37 (variable -> GLOBAL .)
    LOCAL           reduce using rule 37 (variable -> GLOBAL .)
    GLOBAL          reduce using rule 37 (variable -> GLOBAL .)
    CONSTANTS       reduce using rule 37 (variable -> GLOBAL .)
    INSTANCEVAR     reduce using rule 37 (variable -> GLOBAL .)
    CLASSVAR        reduce using rule 37 (variable -> GLOBAL .)
    $end            reduce using rule 37 (variable -> GLOBAL .)
    EQUAL           reduce using rule 37 (variable -> GLOBAL .)
    NOTEQ           reduce using rule 37 (variable -> GLOBAL .)
    GREATHER        reduce using rule 37 (variable -> GLOBAL .)
    LOWER           reduce using rule 37 (variable -> GLOBAL .)
    GREATHEREQ      reduce using rule 37 (variable -> GLOBAL .)
    LOWEREQ         reduce using rule 37 (variable -> GLOBAL .)
    END             reduce using rule 37 (variable -> GLOBAL .)
    COMA            reduce using rule 37 (variable -> GLOBAL .)
    IN              reduce using rule 37 (variable -> GLOBAL .)
    ELSE            reduce using rule 37 (variable -> GLOBAL .)
    ELSIF           reduce using rule 37 (variable -> GLOBAL .)
    NEWLINE         reduce using rule 37 (variable -> GLOBAL .)


state 22

    (38) variable -> CONSTANTS .

    ASS             reduce using rule 38 (variable -> CONSTANTS .)
    LBRACK          reduce using rule 38 (variable -> CONSTANTS .)
    ADDASS          reduce using rule 38 (variable -> CONSTANTS .)
    SUBASS          reduce using rule 38 (variable -> CONSTANTS .)
    MULASS          reduce using rule 38 (variable -> CONSTANTS .)
    DIVASS          reduce using rule 38 (variable -> CONSTANTS .)
    MODASS          reduce using rule 38 (variable -> CONSTANTS .)
    EXPASS          reduce using rule 38 (variable -> CONSTANTS .)
    IF              reduce using rule 38 (variable -> CONSTANTS .)
    WHILE           reduce using rule 38 (variable -> CONSTANTS .)
    BEGIN           reduce using rule 38 (variable -> CONSTANTS .)
    FOR             reduce using rule 38 (variable -> CONSTANTS .)
    NUMBER          reduce using rule 38 (variable -> CONSTANTS .)
    STRING          reduce using rule 38 (variable -> CONSTANTS .)
    LOCAL           reduce using rule 38 (variable -> CONSTANTS .)
    GLOBAL          reduce using rule 38 (variable -> CONSTANTS .)
    CONSTANTS       reduce using rule 38 (variable -> CONSTANTS .)
    INSTANCEVAR     reduce using rule 38 (variable -> CONSTANTS .)
    CLASSVAR        reduce using rule 38 (variable -> CONSTANTS .)
    $end            reduce using rule 38 (variable -> CONSTANTS .)
    EQUAL           reduce using rule 38 (variable -> CONSTANTS .)
    NOTEQ           reduce using rule 38 (variable -> CONSTANTS .)
    GREATHER        reduce using rule 38 (variable -> CONSTANTS .)
    LOWER           reduce using rule 38 (variable -> CONSTANTS .)
    GREATHEREQ      reduce using rule 38 (variable -> CONSTANTS .)
    LOWEREQ         reduce using rule 38 (variable -> CONSTANTS .)
    END             reduce using rule 38 (variable -> CONSTANTS .)
    COMA            reduce using rule 38 (variable -> CONSTANTS .)
    IN              reduce using rule 38 (variable -> CONSTANTS .)
    ELSE            reduce using rule 38 (variable -> CONSTANTS .)
    ELSIF           reduce using rule 38 (variable -> CONSTANTS .)
    NEWLINE         reduce using rule 38 (variable -> CONSTANTS .)


state 23

    (39) variable -> INSTANCEVAR .

    ASS             reduce using rule 39 (variable -> INSTANCEVAR .)
    LBRACK          reduce using rule 39 (variable -> INSTANCEVAR .)
    ADDASS          reduce using rule 39 (variable -> INSTANCEVAR .)
    SUBASS          reduce using rule 39 (variable -> INSTANCEVAR .)
    MULASS          reduce using rule 39 (variable -> INSTANCEVAR .)
    DIVASS          reduce using rule 39 (variable -> INSTANCEVAR .)
    MODASS          reduce using rule 39 (variable -> INSTANCEVAR .)
    EXPASS          reduce using rule 39 (variable -> INSTANCEVAR .)
    IF              reduce using rule 39 (variable -> INSTANCEVAR .)
    WHILE           reduce using rule 39 (variable -> INSTANCEVAR .)
    BEGIN           reduce using rule 39 (variable -> INSTANCEVAR .)
    FOR             reduce using rule 39 (variable -> INSTANCEVAR .)
    NUMBER          reduce using rule 39 (variable -> INSTANCEVAR .)
    STRING          reduce using rule 39 (variable -> INSTANCEVAR .)
    LOCAL           reduce using rule 39 (variable -> INSTANCEVAR .)
    GLOBAL          reduce using rule 39 (variable -> INSTANCEVAR .)
    CONSTANTS       reduce using rule 39 (variable -> INSTANCEVAR .)
    INSTANCEVAR     reduce using rule 39 (variable -> INSTANCEVAR .)
    CLASSVAR        reduce using rule 39 (variable -> INSTANCEVAR .)
    $end            reduce using rule 39 (variable -> INSTANCEVAR .)
    EQUAL           reduce using rule 39 (variable -> INSTANCEVAR .)
    NOTEQ           reduce using rule 39 (variable -> INSTANCEVAR .)
    GREATHER        reduce using rule 39 (variable -> INSTANCEVAR .)
    LOWER           reduce using rule 39 (variable -> INSTANCEVAR .)
    GREATHEREQ      reduce using rule 39 (variable -> INSTANCEVAR .)
    LOWEREQ         reduce using rule 39 (variable -> INSTANCEVAR .)
    END             reduce using rule 39 (variable -> INSTANCEVAR .)
    COMA            reduce using rule 39 (variable -> INSTANCEVAR .)
    IN              reduce using rule 39 (variable -> INSTANCEVAR .)
    ELSE            reduce using rule 39 (variable -> INSTANCEVAR .)
    ELSIF           reduce using rule 39 (variable -> INSTANCEVAR .)
    NEWLINE         reduce using rule 39 (variable -> INSTANCEVAR .)


state 24

    (40) variable -> CLASSVAR .

    ASS             reduce using rule 40 (variable -> CLASSVAR .)
    LBRACK          reduce using rule 40 (variable -> CLASSVAR .)
    ADDASS          reduce using rule 40 (variable -> CLASSVAR .)
    SUBASS          reduce using rule 40 (variable -> CLASSVAR .)
    MULASS          reduce using rule 40 (variable -> CLASSVAR .)
    DIVASS          reduce using rule 40 (variable -> CLASSVAR .)
    MODASS          reduce using rule 40 (variable -> CLASSVAR .)
    EXPASS          reduce using rule 40 (variable -> CLASSVAR .)
    IF              reduce using rule 40 (variable -> CLASSVAR .)
    WHILE           reduce using rule 40 (variable -> CLASSVAR .)
    BEGIN           reduce using rule 40 (variable -> CLASSVAR .)
    FOR             reduce using rule 40 (variable -> CLASSVAR .)
    NUMBER          reduce using rule 40 (variable -> CLASSVAR .)
    STRING          reduce using rule 40 (variable -> CLASSVAR .)
    LOCAL           reduce using rule 40 (variable -> CLASSVAR .)
    GLOBAL          reduce using rule 40 (variable -> CLASSVAR .)
    CONSTANTS       reduce using rule 40 (variable -> CLASSVAR .)
    INSTANCEVAR     reduce using rule 40 (variable -> CLASSVAR .)
    CLASSVAR        reduce using rule 40 (variable -> CLASSVAR .)
    $end            reduce using rule 40 (variable -> CLASSVAR .)
    EQUAL           reduce using rule 40 (variable -> CLASSVAR .)
    NOTEQ           reduce using rule 40 (variable -> CLASSVAR .)
    GREATHER        reduce using rule 40 (variable -> CLASSVAR .)
    LOWER           reduce using rule 40 (variable -> CLASSVAR .)
    GREATHEREQ      reduce using rule 40 (variable -> CLASSVAR .)
    LOWEREQ         reduce using rule 40 (variable -> CLASSVAR .)
    END             reduce using rule 40 (variable -> CLASSVAR .)
    COMA            reduce using rule 40 (variable -> CLASSVAR .)
    IN              reduce using rule 40 (variable -> CLASSVAR .)
    ELSE            reduce using rule 40 (variable -> CLASSVAR .)
    ELSIF           reduce using rule 40 (variable -> CLASSVAR .)
    NEWLINE         reduce using rule 40 (variable -> CLASSVAR .)


state 25

    (7) code -> code code .
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for LOCAL resolved as shift
  ! shift/reduce conflict for GLOBAL resolved as shift
  ! shift/reduce conflict for CONSTANTS resolved as shift
  ! shift/reduce conflict for INSTANCEVAR resolved as shift
  ! shift/reduce conflict for CLASSVAR resolved as shift
    $end            reduce using rule 7 (code -> code code .)
    END             reduce using rule 7 (code -> code code .)
    ELSE            reduce using rule 7 (code -> code code .)
    ELSIF           reduce using rule 7 (code -> code code .)
    NEWLINE         reduce using rule 7 (code -> code code .)
    IF              shift and go to state 14
    WHILE           shift and go to state 15
    BEGIN           shift and go to state 16
    FOR             shift and go to state 17
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

  ! IF              [ reduce using rule 7 (code -> code code .) ]
  ! WHILE           [ reduce using rule 7 (code -> code code .) ]
  ! BEGIN           [ reduce using rule 7 (code -> code code .) ]
  ! FOR             [ reduce using rule 7 (code -> code code .) ]
  ! NUMBER          [ reduce using rule 7 (code -> code code .) ]
  ! STRING          [ reduce using rule 7 (code -> code code .) ]
  ! LOCAL           [ reduce using rule 7 (code -> code code .) ]
  ! GLOBAL          [ reduce using rule 7 (code -> code code .) ]
  ! CONSTANTS       [ reduce using rule 7 (code -> code code .) ]
  ! INSTANCEVAR     [ reduce using rule 7 (code -> code code .) ]
  ! CLASSVAR        [ reduce using rule 7 (code -> code code .) ]

    code                           shift and go to state 25
    expr                           shift and go to state 2
    if                             shift and go to state 3
    while                          shift and go to state 4
    expresiones                    shift and go to state 5
    for                            shift and go to state 6
    assign                         shift and go to state 7
    math                           shift and go to state 8
    term                           shift and go to state 9
    sterm                          shift and go to state 10
    variable                       shift and go to state 11
    slice                          shift and go to state 12
    index                          shift and go to state 13

state 26

    (73) if -> if else .

    ELSE            reduce using rule 73 (if -> if else .)
    ELSIF           reduce using rule 73 (if -> if else .)
    IF              reduce using rule 73 (if -> if else .)
    WHILE           reduce using rule 73 (if -> if else .)
    BEGIN           reduce using rule 73 (if -> if else .)
    FOR             reduce using rule 73 (if -> if else .)
    NUMBER          reduce using rule 73 (if -> if else .)
    STRING          reduce using rule 73 (if -> if else .)
    LOCAL           reduce using rule 73 (if -> if else .)
    GLOBAL          reduce using rule 73 (if -> if else .)
    CONSTANTS       reduce using rule 73 (if -> if else .)
    INSTANCEVAR     reduce using rule 73 (if -> if else .)
    CLASSVAR        reduce using rule 73 (if -> if else .)
    $end            reduce using rule 73 (if -> if else .)
    END             reduce using rule 73 (if -> if else .)
    NEWLINE         reduce using rule 73 (if -> if else .)


state 27

    (74) if -> if elsif . END

    END             shift and go to state 55


state 28

    (75) else -> ELSE . code END
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 14
    WHILE           shift and go to state 15
    BEGIN           shift and go to state 16
    FOR             shift and go to state 17
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

    code                           shift and go to state 56
    expr                           shift and go to state 2
    if                             shift and go to state 3
    while                          shift and go to state 4
    expresiones                    shift and go to state 5
    for                            shift and go to state 6
    assign                         shift and go to state 7
    math                           shift and go to state 8
    term                           shift and go to state 9
    sterm                          shift and go to state 10
    variable                       shift and go to state 11
    slice                          shift and go to state 12
    index                          shift and go to state 13

state 29

    (76) elsif -> ELSIF . logical final
    (12) logical -> . term comparison term
    (13) logical -> . term comparison logical
    (14) logical -> . variable comparison term
    (15) logical -> . variable comparison BOOLEAN
    (16) logical -> . logical logcompare logical
    (17) logical -> . BOOLEAN
    (56) term -> . NUMBER
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR

    BOOLEAN         shift and go to state 50
    NUMBER          shift and go to state 18
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

    logical                        shift and go to state 57
    term                           shift and go to state 48
    variable                       shift and go to state 49

state 30

    (83) expresiones -> term DOUBLESECUENCEPOINT . term
    (56) term -> . NUMBER

    NUMBER          shift and go to state 18

    term                           shift and go to state 58

state 31

    (33) math -> term arith . term
    (34) math -> term arith . math
    (56) term -> . NUMBER
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR

    NUMBER          shift and go to state 18
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

    term                           shift and go to state 59
    math                           shift and go to state 60
    variable                       shift and go to state 61

state 32

    (58) arith -> EXP .

    NUMBER          reduce using rule 58 (arith -> EXP .)
    LOCAL           reduce using rule 58 (arith -> EXP .)
    GLOBAL          reduce using rule 58 (arith -> EXP .)
    CONSTANTS       reduce using rule 58 (arith -> EXP .)
    INSTANCEVAR     reduce using rule 58 (arith -> EXP .)
    CLASSVAR        reduce using rule 58 (arith -> EXP .)


state 33

    (59) arith -> MUL .

    NUMBER          reduce using rule 59 (arith -> MUL .)
    LOCAL           reduce using rule 59 (arith -> MUL .)
    GLOBAL          reduce using rule 59 (arith -> MUL .)
    CONSTANTS       reduce using rule 59 (arith -> MUL .)
    INSTANCEVAR     reduce using rule 59 (arith -> MUL .)
    CLASSVAR        reduce using rule 59 (arith -> MUL .)


state 34

    (60) arith -> DIV .

    NUMBER          reduce using rule 60 (arith -> DIV .)
    LOCAL           reduce using rule 60 (arith -> DIV .)
    GLOBAL          reduce using rule 60 (arith -> DIV .)
    CONSTANTS       reduce using rule 60 (arith -> DIV .)
    INSTANCEVAR     reduce using rule 60 (arith -> DIV .)
    CLASSVAR        reduce using rule 60 (arith -> DIV .)


state 35

    (61) arith -> MOD .

    NUMBER          reduce using rule 61 (arith -> MOD .)
    LOCAL           reduce using rule 61 (arith -> MOD .)
    GLOBAL          reduce using rule 61 (arith -> MOD .)
    CONSTANTS       reduce using rule 61 (arith -> MOD .)
    INSTANCEVAR     reduce using rule 61 (arith -> MOD .)
    CLASSVAR        reduce using rule 61 (arith -> MOD .)


state 36

    (62) arith -> ADD .

    NUMBER          reduce using rule 62 (arith -> ADD .)
    LOCAL           reduce using rule 62 (arith -> ADD .)
    GLOBAL          reduce using rule 62 (arith -> ADD .)
    CONSTANTS       reduce using rule 62 (arith -> ADD .)
    INSTANCEVAR     reduce using rule 62 (arith -> ADD .)
    CLASSVAR        reduce using rule 62 (arith -> ADD .)


state 37

    (63) arith -> SUB .

    NUMBER          reduce using rule 63 (arith -> SUB .)
    LOCAL           reduce using rule 63 (arith -> SUB .)
    GLOBAL          reduce using rule 63 (arith -> SUB .)
    CONSTANTS       reduce using rule 63 (arith -> SUB .)
    INSTANCEVAR     reduce using rule 63 (arith -> SUB .)
    CLASSVAR        reduce using rule 63 (arith -> SUB .)


state 38

    (30) assign -> variable ASS . expr
    (31) assign -> variable ASS . sexpr
    (32) assign -> variable ASS . array
    (41) asig -> ASS .
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (54) sexpr -> . sterm MUL term
    (55) sexpr -> . sterm ADD sexpr
    (84) array -> . LBRACK defarray RBRACK
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

  ! shift/reduce conflict for NUMBER resolved as shift
    LBRACK          shift and go to state 68
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

  ! NUMBER          [ reduce using rule 41 (asig -> ASS .) ]

    variable                       shift and go to state 62
    expr                           shift and go to state 63
    sexpr                          shift and go to state 64
    array                          shift and go to state 65
    math                           shift and go to state 8
    term                           shift and go to state 66
    sterm                          shift and go to state 67
    slice                          shift and go to state 12
    index                          shift and go to state 13

state 39

    (35) math -> variable asig . term
    (56) term -> . NUMBER

    NUMBER          shift and go to state 18

    term                           shift and go to state 69

state 40

    (96) slice -> variable LBRACK . defslice RBRACK
    (95) index -> variable LBRACK . INT RBRACK
    (97) defslice -> . INT DOBLEPOINT INT
    (98) defslice -> . INT DOBLEPOINT
    (99) defslice -> . DOBLEPOINT INT

    INT             shift and go to state 71
    DOBLEPOINT      shift and go to state 72

    defslice                       shift and go to state 70

state 41

    (42) asig -> ADDASS .

    NUMBER          reduce using rule 42 (asig -> ADDASS .)


state 42

    (43) asig -> SUBASS .

    NUMBER          reduce using rule 43 (asig -> SUBASS .)


state 43

    (44) asig -> MULASS .

    NUMBER          reduce using rule 44 (asig -> MULASS .)


state 44

    (45) asig -> DIVASS .

    NUMBER          reduce using rule 45 (asig -> DIVASS .)


state 45

    (46) asig -> MODASS .

    NUMBER          reduce using rule 46 (asig -> MODASS .)


state 46

    (47) asig -> EXPASS .

    NUMBER          reduce using rule 47 (asig -> EXPASS .)


state 47

    (69) if -> IF logical . expr END
    (70) if -> IF logical . THEN expr END
    (71) if -> IF logical .
    (72) if -> IF logical . THEN
    (16) logical -> logical . logcompare logical
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (24) logcompare -> . ANDLOG
    (25) logcompare -> . ORLOG
    (26) logcompare -> . NOTLOG
    (27) logcompare -> . AND
    (28) logcompare -> . OR
    (29) logcompare -> . NOT
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for LOCAL resolved as shift
  ! shift/reduce conflict for GLOBAL resolved as shift
  ! shift/reduce conflict for CONSTANTS resolved as shift
  ! shift/reduce conflict for INSTANCEVAR resolved as shift
  ! shift/reduce conflict for CLASSVAR resolved as shift
    THEN            shift and go to state 74
    ELSE            reduce using rule 71 (if -> IF logical .)
    ELSIF           reduce using rule 71 (if -> IF logical .)
    IF              reduce using rule 71 (if -> IF logical .)
    WHILE           reduce using rule 71 (if -> IF logical .)
    BEGIN           reduce using rule 71 (if -> IF logical .)
    FOR             reduce using rule 71 (if -> IF logical .)
    $end            reduce using rule 71 (if -> IF logical .)
    END             reduce using rule 71 (if -> IF logical .)
    NEWLINE         reduce using rule 71 (if -> IF logical .)
    ANDLOG          shift and go to state 76
    ORLOG           shift and go to state 77
    NOTLOG          shift and go to state 78
    AND             shift and go to state 79
    OR              shift and go to state 80
    NOT             shift and go to state 81
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

  ! NUMBER          [ reduce using rule 71 (if -> IF logical .) ]
  ! STRING          [ reduce using rule 71 (if -> IF logical .) ]
  ! LOCAL           [ reduce using rule 71 (if -> IF logical .) ]
  ! GLOBAL          [ reduce using rule 71 (if -> IF logical .) ]
  ! CONSTANTS       [ reduce using rule 71 (if -> IF logical .) ]
  ! INSTANCEVAR     [ reduce using rule 71 (if -> IF logical .) ]
  ! CLASSVAR        [ reduce using rule 71 (if -> IF logical .) ]

    expr                           shift and go to state 73
    logcompare                     shift and go to state 75
    math                           shift and go to state 8
    term                           shift and go to state 66
    sterm                          shift and go to state 10
    variable                       shift and go to state 62
    slice                          shift and go to state 12
    index                          shift and go to state 13

state 48

    (12) logical -> term . comparison term
    (13) logical -> term . comparison logical
    (18) comparison -> . EQUAL
    (19) comparison -> . NOTEQ
    (20) comparison -> . GREATHER
    (21) comparison -> . LOWER
    (22) comparison -> . GREATHEREQ
    (23) comparison -> . LOWEREQ

    EQUAL           shift and go to state 83
    NOTEQ           shift and go to state 84
    GREATHER        shift and go to state 85
    LOWER           shift and go to state 86
    GREATHEREQ      shift and go to state 87
    LOWEREQ         shift and go to state 88

    comparison                     shift and go to state 82

state 49

    (14) logical -> variable . comparison term
    (15) logical -> variable . comparison BOOLEAN
    (18) comparison -> . EQUAL
    (19) comparison -> . NOTEQ
    (20) comparison -> . GREATHER
    (21) comparison -> . LOWER
    (22) comparison -> . GREATHEREQ
    (23) comparison -> . LOWEREQ

    EQUAL           shift and go to state 83
    NOTEQ           shift and go to state 84
    GREATHER        shift and go to state 85
    LOWER           shift and go to state 86
    GREATHEREQ      shift and go to state 87
    LOWEREQ         shift and go to state 88

    comparison                     shift and go to state 89

state 50

    (17) logical -> BOOLEAN .

    THEN            reduce using rule 17 (logical -> BOOLEAN .)
    ANDLOG          reduce using rule 17 (logical -> BOOLEAN .)
    ORLOG           reduce using rule 17 (logical -> BOOLEAN .)
    NOTLOG          reduce using rule 17 (logical -> BOOLEAN .)
    AND             reduce using rule 17 (logical -> BOOLEAN .)
    OR              reduce using rule 17 (logical -> BOOLEAN .)
    NOT             reduce using rule 17 (logical -> BOOLEAN .)
    NUMBER          reduce using rule 17 (logical -> BOOLEAN .)
    STRING          reduce using rule 17 (logical -> BOOLEAN .)
    LOCAL           reduce using rule 17 (logical -> BOOLEAN .)
    GLOBAL          reduce using rule 17 (logical -> BOOLEAN .)
    CONSTANTS       reduce using rule 17 (logical -> BOOLEAN .)
    INSTANCEVAR     reduce using rule 17 (logical -> BOOLEAN .)
    CLASSVAR        reduce using rule 17 (logical -> BOOLEAN .)
    ELSE            reduce using rule 17 (logical -> BOOLEAN .)
    ELSIF           reduce using rule 17 (logical -> BOOLEAN .)
    IF              reduce using rule 17 (logical -> BOOLEAN .)
    WHILE           reduce using rule 17 (logical -> BOOLEAN .)
    BEGIN           reduce using rule 17 (logical -> BOOLEAN .)
    FOR             reduce using rule 17 (logical -> BOOLEAN .)
    $end            reduce using rule 17 (logical -> BOOLEAN .)
    END             reduce using rule 17 (logical -> BOOLEAN .)
    NEWLINE         reduce using rule 17 (logical -> BOOLEAN .)
    DO              reduce using rule 17 (logical -> BOOLEAN .)
    DOBLEPOINT      reduce using rule 17 (logical -> BOOLEAN .)


state 51

    (8) while -> WHILE logical . code END
    (9) while -> WHILE logical . DO salto code salto END
    (10) while -> WHILE logical . DOBLEPOINT salto code salto END
    (16) logical -> logical . logcompare logical
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (24) logcompare -> . ANDLOG
    (25) logcompare -> . ORLOG
    (26) logcompare -> . NOTLOG
    (27) logcompare -> . AND
    (28) logcompare -> . OR
    (29) logcompare -> . NOT
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    DO              shift and go to state 91
    DOBLEPOINT      shift and go to state 92
    ANDLOG          shift and go to state 76
    ORLOG           shift and go to state 77
    NOTLOG          shift and go to state 78
    AND             shift and go to state 79
    OR              shift and go to state 80
    NOT             shift and go to state 81
    IF              shift and go to state 14
    WHILE           shift and go to state 15
    BEGIN           shift and go to state 16
    FOR             shift and go to state 17
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

    code                           shift and go to state 90
    logcompare                     shift and go to state 75
    expr                           shift and go to state 2
    if                             shift and go to state 3
    while                          shift and go to state 4
    expresiones                    shift and go to state 5
    for                            shift and go to state 6
    assign                         shift and go to state 7
    math                           shift and go to state 8
    term                           shift and go to state 9
    sterm                          shift and go to state 10
    variable                       shift and go to state 11
    slice                          shift and go to state 12
    index                          shift and go to state 13

state 52

    (11) while -> BEGIN code . END WHILE logical
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    END             shift and go to state 93
    IF              shift and go to state 14
    WHILE           shift and go to state 15
    BEGIN           shift and go to state 16
    FOR             shift and go to state 17
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

    code                           shift and go to state 25
    expr                           shift and go to state 2
    if                             shift and go to state 3
    while                          shift and go to state 4
    expresiones                    shift and go to state 5
    for                            shift and go to state 6
    assign                         shift and go to state 7
    math                           shift and go to state 8
    term                           shift and go to state 9
    sterm                          shift and go to state 10
    variable                       shift and go to state 11
    slice                          shift and go to state 12
    index                          shift and go to state 13

state 53

    (64) for -> FOR iterador . IN expresiones code END
    (65) for -> FOR iterador . IN expresiones DO code END
    (66) for -> FOR iterador . IN array code END
    (67) for -> FOR iterador . IN array DO code END

    IN              shift and go to state 94


state 54

    (81) iterador -> variable .
    (82) iterador -> variable . COMA variable

    IN              reduce using rule 81 (iterador -> variable .)
    COMA            shift and go to state 95


state 55

    (74) if -> if elsif END .

    ELSE            reduce using rule 74 (if -> if elsif END .)
    ELSIF           reduce using rule 74 (if -> if elsif END .)
    IF              reduce using rule 74 (if -> if elsif END .)
    WHILE           reduce using rule 74 (if -> if elsif END .)
    BEGIN           reduce using rule 74 (if -> if elsif END .)
    FOR             reduce using rule 74 (if -> if elsif END .)
    NUMBER          reduce using rule 74 (if -> if elsif END .)
    STRING          reduce using rule 74 (if -> if elsif END .)
    LOCAL           reduce using rule 74 (if -> if elsif END .)
    GLOBAL          reduce using rule 74 (if -> if elsif END .)
    CONSTANTS       reduce using rule 74 (if -> if elsif END .)
    INSTANCEVAR     reduce using rule 74 (if -> if elsif END .)
    CLASSVAR        reduce using rule 74 (if -> if elsif END .)
    $end            reduce using rule 74 (if -> if elsif END .)
    END             reduce using rule 74 (if -> if elsif END .)
    NEWLINE         reduce using rule 74 (if -> if elsif END .)


state 56

    (75) else -> ELSE code . END
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    END             shift and go to state 96
    IF              shift and go to state 14
    WHILE           shift and go to state 15
    BEGIN           shift and go to state 16
    FOR             shift and go to state 17
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

    code                           shift and go to state 25
    expr                           shift and go to state 2
    if                             shift and go to state 3
    while                          shift and go to state 4
    expresiones                    shift and go to state 5
    for                            shift and go to state 6
    assign                         shift and go to state 7
    math                           shift and go to state 8
    term                           shift and go to state 9
    sterm                          shift and go to state 10
    variable                       shift and go to state 11
    slice                          shift and go to state 12
    index                          shift and go to state 13

state 57

    (76) elsif -> ELSIF logical . final
    (16) logical -> logical . logcompare logical
    (77) final -> . code
    (78) final -> . THEN code
    (79) final -> . code else
    (80) final -> . code elsif
    (24) logcompare -> . ANDLOG
    (25) logcompare -> . ORLOG
    (26) logcompare -> . NOTLOG
    (27) logcompare -> . AND
    (28) logcompare -> . OR
    (29) logcompare -> . NOT
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    THEN            shift and go to state 99
    ANDLOG          shift and go to state 76
    ORLOG           shift and go to state 77
    NOTLOG          shift and go to state 78
    AND             shift and go to state 79
    OR              shift and go to state 80
    NOT             shift and go to state 81
    IF              shift and go to state 14
    WHILE           shift and go to state 15
    BEGIN           shift and go to state 16
    FOR             shift and go to state 17
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

    final                          shift and go to state 97
    logcompare                     shift and go to state 75
    code                           shift and go to state 98
    expr                           shift and go to state 2
    if                             shift and go to state 3
    while                          shift and go to state 4
    expresiones                    shift and go to state 5
    for                            shift and go to state 6
    assign                         shift and go to state 7
    math                           shift and go to state 8
    term                           shift and go to state 9
    sterm                          shift and go to state 10
    variable                       shift and go to state 11
    slice                          shift and go to state 12
    index                          shift and go to state 13

state 58

    (83) expresiones -> term DOUBLESECUENCEPOINT term .

    IF              reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    WHILE           reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    BEGIN           reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    FOR             reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    NUMBER          reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    STRING          reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    LOCAL           reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    GLOBAL          reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    CONSTANTS       reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    INSTANCEVAR     reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    CLASSVAR        reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    $end            reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    END             reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    ELSE            reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    ELSIF           reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    NEWLINE         reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)
    DO              reduce using rule 83 (expresiones -> term DOUBLESECUENCEPOINT term .)


state 59

    (33) math -> term arith term .
    (33) math -> term . arith term
    (34) math -> term . arith math
    (58) arith -> . EXP
    (59) arith -> . MUL
    (60) arith -> . DIV
    (61) arith -> . MOD
    (62) arith -> . ADD
    (63) arith -> . SUB

    IF              reduce using rule 33 (math -> term arith term .)
    WHILE           reduce using rule 33 (math -> term arith term .)
    BEGIN           reduce using rule 33 (math -> term arith term .)
    FOR             reduce using rule 33 (math -> term arith term .)
    NUMBER          reduce using rule 33 (math -> term arith term .)
    STRING          reduce using rule 33 (math -> term arith term .)
    LOCAL           reduce using rule 33 (math -> term arith term .)
    GLOBAL          reduce using rule 33 (math -> term arith term .)
    CONSTANTS       reduce using rule 33 (math -> term arith term .)
    INSTANCEVAR     reduce using rule 33 (math -> term arith term .)
    CLASSVAR        reduce using rule 33 (math -> term arith term .)
    $end            reduce using rule 33 (math -> term arith term .)
    END             reduce using rule 33 (math -> term arith term .)
    ELSE            reduce using rule 33 (math -> term arith term .)
    ELSIF           reduce using rule 33 (math -> term arith term .)
    NEWLINE         reduce using rule 33 (math -> term arith term .)
    EXP             shift and go to state 32
    MUL             shift and go to state 33
    DIV             shift and go to state 34
    MOD             shift and go to state 35
    ADD             shift and go to state 36
    SUB             shift and go to state 37

    arith                          shift and go to state 31

state 60

    (34) math -> term arith math .

    IF              reduce using rule 34 (math -> term arith math .)
    WHILE           reduce using rule 34 (math -> term arith math .)
    BEGIN           reduce using rule 34 (math -> term arith math .)
    FOR             reduce using rule 34 (math -> term arith math .)
    NUMBER          reduce using rule 34 (math -> term arith math .)
    STRING          reduce using rule 34 (math -> term arith math .)
    LOCAL           reduce using rule 34 (math -> term arith math .)
    GLOBAL          reduce using rule 34 (math -> term arith math .)
    CONSTANTS       reduce using rule 34 (math -> term arith math .)
    INSTANCEVAR     reduce using rule 34 (math -> term arith math .)
    CLASSVAR        reduce using rule 34 (math -> term arith math .)
    $end            reduce using rule 34 (math -> term arith math .)
    END             reduce using rule 34 (math -> term arith math .)
    ELSE            reduce using rule 34 (math -> term arith math .)
    ELSIF           reduce using rule 34 (math -> term arith math .)
    NEWLINE         reduce using rule 34 (math -> term arith math .)


state 61

    (35) math -> variable . asig term
    (41) asig -> . ASS
    (42) asig -> . ADDASS
    (43) asig -> . SUBASS
    (44) asig -> . MULASS
    (45) asig -> . DIVASS
    (46) asig -> . MODASS
    (47) asig -> . EXPASS

    ASS             shift and go to state 100
    ADDASS          shift and go to state 41
    SUBASS          shift and go to state 42
    MULASS          shift and go to state 43
    DIVASS          shift and go to state 44
    MODASS          shift and go to state 45
    EXPASS          shift and go to state 46

    asig                           shift and go to state 39

state 62

    (51) expr -> variable .
    (35) math -> variable . asig term
    (96) slice -> variable . LBRACK defslice RBRACK
    (95) index -> variable . LBRACK INT RBRACK
    (41) asig -> . ASS
    (42) asig -> . ADDASS
    (43) asig -> . SUBASS
    (44) asig -> . MULASS
    (45) asig -> . DIVASS
    (46) asig -> . MODASS
    (47) asig -> . EXPASS

    IF              reduce using rule 51 (expr -> variable .)
    WHILE           reduce using rule 51 (expr -> variable .)
    BEGIN           reduce using rule 51 (expr -> variable .)
    FOR             reduce using rule 51 (expr -> variable .)
    NUMBER          reduce using rule 51 (expr -> variable .)
    STRING          reduce using rule 51 (expr -> variable .)
    LOCAL           reduce using rule 51 (expr -> variable .)
    GLOBAL          reduce using rule 51 (expr -> variable .)
    CONSTANTS       reduce using rule 51 (expr -> variable .)
    INSTANCEVAR     reduce using rule 51 (expr -> variable .)
    CLASSVAR        reduce using rule 51 (expr -> variable .)
    $end            reduce using rule 51 (expr -> variable .)
    END             reduce using rule 51 (expr -> variable .)
    ELSE            reduce using rule 51 (expr -> variable .)
    ELSIF           reduce using rule 51 (expr -> variable .)
    NEWLINE         reduce using rule 51 (expr -> variable .)
    LBRACK          shift and go to state 40
    ASS             shift and go to state 100
    ADDASS          shift and go to state 41
    SUBASS          shift and go to state 42
    MULASS          shift and go to state 43
    DIVASS          shift and go to state 44
    MODASS          shift and go to state 45
    EXPASS          shift and go to state 46

    asig                           shift and go to state 39

state 63

    (30) assign -> variable ASS expr .

    IF              reduce using rule 30 (assign -> variable ASS expr .)
    WHILE           reduce using rule 30 (assign -> variable ASS expr .)
    BEGIN           reduce using rule 30 (assign -> variable ASS expr .)
    FOR             reduce using rule 30 (assign -> variable ASS expr .)
    NUMBER          reduce using rule 30 (assign -> variable ASS expr .)
    STRING          reduce using rule 30 (assign -> variable ASS expr .)
    LOCAL           reduce using rule 30 (assign -> variable ASS expr .)
    GLOBAL          reduce using rule 30 (assign -> variable ASS expr .)
    CONSTANTS       reduce using rule 30 (assign -> variable ASS expr .)
    INSTANCEVAR     reduce using rule 30 (assign -> variable ASS expr .)
    CLASSVAR        reduce using rule 30 (assign -> variable ASS expr .)
    $end            reduce using rule 30 (assign -> variable ASS expr .)
    END             reduce using rule 30 (assign -> variable ASS expr .)
    ELSE            reduce using rule 30 (assign -> variable ASS expr .)
    ELSIF           reduce using rule 30 (assign -> variable ASS expr .)
    NEWLINE         reduce using rule 30 (assign -> variable ASS expr .)


state 64

    (31) assign -> variable ASS sexpr .

    IF              reduce using rule 31 (assign -> variable ASS sexpr .)
    WHILE           reduce using rule 31 (assign -> variable ASS sexpr .)
    BEGIN           reduce using rule 31 (assign -> variable ASS sexpr .)
    FOR             reduce using rule 31 (assign -> variable ASS sexpr .)
    NUMBER          reduce using rule 31 (assign -> variable ASS sexpr .)
    STRING          reduce using rule 31 (assign -> variable ASS sexpr .)
    LOCAL           reduce using rule 31 (assign -> variable ASS sexpr .)
    GLOBAL          reduce using rule 31 (assign -> variable ASS sexpr .)
    CONSTANTS       reduce using rule 31 (assign -> variable ASS sexpr .)
    INSTANCEVAR     reduce using rule 31 (assign -> variable ASS sexpr .)
    CLASSVAR        reduce using rule 31 (assign -> variable ASS sexpr .)
    $end            reduce using rule 31 (assign -> variable ASS sexpr .)
    END             reduce using rule 31 (assign -> variable ASS sexpr .)
    ELSE            reduce using rule 31 (assign -> variable ASS sexpr .)
    ELSIF           reduce using rule 31 (assign -> variable ASS sexpr .)
    NEWLINE         reduce using rule 31 (assign -> variable ASS sexpr .)


state 65

    (32) assign -> variable ASS array .

    IF              reduce using rule 32 (assign -> variable ASS array .)
    WHILE           reduce using rule 32 (assign -> variable ASS array .)
    BEGIN           reduce using rule 32 (assign -> variable ASS array .)
    FOR             reduce using rule 32 (assign -> variable ASS array .)
    NUMBER          reduce using rule 32 (assign -> variable ASS array .)
    STRING          reduce using rule 32 (assign -> variable ASS array .)
    LOCAL           reduce using rule 32 (assign -> variable ASS array .)
    GLOBAL          reduce using rule 32 (assign -> variable ASS array .)
    CONSTANTS       reduce using rule 32 (assign -> variable ASS array .)
    INSTANCEVAR     reduce using rule 32 (assign -> variable ASS array .)
    CLASSVAR        reduce using rule 32 (assign -> variable ASS array .)
    $end            reduce using rule 32 (assign -> variable ASS array .)
    END             reduce using rule 32 (assign -> variable ASS array .)
    ELSE            reduce using rule 32 (assign -> variable ASS array .)
    ELSIF           reduce using rule 32 (assign -> variable ASS array .)
    NEWLINE         reduce using rule 32 (assign -> variable ASS array .)


state 66

    (49) expr -> term .
    (33) math -> term . arith term
    (34) math -> term . arith math
    (58) arith -> . EXP
    (59) arith -> . MUL
    (60) arith -> . DIV
    (61) arith -> . MOD
    (62) arith -> . ADD
    (63) arith -> . SUB

    IF              reduce using rule 49 (expr -> term .)
    WHILE           reduce using rule 49 (expr -> term .)
    BEGIN           reduce using rule 49 (expr -> term .)
    FOR             reduce using rule 49 (expr -> term .)
    NUMBER          reduce using rule 49 (expr -> term .)
    STRING          reduce using rule 49 (expr -> term .)
    LOCAL           reduce using rule 49 (expr -> term .)
    GLOBAL          reduce using rule 49 (expr -> term .)
    CONSTANTS       reduce using rule 49 (expr -> term .)
    INSTANCEVAR     reduce using rule 49 (expr -> term .)
    CLASSVAR        reduce using rule 49 (expr -> term .)
    $end            reduce using rule 49 (expr -> term .)
    END             reduce using rule 49 (expr -> term .)
    ELSE            reduce using rule 49 (expr -> term .)
    ELSIF           reduce using rule 49 (expr -> term .)
    NEWLINE         reduce using rule 49 (expr -> term .)
    EXP             shift and go to state 32
    MUL             shift and go to state 33
    DIV             shift and go to state 34
    MOD             shift and go to state 35
    ADD             shift and go to state 36
    SUB             shift and go to state 37

    arith                          shift and go to state 31

state 67

    (50) expr -> sterm .
    (54) sexpr -> sterm . MUL term
    (55) sexpr -> sterm . ADD sexpr

    IF              reduce using rule 50 (expr -> sterm .)
    WHILE           reduce using rule 50 (expr -> sterm .)
    BEGIN           reduce using rule 50 (expr -> sterm .)
    FOR             reduce using rule 50 (expr -> sterm .)
    NUMBER          reduce using rule 50 (expr -> sterm .)
    STRING          reduce using rule 50 (expr -> sterm .)
    LOCAL           reduce using rule 50 (expr -> sterm .)
    GLOBAL          reduce using rule 50 (expr -> sterm .)
    CONSTANTS       reduce using rule 50 (expr -> sterm .)
    INSTANCEVAR     reduce using rule 50 (expr -> sterm .)
    CLASSVAR        reduce using rule 50 (expr -> sterm .)
    $end            reduce using rule 50 (expr -> sterm .)
    END             reduce using rule 50 (expr -> sterm .)
    ELSE            reduce using rule 50 (expr -> sterm .)
    ELSIF           reduce using rule 50 (expr -> sterm .)
    NEWLINE         reduce using rule 50 (expr -> sterm .)
    MUL             shift and go to state 101
    ADD             shift and go to state 102


state 68

    (84) array -> LBRACK . defarray RBRACK
    (85) defarray -> . NUMBER
    (86) defarray -> . NUMBER COMA defarray
    (87) defarray -> . STRING
    (88) defarray -> . STRING COMA defarray
    (89) defarray -> . INT
    (90) defarray -> . INT COMA defarray
    (91) defarray -> . FLOAT
    (92) defarray -> . FLOAT COMA defarray
    (93) defarray -> . BOOLEAN
    (94) defarray -> . BOOLEAN COMA defarray

    NUMBER          shift and go to state 104
    STRING          shift and go to state 105
    INT             shift and go to state 106
    FLOAT           shift and go to state 107
    BOOLEAN         shift and go to state 108

    defarray                       shift and go to state 103

state 69

    (35) math -> variable asig term .

    IF              reduce using rule 35 (math -> variable asig term .)
    WHILE           reduce using rule 35 (math -> variable asig term .)
    BEGIN           reduce using rule 35 (math -> variable asig term .)
    FOR             reduce using rule 35 (math -> variable asig term .)
    NUMBER          reduce using rule 35 (math -> variable asig term .)
    STRING          reduce using rule 35 (math -> variable asig term .)
    LOCAL           reduce using rule 35 (math -> variable asig term .)
    GLOBAL          reduce using rule 35 (math -> variable asig term .)
    CONSTANTS       reduce using rule 35 (math -> variable asig term .)
    INSTANCEVAR     reduce using rule 35 (math -> variable asig term .)
    CLASSVAR        reduce using rule 35 (math -> variable asig term .)
    $end            reduce using rule 35 (math -> variable asig term .)
    END             reduce using rule 35 (math -> variable asig term .)
    ELSE            reduce using rule 35 (math -> variable asig term .)
    ELSIF           reduce using rule 35 (math -> variable asig term .)
    NEWLINE         reduce using rule 35 (math -> variable asig term .)


state 70

    (96) slice -> variable LBRACK defslice . RBRACK

    RBRACK          shift and go to state 109


state 71

    (95) index -> variable LBRACK INT . RBRACK
    (97) defslice -> INT . DOBLEPOINT INT
    (98) defslice -> INT . DOBLEPOINT

    RBRACK          shift and go to state 110
    DOBLEPOINT      shift and go to state 111


state 72

    (99) defslice -> DOBLEPOINT . INT

    INT             shift and go to state 112


state 73

    (69) if -> IF logical expr . END

    END             shift and go to state 113


state 74

    (70) if -> IF logical THEN . expr END
    (72) if -> IF logical THEN .
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for LOCAL resolved as shift
  ! shift/reduce conflict for GLOBAL resolved as shift
  ! shift/reduce conflict for CONSTANTS resolved as shift
  ! shift/reduce conflict for INSTANCEVAR resolved as shift
  ! shift/reduce conflict for CLASSVAR resolved as shift
    ELSE            reduce using rule 72 (if -> IF logical THEN .)
    ELSIF           reduce using rule 72 (if -> IF logical THEN .)
    IF              reduce using rule 72 (if -> IF logical THEN .)
    WHILE           reduce using rule 72 (if -> IF logical THEN .)
    BEGIN           reduce using rule 72 (if -> IF logical THEN .)
    FOR             reduce using rule 72 (if -> IF logical THEN .)
    $end            reduce using rule 72 (if -> IF logical THEN .)
    END             reduce using rule 72 (if -> IF logical THEN .)
    NEWLINE         reduce using rule 72 (if -> IF logical THEN .)
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

  ! NUMBER          [ reduce using rule 72 (if -> IF logical THEN .) ]
  ! STRING          [ reduce using rule 72 (if -> IF logical THEN .) ]
  ! LOCAL           [ reduce using rule 72 (if -> IF logical THEN .) ]
  ! GLOBAL          [ reduce using rule 72 (if -> IF logical THEN .) ]
  ! CONSTANTS       [ reduce using rule 72 (if -> IF logical THEN .) ]
  ! INSTANCEVAR     [ reduce using rule 72 (if -> IF logical THEN .) ]
  ! CLASSVAR        [ reduce using rule 72 (if -> IF logical THEN .) ]

    expr                           shift and go to state 114
    math                           shift and go to state 8
    term                           shift and go to state 66
    sterm                          shift and go to state 10
    variable                       shift and go to state 62
    slice                          shift and go to state 12
    index                          shift and go to state 13

state 75

    (16) logical -> logical logcompare . logical
    (12) logical -> . term comparison term
    (13) logical -> . term comparison logical
    (14) logical -> . variable comparison term
    (15) logical -> . variable comparison BOOLEAN
    (16) logical -> . logical logcompare logical
    (17) logical -> . BOOLEAN
    (56) term -> . NUMBER
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR

    BOOLEAN         shift and go to state 50
    NUMBER          shift and go to state 18
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

    logical                        shift and go to state 115
    term                           shift and go to state 48
    variable                       shift and go to state 49

state 76

    (24) logcompare -> ANDLOG .

    BOOLEAN         reduce using rule 24 (logcompare -> ANDLOG .)
    NUMBER          reduce using rule 24 (logcompare -> ANDLOG .)
    LOCAL           reduce using rule 24 (logcompare -> ANDLOG .)
    GLOBAL          reduce using rule 24 (logcompare -> ANDLOG .)
    CONSTANTS       reduce using rule 24 (logcompare -> ANDLOG .)
    INSTANCEVAR     reduce using rule 24 (logcompare -> ANDLOG .)
    CLASSVAR        reduce using rule 24 (logcompare -> ANDLOG .)


state 77

    (25) logcompare -> ORLOG .

    BOOLEAN         reduce using rule 25 (logcompare -> ORLOG .)
    NUMBER          reduce using rule 25 (logcompare -> ORLOG .)
    LOCAL           reduce using rule 25 (logcompare -> ORLOG .)
    GLOBAL          reduce using rule 25 (logcompare -> ORLOG .)
    CONSTANTS       reduce using rule 25 (logcompare -> ORLOG .)
    INSTANCEVAR     reduce using rule 25 (logcompare -> ORLOG .)
    CLASSVAR        reduce using rule 25 (logcompare -> ORLOG .)


state 78

    (26) logcompare -> NOTLOG .

    BOOLEAN         reduce using rule 26 (logcompare -> NOTLOG .)
    NUMBER          reduce using rule 26 (logcompare -> NOTLOG .)
    LOCAL           reduce using rule 26 (logcompare -> NOTLOG .)
    GLOBAL          reduce using rule 26 (logcompare -> NOTLOG .)
    CONSTANTS       reduce using rule 26 (logcompare -> NOTLOG .)
    INSTANCEVAR     reduce using rule 26 (logcompare -> NOTLOG .)
    CLASSVAR        reduce using rule 26 (logcompare -> NOTLOG .)


state 79

    (27) logcompare -> AND .

    BOOLEAN         reduce using rule 27 (logcompare -> AND .)
    NUMBER          reduce using rule 27 (logcompare -> AND .)
    LOCAL           reduce using rule 27 (logcompare -> AND .)
    GLOBAL          reduce using rule 27 (logcompare -> AND .)
    CONSTANTS       reduce using rule 27 (logcompare -> AND .)
    INSTANCEVAR     reduce using rule 27 (logcompare -> AND .)
    CLASSVAR        reduce using rule 27 (logcompare -> AND .)


state 80

    (28) logcompare -> OR .

    BOOLEAN         reduce using rule 28 (logcompare -> OR .)
    NUMBER          reduce using rule 28 (logcompare -> OR .)
    LOCAL           reduce using rule 28 (logcompare -> OR .)
    GLOBAL          reduce using rule 28 (logcompare -> OR .)
    CONSTANTS       reduce using rule 28 (logcompare -> OR .)
    INSTANCEVAR     reduce using rule 28 (logcompare -> OR .)
    CLASSVAR        reduce using rule 28 (logcompare -> OR .)


state 81

    (29) logcompare -> NOT .

    BOOLEAN         reduce using rule 29 (logcompare -> NOT .)
    NUMBER          reduce using rule 29 (logcompare -> NOT .)
    LOCAL           reduce using rule 29 (logcompare -> NOT .)
    GLOBAL          reduce using rule 29 (logcompare -> NOT .)
    CONSTANTS       reduce using rule 29 (logcompare -> NOT .)
    INSTANCEVAR     reduce using rule 29 (logcompare -> NOT .)
    CLASSVAR        reduce using rule 29 (logcompare -> NOT .)


state 82

    (12) logical -> term comparison . term
    (13) logical -> term comparison . logical
    (56) term -> . NUMBER
    (12) logical -> . term comparison term
    (13) logical -> . term comparison logical
    (14) logical -> . variable comparison term
    (15) logical -> . variable comparison BOOLEAN
    (16) logical -> . logical logcompare logical
    (17) logical -> . BOOLEAN
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR

    NUMBER          shift and go to state 18
    BOOLEAN         shift and go to state 50
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

    term                           shift and go to state 116
    logical                        shift and go to state 117
    variable                       shift and go to state 49

state 83

    (18) comparison -> EQUAL .

    NUMBER          reduce using rule 18 (comparison -> EQUAL .)
    BOOLEAN         reduce using rule 18 (comparison -> EQUAL .)
    LOCAL           reduce using rule 18 (comparison -> EQUAL .)
    GLOBAL          reduce using rule 18 (comparison -> EQUAL .)
    CONSTANTS       reduce using rule 18 (comparison -> EQUAL .)
    INSTANCEVAR     reduce using rule 18 (comparison -> EQUAL .)
    CLASSVAR        reduce using rule 18 (comparison -> EQUAL .)


state 84

    (19) comparison -> NOTEQ .

    NUMBER          reduce using rule 19 (comparison -> NOTEQ .)
    BOOLEAN         reduce using rule 19 (comparison -> NOTEQ .)
    LOCAL           reduce using rule 19 (comparison -> NOTEQ .)
    GLOBAL          reduce using rule 19 (comparison -> NOTEQ .)
    CONSTANTS       reduce using rule 19 (comparison -> NOTEQ .)
    INSTANCEVAR     reduce using rule 19 (comparison -> NOTEQ .)
    CLASSVAR        reduce using rule 19 (comparison -> NOTEQ .)


state 85

    (20) comparison -> GREATHER .

    NUMBER          reduce using rule 20 (comparison -> GREATHER .)
    BOOLEAN         reduce using rule 20 (comparison -> GREATHER .)
    LOCAL           reduce using rule 20 (comparison -> GREATHER .)
    GLOBAL          reduce using rule 20 (comparison -> GREATHER .)
    CONSTANTS       reduce using rule 20 (comparison -> GREATHER .)
    INSTANCEVAR     reduce using rule 20 (comparison -> GREATHER .)
    CLASSVAR        reduce using rule 20 (comparison -> GREATHER .)


state 86

    (21) comparison -> LOWER .

    NUMBER          reduce using rule 21 (comparison -> LOWER .)
    BOOLEAN         reduce using rule 21 (comparison -> LOWER .)
    LOCAL           reduce using rule 21 (comparison -> LOWER .)
    GLOBAL          reduce using rule 21 (comparison -> LOWER .)
    CONSTANTS       reduce using rule 21 (comparison -> LOWER .)
    INSTANCEVAR     reduce using rule 21 (comparison -> LOWER .)
    CLASSVAR        reduce using rule 21 (comparison -> LOWER .)


state 87

    (22) comparison -> GREATHEREQ .

    NUMBER          reduce using rule 22 (comparison -> GREATHEREQ .)
    BOOLEAN         reduce using rule 22 (comparison -> GREATHEREQ .)
    LOCAL           reduce using rule 22 (comparison -> GREATHEREQ .)
    GLOBAL          reduce using rule 22 (comparison -> GREATHEREQ .)
    CONSTANTS       reduce using rule 22 (comparison -> GREATHEREQ .)
    INSTANCEVAR     reduce using rule 22 (comparison -> GREATHEREQ .)
    CLASSVAR        reduce using rule 22 (comparison -> GREATHEREQ .)


state 88

    (23) comparison -> LOWEREQ .

    NUMBER          reduce using rule 23 (comparison -> LOWEREQ .)
    BOOLEAN         reduce using rule 23 (comparison -> LOWEREQ .)
    LOCAL           reduce using rule 23 (comparison -> LOWEREQ .)
    GLOBAL          reduce using rule 23 (comparison -> LOWEREQ .)
    CONSTANTS       reduce using rule 23 (comparison -> LOWEREQ .)
    INSTANCEVAR     reduce using rule 23 (comparison -> LOWEREQ .)
    CLASSVAR        reduce using rule 23 (comparison -> LOWEREQ .)


state 89

    (14) logical -> variable comparison . term
    (15) logical -> variable comparison . BOOLEAN
    (56) term -> . NUMBER

    BOOLEAN         shift and go to state 119
    NUMBER          shift and go to state 18

    term                           shift and go to state 118

state 90

    (8) while -> WHILE logical code . END
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    END             shift and go to state 120
    IF              shift and go to state 14
    WHILE           shift and go to state 15
    BEGIN           shift and go to state 16
    FOR             shift and go to state 17
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

    code                           shift and go to state 25
    expr                           shift and go to state 2
    if                             shift and go to state 3
    while                          shift and go to state 4
    expresiones                    shift and go to state 5
    for                            shift and go to state 6
    assign                         shift and go to state 7
    math                           shift and go to state 8
    term                           shift and go to state 9
    sterm                          shift and go to state 10
    variable                       shift and go to state 11
    slice                          shift and go to state 12
    index                          shift and go to state 13

state 91

    (9) while -> WHILE logical DO . salto code salto END
    (68) salto -> . NEWLINE

    NEWLINE         shift and go to state 122

    salto                          shift and go to state 121

state 92

    (10) while -> WHILE logical DOBLEPOINT . salto code salto END
    (68) salto -> . NEWLINE

    NEWLINE         shift and go to state 122

    salto                          shift and go to state 123

state 93

    (11) while -> BEGIN code END . WHILE logical

    WHILE           shift and go to state 124


state 94

    (64) for -> FOR iterador IN . expresiones code END
    (65) for -> FOR iterador IN . expresiones DO code END
    (66) for -> FOR iterador IN . array code END
    (67) for -> FOR iterador IN . array DO code END
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (84) array -> . LBRACK defarray RBRACK
    (56) term -> . NUMBER

    LBRACK          shift and go to state 68
    NUMBER          shift and go to state 18

    expresiones                    shift and go to state 125
    array                          shift and go to state 126
    term                           shift and go to state 127

state 95

    (82) iterador -> variable COMA . variable
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR

    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

    variable                       shift and go to state 128

state 96

    (75) else -> ELSE code END .

    ELSE            reduce using rule 75 (else -> ELSE code END .)
    ELSIF           reduce using rule 75 (else -> ELSE code END .)
    IF              reduce using rule 75 (else -> ELSE code END .)
    WHILE           reduce using rule 75 (else -> ELSE code END .)
    BEGIN           reduce using rule 75 (else -> ELSE code END .)
    FOR             reduce using rule 75 (else -> ELSE code END .)
    NUMBER          reduce using rule 75 (else -> ELSE code END .)
    STRING          reduce using rule 75 (else -> ELSE code END .)
    LOCAL           reduce using rule 75 (else -> ELSE code END .)
    GLOBAL          reduce using rule 75 (else -> ELSE code END .)
    CONSTANTS       reduce using rule 75 (else -> ELSE code END .)
    INSTANCEVAR     reduce using rule 75 (else -> ELSE code END .)
    CLASSVAR        reduce using rule 75 (else -> ELSE code END .)
    $end            reduce using rule 75 (else -> ELSE code END .)
    END             reduce using rule 75 (else -> ELSE code END .)
    NEWLINE         reduce using rule 75 (else -> ELSE code END .)


state 97

    (76) elsif -> ELSIF logical final .

    END             reduce using rule 76 (elsif -> ELSIF logical final .)


state 98

    (77) final -> code .
    (79) final -> code . else
    (80) final -> code . elsif
    (7) code -> code . code
    (75) else -> . ELSE code END
    (76) elsif -> . ELSIF logical final
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    END             reduce using rule 77 (final -> code .)
    ELSE            shift and go to state 28
    ELSIF           shift and go to state 29
    IF              shift and go to state 14
    WHILE           shift and go to state 15
    BEGIN           shift and go to state 16
    FOR             shift and go to state 17
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

    code                           shift and go to state 25
    else                           shift and go to state 129
    elsif                          shift and go to state 130
    expr                           shift and go to state 2
    if                             shift and go to state 3
    while                          shift and go to state 4
    expresiones                    shift and go to state 5
    for                            shift and go to state 6
    assign                         shift and go to state 7
    math                           shift and go to state 8
    term                           shift and go to state 9
    sterm                          shift and go to state 10
    variable                       shift and go to state 11
    slice                          shift and go to state 12
    index                          shift and go to state 13

state 99

    (78) final -> THEN . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 14
    WHILE           shift and go to state 15
    BEGIN           shift and go to state 16
    FOR             shift and go to state 17
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

    code                           shift and go to state 131
    expr                           shift and go to state 2
    if                             shift and go to state 3
    while                          shift and go to state 4
    expresiones                    shift and go to state 5
    for                            shift and go to state 6
    assign                         shift and go to state 7
    math                           shift and go to state 8
    term                           shift and go to state 9
    sterm                          shift and go to state 10
    variable                       shift and go to state 11
    slice                          shift and go to state 12
    index                          shift and go to state 13

state 100

    (41) asig -> ASS .

    NUMBER          reduce using rule 41 (asig -> ASS .)


state 101

    (54) sexpr -> sterm MUL . term
    (56) term -> . NUMBER

    NUMBER          shift and go to state 18

    term                           shift and go to state 132

state 102

    (55) sexpr -> sterm ADD . sexpr
    (54) sexpr -> . sterm MUL term
    (55) sexpr -> . sterm ADD sexpr
    (57) sterm -> . STRING

    STRING          shift and go to state 19

    sterm                          shift and go to state 133
    sexpr                          shift and go to state 134

state 103

    (84) array -> LBRACK defarray . RBRACK

    RBRACK          shift and go to state 135


state 104

    (85) defarray -> NUMBER .
    (86) defarray -> NUMBER . COMA defarray

    RBRACK          reduce using rule 85 (defarray -> NUMBER .)
    COMA            shift and go to state 136


state 105

    (87) defarray -> STRING .
    (88) defarray -> STRING . COMA defarray

    RBRACK          reduce using rule 87 (defarray -> STRING .)
    COMA            shift and go to state 137


state 106

    (89) defarray -> INT .
    (90) defarray -> INT . COMA defarray

    RBRACK          reduce using rule 89 (defarray -> INT .)
    COMA            shift and go to state 138


state 107

    (91) defarray -> FLOAT .
    (92) defarray -> FLOAT . COMA defarray

    RBRACK          reduce using rule 91 (defarray -> FLOAT .)
    COMA            shift and go to state 139


state 108

    (93) defarray -> BOOLEAN .
    (94) defarray -> BOOLEAN . COMA defarray

    RBRACK          reduce using rule 93 (defarray -> BOOLEAN .)
    COMA            shift and go to state 140


state 109

    (96) slice -> variable LBRACK defslice RBRACK .

    IF              reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    WHILE           reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    BEGIN           reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    FOR             reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    NUMBER          reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    STRING          reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    LOCAL           reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    GLOBAL          reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    CONSTANTS       reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    INSTANCEVAR     reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    CLASSVAR        reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    $end            reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    END             reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    ELSE            reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    ELSIF           reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)
    NEWLINE         reduce using rule 96 (slice -> variable LBRACK defslice RBRACK .)


state 110

    (95) index -> variable LBRACK INT RBRACK .

    IF              reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    WHILE           reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    BEGIN           reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    FOR             reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    NUMBER          reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    STRING          reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    LOCAL           reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    GLOBAL          reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    CONSTANTS       reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    INSTANCEVAR     reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    CLASSVAR        reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    $end            reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    END             reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    ELSE            reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    ELSIF           reduce using rule 95 (index -> variable LBRACK INT RBRACK .)
    NEWLINE         reduce using rule 95 (index -> variable LBRACK INT RBRACK .)


state 111

    (97) defslice -> INT DOBLEPOINT . INT
    (98) defslice -> INT DOBLEPOINT .

    INT             shift and go to state 141
    RBRACK          reduce using rule 98 (defslice -> INT DOBLEPOINT .)


state 112

    (99) defslice -> DOBLEPOINT INT .

    RBRACK          reduce using rule 99 (defslice -> DOBLEPOINT INT .)


state 113

    (69) if -> IF logical expr END .

    ELSE            reduce using rule 69 (if -> IF logical expr END .)
    ELSIF           reduce using rule 69 (if -> IF logical expr END .)
    IF              reduce using rule 69 (if -> IF logical expr END .)
    WHILE           reduce using rule 69 (if -> IF logical expr END .)
    BEGIN           reduce using rule 69 (if -> IF logical expr END .)
    FOR             reduce using rule 69 (if -> IF logical expr END .)
    NUMBER          reduce using rule 69 (if -> IF logical expr END .)
    STRING          reduce using rule 69 (if -> IF logical expr END .)
    LOCAL           reduce using rule 69 (if -> IF logical expr END .)
    GLOBAL          reduce using rule 69 (if -> IF logical expr END .)
    CONSTANTS       reduce using rule 69 (if -> IF logical expr END .)
    INSTANCEVAR     reduce using rule 69 (if -> IF logical expr END .)
    CLASSVAR        reduce using rule 69 (if -> IF logical expr END .)
    $end            reduce using rule 69 (if -> IF logical expr END .)
    END             reduce using rule 69 (if -> IF logical expr END .)
    NEWLINE         reduce using rule 69 (if -> IF logical expr END .)


state 114

    (70) if -> IF logical THEN expr . END

    END             shift and go to state 142


state 115

    (16) logical -> logical logcompare logical .
    (16) logical -> logical . logcompare logical
    (24) logcompare -> . ANDLOG
    (25) logcompare -> . ORLOG
    (26) logcompare -> . NOTLOG
    (27) logcompare -> . AND
    (28) logcompare -> . OR
    (29) logcompare -> . NOT

  ! shift/reduce conflict for ANDLOG resolved as shift
  ! shift/reduce conflict for ORLOG resolved as shift
  ! shift/reduce conflict for NOTLOG resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    THEN            reduce using rule 16 (logical -> logical logcompare logical .)
    NUMBER          reduce using rule 16 (logical -> logical logcompare logical .)
    STRING          reduce using rule 16 (logical -> logical logcompare logical .)
    LOCAL           reduce using rule 16 (logical -> logical logcompare logical .)
    GLOBAL          reduce using rule 16 (logical -> logical logcompare logical .)
    CONSTANTS       reduce using rule 16 (logical -> logical logcompare logical .)
    INSTANCEVAR     reduce using rule 16 (logical -> logical logcompare logical .)
    CLASSVAR        reduce using rule 16 (logical -> logical logcompare logical .)
    ELSE            reduce using rule 16 (logical -> logical logcompare logical .)
    ELSIF           reduce using rule 16 (logical -> logical logcompare logical .)
    IF              reduce using rule 16 (logical -> logical logcompare logical .)
    WHILE           reduce using rule 16 (logical -> logical logcompare logical .)
    BEGIN           reduce using rule 16 (logical -> logical logcompare logical .)
    FOR             reduce using rule 16 (logical -> logical logcompare logical .)
    $end            reduce using rule 16 (logical -> logical logcompare logical .)
    END             reduce using rule 16 (logical -> logical logcompare logical .)
    NEWLINE         reduce using rule 16 (logical -> logical logcompare logical .)
    DO              reduce using rule 16 (logical -> logical logcompare logical .)
    DOBLEPOINT      reduce using rule 16 (logical -> logical logcompare logical .)
    ANDLOG          shift and go to state 76
    ORLOG           shift and go to state 77
    NOTLOG          shift and go to state 78
    AND             shift and go to state 79
    OR              shift and go to state 80
    NOT             shift and go to state 81

  ! ANDLOG          [ reduce using rule 16 (logical -> logical logcompare logical .) ]
  ! ORLOG           [ reduce using rule 16 (logical -> logical logcompare logical .) ]
  ! NOTLOG          [ reduce using rule 16 (logical -> logical logcompare logical .) ]
  ! AND             [ reduce using rule 16 (logical -> logical logcompare logical .) ]
  ! OR              [ reduce using rule 16 (logical -> logical logcompare logical .) ]
  ! NOT             [ reduce using rule 16 (logical -> logical logcompare logical .) ]

    logcompare                     shift and go to state 75

state 116

    (12) logical -> term comparison term .
    (12) logical -> term . comparison term
    (13) logical -> term . comparison logical
    (18) comparison -> . EQUAL
    (19) comparison -> . NOTEQ
    (20) comparison -> . GREATHER
    (21) comparison -> . LOWER
    (22) comparison -> . GREATHEREQ
    (23) comparison -> . LOWEREQ

    THEN            reduce using rule 12 (logical -> term comparison term .)
    ANDLOG          reduce using rule 12 (logical -> term comparison term .)
    ORLOG           reduce using rule 12 (logical -> term comparison term .)
    NOTLOG          reduce using rule 12 (logical -> term comparison term .)
    AND             reduce using rule 12 (logical -> term comparison term .)
    OR              reduce using rule 12 (logical -> term comparison term .)
    NOT             reduce using rule 12 (logical -> term comparison term .)
    NUMBER          reduce using rule 12 (logical -> term comparison term .)
    STRING          reduce using rule 12 (logical -> term comparison term .)
    LOCAL           reduce using rule 12 (logical -> term comparison term .)
    GLOBAL          reduce using rule 12 (logical -> term comparison term .)
    CONSTANTS       reduce using rule 12 (logical -> term comparison term .)
    INSTANCEVAR     reduce using rule 12 (logical -> term comparison term .)
    CLASSVAR        reduce using rule 12 (logical -> term comparison term .)
    ELSE            reduce using rule 12 (logical -> term comparison term .)
    ELSIF           reduce using rule 12 (logical -> term comparison term .)
    IF              reduce using rule 12 (logical -> term comparison term .)
    WHILE           reduce using rule 12 (logical -> term comparison term .)
    BEGIN           reduce using rule 12 (logical -> term comparison term .)
    FOR             reduce using rule 12 (logical -> term comparison term .)
    $end            reduce using rule 12 (logical -> term comparison term .)
    END             reduce using rule 12 (logical -> term comparison term .)
    NEWLINE         reduce using rule 12 (logical -> term comparison term .)
    DO              reduce using rule 12 (logical -> term comparison term .)
    DOBLEPOINT      reduce using rule 12 (logical -> term comparison term .)
    EQUAL           shift and go to state 83
    NOTEQ           shift and go to state 84
    GREATHER        shift and go to state 85
    LOWER           shift and go to state 86
    GREATHEREQ      shift and go to state 87
    LOWEREQ         shift and go to state 88

    comparison                     shift and go to state 82

state 117

    (13) logical -> term comparison logical .
    (16) logical -> logical . logcompare logical
    (24) logcompare -> . ANDLOG
    (25) logcompare -> . ORLOG
    (26) logcompare -> . NOTLOG
    (27) logcompare -> . AND
    (28) logcompare -> . OR
    (29) logcompare -> . NOT

  ! shift/reduce conflict for ANDLOG resolved as shift
  ! shift/reduce conflict for ORLOG resolved as shift
  ! shift/reduce conflict for NOTLOG resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    THEN            reduce using rule 13 (logical -> term comparison logical .)
    NUMBER          reduce using rule 13 (logical -> term comparison logical .)
    STRING          reduce using rule 13 (logical -> term comparison logical .)
    LOCAL           reduce using rule 13 (logical -> term comparison logical .)
    GLOBAL          reduce using rule 13 (logical -> term comparison logical .)
    CONSTANTS       reduce using rule 13 (logical -> term comparison logical .)
    INSTANCEVAR     reduce using rule 13 (logical -> term comparison logical .)
    CLASSVAR        reduce using rule 13 (logical -> term comparison logical .)
    ELSE            reduce using rule 13 (logical -> term comparison logical .)
    ELSIF           reduce using rule 13 (logical -> term comparison logical .)
    IF              reduce using rule 13 (logical -> term comparison logical .)
    WHILE           reduce using rule 13 (logical -> term comparison logical .)
    BEGIN           reduce using rule 13 (logical -> term comparison logical .)
    FOR             reduce using rule 13 (logical -> term comparison logical .)
    $end            reduce using rule 13 (logical -> term comparison logical .)
    END             reduce using rule 13 (logical -> term comparison logical .)
    NEWLINE         reduce using rule 13 (logical -> term comparison logical .)
    DO              reduce using rule 13 (logical -> term comparison logical .)
    DOBLEPOINT      reduce using rule 13 (logical -> term comparison logical .)
    ANDLOG          shift and go to state 76
    ORLOG           shift and go to state 77
    NOTLOG          shift and go to state 78
    AND             shift and go to state 79
    OR              shift and go to state 80
    NOT             shift and go to state 81

  ! ANDLOG          [ reduce using rule 13 (logical -> term comparison logical .) ]
  ! ORLOG           [ reduce using rule 13 (logical -> term comparison logical .) ]
  ! NOTLOG          [ reduce using rule 13 (logical -> term comparison logical .) ]
  ! AND             [ reduce using rule 13 (logical -> term comparison logical .) ]
  ! OR              [ reduce using rule 13 (logical -> term comparison logical .) ]
  ! NOT             [ reduce using rule 13 (logical -> term comparison logical .) ]

    logcompare                     shift and go to state 75

state 118

    (14) logical -> variable comparison term .

    THEN            reduce using rule 14 (logical -> variable comparison term .)
    ANDLOG          reduce using rule 14 (logical -> variable comparison term .)
    ORLOG           reduce using rule 14 (logical -> variable comparison term .)
    NOTLOG          reduce using rule 14 (logical -> variable comparison term .)
    AND             reduce using rule 14 (logical -> variable comparison term .)
    OR              reduce using rule 14 (logical -> variable comparison term .)
    NOT             reduce using rule 14 (logical -> variable comparison term .)
    NUMBER          reduce using rule 14 (logical -> variable comparison term .)
    STRING          reduce using rule 14 (logical -> variable comparison term .)
    LOCAL           reduce using rule 14 (logical -> variable comparison term .)
    GLOBAL          reduce using rule 14 (logical -> variable comparison term .)
    CONSTANTS       reduce using rule 14 (logical -> variable comparison term .)
    INSTANCEVAR     reduce using rule 14 (logical -> variable comparison term .)
    CLASSVAR        reduce using rule 14 (logical -> variable comparison term .)
    ELSE            reduce using rule 14 (logical -> variable comparison term .)
    ELSIF           reduce using rule 14 (logical -> variable comparison term .)
    IF              reduce using rule 14 (logical -> variable comparison term .)
    WHILE           reduce using rule 14 (logical -> variable comparison term .)
    BEGIN           reduce using rule 14 (logical -> variable comparison term .)
    FOR             reduce using rule 14 (logical -> variable comparison term .)
    $end            reduce using rule 14 (logical -> variable comparison term .)
    END             reduce using rule 14 (logical -> variable comparison term .)
    NEWLINE         reduce using rule 14 (logical -> variable comparison term .)
    DO              reduce using rule 14 (logical -> variable comparison term .)
    DOBLEPOINT      reduce using rule 14 (logical -> variable comparison term .)


state 119

    (15) logical -> variable comparison BOOLEAN .

    THEN            reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    ANDLOG          reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    ORLOG           reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    NOTLOG          reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    AND             reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    OR              reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    NOT             reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    NUMBER          reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    STRING          reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    LOCAL           reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    GLOBAL          reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    CONSTANTS       reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    INSTANCEVAR     reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    CLASSVAR        reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    ELSE            reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    ELSIF           reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    IF              reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    WHILE           reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    BEGIN           reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    FOR             reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    $end            reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    END             reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    NEWLINE         reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    DO              reduce using rule 15 (logical -> variable comparison BOOLEAN .)
    DOBLEPOINT      reduce using rule 15 (logical -> variable comparison BOOLEAN .)


state 120

    (8) while -> WHILE logical code END .

    IF              reduce using rule 8 (while -> WHILE logical code END .)
    WHILE           reduce using rule 8 (while -> WHILE logical code END .)
    BEGIN           reduce using rule 8 (while -> WHILE logical code END .)
    FOR             reduce using rule 8 (while -> WHILE logical code END .)
    NUMBER          reduce using rule 8 (while -> WHILE logical code END .)
    STRING          reduce using rule 8 (while -> WHILE logical code END .)
    LOCAL           reduce using rule 8 (while -> WHILE logical code END .)
    GLOBAL          reduce using rule 8 (while -> WHILE logical code END .)
    CONSTANTS       reduce using rule 8 (while -> WHILE logical code END .)
    INSTANCEVAR     reduce using rule 8 (while -> WHILE logical code END .)
    CLASSVAR        reduce using rule 8 (while -> WHILE logical code END .)
    $end            reduce using rule 8 (while -> WHILE logical code END .)
    END             reduce using rule 8 (while -> WHILE logical code END .)
    ELSE            reduce using rule 8 (while -> WHILE logical code END .)
    ELSIF           reduce using rule 8 (while -> WHILE logical code END .)
    NEWLINE         reduce using rule 8 (while -> WHILE logical code END .)


state 121

    (9) while -> WHILE logical DO salto . code salto END
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 14
    WHILE           shift and go to state 15
    BEGIN           shift and go to state 16
    FOR             shift and go to state 17
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

    code                           shift and go to state 143
    expr                           shift and go to state 2
    if                             shift and go to state 3
    while                          shift and go to state 4
    expresiones                    shift and go to state 5
    for                            shift and go to state 6
    assign                         shift and go to state 7
    math                           shift and go to state 8
    term                           shift and go to state 9
    sterm                          shift and go to state 10
    variable                       shift and go to state 11
    slice                          shift and go to state 12
    index                          shift and go to state 13

state 122

    (68) salto -> NEWLINE .

    IF              reduce using rule 68 (salto -> NEWLINE .)
    WHILE           reduce using rule 68 (salto -> NEWLINE .)
    BEGIN           reduce using rule 68 (salto -> NEWLINE .)
    FOR             reduce using rule 68 (salto -> NEWLINE .)
    NUMBER          reduce using rule 68 (salto -> NEWLINE .)
    STRING          reduce using rule 68 (salto -> NEWLINE .)
    LOCAL           reduce using rule 68 (salto -> NEWLINE .)
    GLOBAL          reduce using rule 68 (salto -> NEWLINE .)
    CONSTANTS       reduce using rule 68 (salto -> NEWLINE .)
    INSTANCEVAR     reduce using rule 68 (salto -> NEWLINE .)
    CLASSVAR        reduce using rule 68 (salto -> NEWLINE .)
    END             reduce using rule 68 (salto -> NEWLINE .)


state 123

    (10) while -> WHILE logical DOBLEPOINT salto . code salto END
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 14
    WHILE           shift and go to state 15
    BEGIN           shift and go to state 16
    FOR             shift and go to state 17
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

    code                           shift and go to state 144
    expr                           shift and go to state 2
    if                             shift and go to state 3
    while                          shift and go to state 4
    expresiones                    shift and go to state 5
    for                            shift and go to state 6
    assign                         shift and go to state 7
    math                           shift and go to state 8
    term                           shift and go to state 9
    sterm                          shift and go to state 10
    variable                       shift and go to state 11
    slice                          shift and go to state 12
    index                          shift and go to state 13

state 124

    (11) while -> BEGIN code END WHILE . logical
    (12) logical -> . term comparison term
    (13) logical -> . term comparison logical
    (14) logical -> . variable comparison term
    (15) logical -> . variable comparison BOOLEAN
    (16) logical -> . logical logcompare logical
    (17) logical -> . BOOLEAN
    (56) term -> . NUMBER
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR

    BOOLEAN         shift and go to state 50
    NUMBER          shift and go to state 18
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

    logical                        shift and go to state 145
    term                           shift and go to state 48
    variable                       shift and go to state 49

state 125

    (64) for -> FOR iterador IN expresiones . code END
    (65) for -> FOR iterador IN expresiones . DO code END
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    DO              shift and go to state 147
    IF              shift and go to state 14
    WHILE           shift and go to state 15
    BEGIN           shift and go to state 16
    FOR             shift and go to state 17
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

    expresiones                    shift and go to state 5
    code                           shift and go to state 146
    expr                           shift and go to state 2
    if                             shift and go to state 3
    while                          shift and go to state 4
    for                            shift and go to state 6
    assign                         shift and go to state 7
    math                           shift and go to state 8
    term                           shift and go to state 9
    sterm                          shift and go to state 10
    variable                       shift and go to state 11
    slice                          shift and go to state 12
    index                          shift and go to state 13

state 126

    (66) for -> FOR iterador IN array . code END
    (67) for -> FOR iterador IN array . DO code END
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    DO              shift and go to state 149
    IF              shift and go to state 14
    WHILE           shift and go to state 15
    BEGIN           shift and go to state 16
    FOR             shift and go to state 17
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

    code                           shift and go to state 148
    expr                           shift and go to state 2
    if                             shift and go to state 3
    while                          shift and go to state 4
    expresiones                    shift and go to state 5
    for                            shift and go to state 6
    assign                         shift and go to state 7
    math                           shift and go to state 8
    term                           shift and go to state 9
    sterm                          shift and go to state 10
    variable                       shift and go to state 11
    slice                          shift and go to state 12
    index                          shift and go to state 13

state 127

    (83) expresiones -> term . DOUBLESECUENCEPOINT term

    DOUBLESECUENCEPOINT shift and go to state 30


state 128

    (82) iterador -> variable COMA variable .

    IN              reduce using rule 82 (iterador -> variable COMA variable .)


state 129

    (79) final -> code else .

    END             reduce using rule 79 (final -> code else .)


state 130

    (80) final -> code elsif .

    END             reduce using rule 80 (final -> code elsif .)


state 131

    (78) final -> THEN code .
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    END             reduce using rule 78 (final -> THEN code .)
    IF              shift and go to state 14
    WHILE           shift and go to state 15
    BEGIN           shift and go to state 16
    FOR             shift and go to state 17
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

    code                           shift and go to state 25
    expr                           shift and go to state 2
    if                             shift and go to state 3
    while                          shift and go to state 4
    expresiones                    shift and go to state 5
    for                            shift and go to state 6
    assign                         shift and go to state 7
    math                           shift and go to state 8
    term                           shift and go to state 9
    sterm                          shift and go to state 10
    variable                       shift and go to state 11
    slice                          shift and go to state 12
    index                          shift and go to state 13

state 132

    (54) sexpr -> sterm MUL term .

    IF              reduce using rule 54 (sexpr -> sterm MUL term .)
    WHILE           reduce using rule 54 (sexpr -> sterm MUL term .)
    BEGIN           reduce using rule 54 (sexpr -> sterm MUL term .)
    FOR             reduce using rule 54 (sexpr -> sterm MUL term .)
    NUMBER          reduce using rule 54 (sexpr -> sterm MUL term .)
    STRING          reduce using rule 54 (sexpr -> sterm MUL term .)
    LOCAL           reduce using rule 54 (sexpr -> sterm MUL term .)
    GLOBAL          reduce using rule 54 (sexpr -> sterm MUL term .)
    CONSTANTS       reduce using rule 54 (sexpr -> sterm MUL term .)
    INSTANCEVAR     reduce using rule 54 (sexpr -> sterm MUL term .)
    CLASSVAR        reduce using rule 54 (sexpr -> sterm MUL term .)
    $end            reduce using rule 54 (sexpr -> sterm MUL term .)
    END             reduce using rule 54 (sexpr -> sterm MUL term .)
    ELSE            reduce using rule 54 (sexpr -> sterm MUL term .)
    ELSIF           reduce using rule 54 (sexpr -> sterm MUL term .)
    NEWLINE         reduce using rule 54 (sexpr -> sterm MUL term .)


state 133

    (54) sexpr -> sterm . MUL term
    (55) sexpr -> sterm . ADD sexpr

    MUL             shift and go to state 101
    ADD             shift and go to state 102


state 134

    (55) sexpr -> sterm ADD sexpr .

    IF              reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    WHILE           reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    BEGIN           reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    FOR             reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    NUMBER          reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    STRING          reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    LOCAL           reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    GLOBAL          reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    CONSTANTS       reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    INSTANCEVAR     reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    CLASSVAR        reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    $end            reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    END             reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    ELSE            reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    ELSIF           reduce using rule 55 (sexpr -> sterm ADD sexpr .)
    NEWLINE         reduce using rule 55 (sexpr -> sterm ADD sexpr .)


state 135

    (84) array -> LBRACK defarray RBRACK .

    IF              reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    WHILE           reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    BEGIN           reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    FOR             reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    NUMBER          reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    STRING          reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    LOCAL           reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    GLOBAL          reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    CONSTANTS       reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    INSTANCEVAR     reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    CLASSVAR        reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    $end            reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    END             reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    ELSE            reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    ELSIF           reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    NEWLINE         reduce using rule 84 (array -> LBRACK defarray RBRACK .)
    DO              reduce using rule 84 (array -> LBRACK defarray RBRACK .)


state 136

    (86) defarray -> NUMBER COMA . defarray
    (85) defarray -> . NUMBER
    (86) defarray -> . NUMBER COMA defarray
    (87) defarray -> . STRING
    (88) defarray -> . STRING COMA defarray
    (89) defarray -> . INT
    (90) defarray -> . INT COMA defarray
    (91) defarray -> . FLOAT
    (92) defarray -> . FLOAT COMA defarray
    (93) defarray -> . BOOLEAN
    (94) defarray -> . BOOLEAN COMA defarray

    NUMBER          shift and go to state 104
    STRING          shift and go to state 105
    INT             shift and go to state 106
    FLOAT           shift and go to state 107
    BOOLEAN         shift and go to state 108

    defarray                       shift and go to state 150

state 137

    (88) defarray -> STRING COMA . defarray
    (85) defarray -> . NUMBER
    (86) defarray -> . NUMBER COMA defarray
    (87) defarray -> . STRING
    (88) defarray -> . STRING COMA defarray
    (89) defarray -> . INT
    (90) defarray -> . INT COMA defarray
    (91) defarray -> . FLOAT
    (92) defarray -> . FLOAT COMA defarray
    (93) defarray -> . BOOLEAN
    (94) defarray -> . BOOLEAN COMA defarray

    NUMBER          shift and go to state 104
    STRING          shift and go to state 105
    INT             shift and go to state 106
    FLOAT           shift and go to state 107
    BOOLEAN         shift and go to state 108

    defarray                       shift and go to state 151

state 138

    (90) defarray -> INT COMA . defarray
    (85) defarray -> . NUMBER
    (86) defarray -> . NUMBER COMA defarray
    (87) defarray -> . STRING
    (88) defarray -> . STRING COMA defarray
    (89) defarray -> . INT
    (90) defarray -> . INT COMA defarray
    (91) defarray -> . FLOAT
    (92) defarray -> . FLOAT COMA defarray
    (93) defarray -> . BOOLEAN
    (94) defarray -> . BOOLEAN COMA defarray

    NUMBER          shift and go to state 104
    STRING          shift and go to state 105
    INT             shift and go to state 106
    FLOAT           shift and go to state 107
    BOOLEAN         shift and go to state 108

    defarray                       shift and go to state 152

state 139

    (92) defarray -> FLOAT COMA . defarray
    (85) defarray -> . NUMBER
    (86) defarray -> . NUMBER COMA defarray
    (87) defarray -> . STRING
    (88) defarray -> . STRING COMA defarray
    (89) defarray -> . INT
    (90) defarray -> . INT COMA defarray
    (91) defarray -> . FLOAT
    (92) defarray -> . FLOAT COMA defarray
    (93) defarray -> . BOOLEAN
    (94) defarray -> . BOOLEAN COMA defarray

    NUMBER          shift and go to state 104
    STRING          shift and go to state 105
    INT             shift and go to state 106
    FLOAT           shift and go to state 107
    BOOLEAN         shift and go to state 108

    defarray                       shift and go to state 153

state 140

    (94) defarray -> BOOLEAN COMA . defarray
    (85) defarray -> . NUMBER
    (86) defarray -> . NUMBER COMA defarray
    (87) defarray -> . STRING
    (88) defarray -> . STRING COMA defarray
    (89) defarray -> . INT
    (90) defarray -> . INT COMA defarray
    (91) defarray -> . FLOAT
    (92) defarray -> . FLOAT COMA defarray
    (93) defarray -> . BOOLEAN
    (94) defarray -> . BOOLEAN COMA defarray

    NUMBER          shift and go to state 104
    STRING          shift and go to state 105
    INT             shift and go to state 106
    FLOAT           shift and go to state 107
    BOOLEAN         shift and go to state 108

    defarray                       shift and go to state 154

state 141

    (97) defslice -> INT DOBLEPOINT INT .

    RBRACK          reduce using rule 97 (defslice -> INT DOBLEPOINT INT .)


state 142

    (70) if -> IF logical THEN expr END .

    ELSE            reduce using rule 70 (if -> IF logical THEN expr END .)
    ELSIF           reduce using rule 70 (if -> IF logical THEN expr END .)
    IF              reduce using rule 70 (if -> IF logical THEN expr END .)
    WHILE           reduce using rule 70 (if -> IF logical THEN expr END .)
    BEGIN           reduce using rule 70 (if -> IF logical THEN expr END .)
    FOR             reduce using rule 70 (if -> IF logical THEN expr END .)
    NUMBER          reduce using rule 70 (if -> IF logical THEN expr END .)
    STRING          reduce using rule 70 (if -> IF logical THEN expr END .)
    LOCAL           reduce using rule 70 (if -> IF logical THEN expr END .)
    GLOBAL          reduce using rule 70 (if -> IF logical THEN expr END .)
    CONSTANTS       reduce using rule 70 (if -> IF logical THEN expr END .)
    INSTANCEVAR     reduce using rule 70 (if -> IF logical THEN expr END .)
    CLASSVAR        reduce using rule 70 (if -> IF logical THEN expr END .)
    $end            reduce using rule 70 (if -> IF logical THEN expr END .)
    END             reduce using rule 70 (if -> IF logical THEN expr END .)
    NEWLINE         reduce using rule 70 (if -> IF logical THEN expr END .)


state 143

    (9) while -> WHILE logical DO salto code . salto END
    (7) code -> code . code
    (68) salto -> . NEWLINE
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    NEWLINE         shift and go to state 122
    IF              shift and go to state 14
    WHILE           shift and go to state 15
    BEGIN           shift and go to state 16
    FOR             shift and go to state 17
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

    salto                          shift and go to state 155
    code                           shift and go to state 25
    expr                           shift and go to state 2
    if                             shift and go to state 3
    while                          shift and go to state 4
    expresiones                    shift and go to state 5
    for                            shift and go to state 6
    assign                         shift and go to state 7
    math                           shift and go to state 8
    term                           shift and go to state 9
    sterm                          shift and go to state 10
    variable                       shift and go to state 11
    slice                          shift and go to state 12
    index                          shift and go to state 13

state 144

    (10) while -> WHILE logical DOBLEPOINT salto code . salto END
    (7) code -> code . code
    (68) salto -> . NEWLINE
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    NEWLINE         shift and go to state 122
    IF              shift and go to state 14
    WHILE           shift and go to state 15
    BEGIN           shift and go to state 16
    FOR             shift and go to state 17
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

    salto                          shift and go to state 156
    code                           shift and go to state 25
    expr                           shift and go to state 2
    if                             shift and go to state 3
    while                          shift and go to state 4
    expresiones                    shift and go to state 5
    for                            shift and go to state 6
    assign                         shift and go to state 7
    math                           shift and go to state 8
    term                           shift and go to state 9
    sterm                          shift and go to state 10
    variable                       shift and go to state 11
    slice                          shift and go to state 12
    index                          shift and go to state 13

state 145

    (11) while -> BEGIN code END WHILE logical .
    (16) logical -> logical . logcompare logical
    (24) logcompare -> . ANDLOG
    (25) logcompare -> . ORLOG
    (26) logcompare -> . NOTLOG
    (27) logcompare -> . AND
    (28) logcompare -> . OR
    (29) logcompare -> . NOT

    IF              reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    WHILE           reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    BEGIN           reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    FOR             reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    NUMBER          reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    STRING          reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    LOCAL           reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    GLOBAL          reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    CONSTANTS       reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    INSTANCEVAR     reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    CLASSVAR        reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    $end            reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    END             reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    ELSE            reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    ELSIF           reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    NEWLINE         reduce using rule 11 (while -> BEGIN code END WHILE logical .)
    ANDLOG          shift and go to state 76
    ORLOG           shift and go to state 77
    NOTLOG          shift and go to state 78
    AND             shift and go to state 79
    OR              shift and go to state 80
    NOT             shift and go to state 81

    logcompare                     shift and go to state 75

state 146

    (64) for -> FOR iterador IN expresiones code . END
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    END             shift and go to state 157
    IF              shift and go to state 14
    WHILE           shift and go to state 15
    BEGIN           shift and go to state 16
    FOR             shift and go to state 17
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

    expresiones                    shift and go to state 5
    code                           shift and go to state 25
    expr                           shift and go to state 2
    if                             shift and go to state 3
    while                          shift and go to state 4
    for                            shift and go to state 6
    assign                         shift and go to state 7
    math                           shift and go to state 8
    term                           shift and go to state 9
    sterm                          shift and go to state 10
    variable                       shift and go to state 11
    slice                          shift and go to state 12
    index                          shift and go to state 13

state 147

    (65) for -> FOR iterador IN expresiones DO . code END
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 14
    WHILE           shift and go to state 15
    BEGIN           shift and go to state 16
    FOR             shift and go to state 17
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

    expresiones                    shift and go to state 5
    code                           shift and go to state 158
    expr                           shift and go to state 2
    if                             shift and go to state 3
    while                          shift and go to state 4
    for                            shift and go to state 6
    assign                         shift and go to state 7
    math                           shift and go to state 8
    term                           shift and go to state 9
    sterm                          shift and go to state 10
    variable                       shift and go to state 11
    slice                          shift and go to state 12
    index                          shift and go to state 13

state 148

    (66) for -> FOR iterador IN array code . END
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    END             shift and go to state 159
    IF              shift and go to state 14
    WHILE           shift and go to state 15
    BEGIN           shift and go to state 16
    FOR             shift and go to state 17
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

    code                           shift and go to state 25
    expr                           shift and go to state 2
    if                             shift and go to state 3
    while                          shift and go to state 4
    expresiones                    shift and go to state 5
    for                            shift and go to state 6
    assign                         shift and go to state 7
    math                           shift and go to state 8
    term                           shift and go to state 9
    sterm                          shift and go to state 10
    variable                       shift and go to state 11
    slice                          shift and go to state 12
    index                          shift and go to state 13

state 149

    (67) for -> FOR iterador IN array DO . code END
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    IF              shift and go to state 14
    WHILE           shift and go to state 15
    BEGIN           shift and go to state 16
    FOR             shift and go to state 17
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

    code                           shift and go to state 160
    expr                           shift and go to state 2
    if                             shift and go to state 3
    while                          shift and go to state 4
    expresiones                    shift and go to state 5
    for                            shift and go to state 6
    assign                         shift and go to state 7
    math                           shift and go to state 8
    term                           shift and go to state 9
    sterm                          shift and go to state 10
    variable                       shift and go to state 11
    slice                          shift and go to state 12
    index                          shift and go to state 13

state 150

    (86) defarray -> NUMBER COMA defarray .

    RBRACK          reduce using rule 86 (defarray -> NUMBER COMA defarray .)


state 151

    (88) defarray -> STRING COMA defarray .

    RBRACK          reduce using rule 88 (defarray -> STRING COMA defarray .)


state 152

    (90) defarray -> INT COMA defarray .

    RBRACK          reduce using rule 90 (defarray -> INT COMA defarray .)


state 153

    (92) defarray -> FLOAT COMA defarray .

    RBRACK          reduce using rule 92 (defarray -> FLOAT COMA defarray .)


state 154

    (94) defarray -> BOOLEAN COMA defarray .

    RBRACK          reduce using rule 94 (defarray -> BOOLEAN COMA defarray .)


state 155

    (9) while -> WHILE logical DO salto code salto . END

    END             shift and go to state 161


state 156

    (10) while -> WHILE logical DOBLEPOINT salto code salto . END

    END             shift and go to state 162


state 157

    (64) for -> FOR iterador IN expresiones code END .

    IF              reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    WHILE           reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    BEGIN           reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    FOR             reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    NUMBER          reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    STRING          reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    LOCAL           reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    GLOBAL          reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    CONSTANTS       reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    INSTANCEVAR     reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    CLASSVAR        reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    $end            reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    END             reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    ELSE            reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    ELSIF           reduce using rule 64 (for -> FOR iterador IN expresiones code END .)
    NEWLINE         reduce using rule 64 (for -> FOR iterador IN expresiones code END .)


state 158

    (65) for -> FOR iterador IN expresiones DO code . END
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    END             shift and go to state 163
    IF              shift and go to state 14
    WHILE           shift and go to state 15
    BEGIN           shift and go to state 16
    FOR             shift and go to state 17
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

    expresiones                    shift and go to state 5
    code                           shift and go to state 25
    expr                           shift and go to state 2
    if                             shift and go to state 3
    while                          shift and go to state 4
    for                            shift and go to state 6
    assign                         shift and go to state 7
    math                           shift and go to state 8
    term                           shift and go to state 9
    sterm                          shift and go to state 10
    variable                       shift and go to state 11
    slice                          shift and go to state 12
    index                          shift and go to state 13

state 159

    (66) for -> FOR iterador IN array code END .

    IF              reduce using rule 66 (for -> FOR iterador IN array code END .)
    WHILE           reduce using rule 66 (for -> FOR iterador IN array code END .)
    BEGIN           reduce using rule 66 (for -> FOR iterador IN array code END .)
    FOR             reduce using rule 66 (for -> FOR iterador IN array code END .)
    NUMBER          reduce using rule 66 (for -> FOR iterador IN array code END .)
    STRING          reduce using rule 66 (for -> FOR iterador IN array code END .)
    LOCAL           reduce using rule 66 (for -> FOR iterador IN array code END .)
    GLOBAL          reduce using rule 66 (for -> FOR iterador IN array code END .)
    CONSTANTS       reduce using rule 66 (for -> FOR iterador IN array code END .)
    INSTANCEVAR     reduce using rule 66 (for -> FOR iterador IN array code END .)
    CLASSVAR        reduce using rule 66 (for -> FOR iterador IN array code END .)
    $end            reduce using rule 66 (for -> FOR iterador IN array code END .)
    END             reduce using rule 66 (for -> FOR iterador IN array code END .)
    ELSE            reduce using rule 66 (for -> FOR iterador IN array code END .)
    ELSIF           reduce using rule 66 (for -> FOR iterador IN array code END .)
    NEWLINE         reduce using rule 66 (for -> FOR iterador IN array code END .)


state 160

    (67) for -> FOR iterador IN array DO code . END
    (7) code -> code . code
    (1) code -> . expr
    (2) code -> . if
    (3) code -> . while
    (4) code -> . expresiones
    (5) code -> . for
    (6) code -> . assign
    (7) code -> . code code
    (48) expr -> . math
    (49) expr -> . term
    (50) expr -> . sterm
    (51) expr -> . variable
    (52) expr -> . slice
    (53) expr -> . index
    (69) if -> . IF logical expr END
    (70) if -> . IF logical THEN expr END
    (71) if -> . IF logical
    (72) if -> . IF logical THEN
    (73) if -> . if else
    (74) if -> . if elsif END
    (8) while -> . WHILE logical code END
    (9) while -> . WHILE logical DO salto code salto END
    (10) while -> . WHILE logical DOBLEPOINT salto code salto END
    (11) while -> . BEGIN code END WHILE logical
    (83) expresiones -> . term DOUBLESECUENCEPOINT term
    (64) for -> . FOR iterador IN expresiones code END
    (65) for -> . FOR iterador IN expresiones DO code END
    (66) for -> . FOR iterador IN array code END
    (67) for -> . FOR iterador IN array DO code END
    (30) assign -> . variable ASS expr
    (31) assign -> . variable ASS sexpr
    (32) assign -> . variable ASS array
    (33) math -> . term arith term
    (34) math -> . term arith math
    (35) math -> . variable asig term
    (56) term -> . NUMBER
    (57) sterm -> . STRING
    (36) variable -> . LOCAL
    (37) variable -> . GLOBAL
    (38) variable -> . CONSTANTS
    (39) variable -> . INSTANCEVAR
    (40) variable -> . CLASSVAR
    (96) slice -> . variable LBRACK defslice RBRACK
    (95) index -> . variable LBRACK INT RBRACK

    END             shift and go to state 164
    IF              shift and go to state 14
    WHILE           shift and go to state 15
    BEGIN           shift and go to state 16
    FOR             shift and go to state 17
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    LOCAL           shift and go to state 20
    GLOBAL          shift and go to state 21
    CONSTANTS       shift and go to state 22
    INSTANCEVAR     shift and go to state 23
    CLASSVAR        shift and go to state 24

    code                           shift and go to state 25
    expr                           shift and go to state 2
    if                             shift and go to state 3
    while                          shift and go to state 4
    expresiones                    shift and go to state 5
    for                            shift and go to state 6
    assign                         shift and go to state 7
    math                           shift and go to state 8
    term                           shift and go to state 9
    sterm                          shift and go to state 10
    variable                       shift and go to state 11
    slice                          shift and go to state 12
    index                          shift and go to state 13

state 161

    (9) while -> WHILE logical DO salto code salto END .

    IF              reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    WHILE           reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    BEGIN           reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    FOR             reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    NUMBER          reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    STRING          reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    LOCAL           reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    GLOBAL          reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    CONSTANTS       reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    INSTANCEVAR     reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    CLASSVAR        reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    $end            reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    END             reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    ELSE            reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    ELSIF           reduce using rule 9 (while -> WHILE logical DO salto code salto END .)
    NEWLINE         reduce using rule 9 (while -> WHILE logical DO salto code salto END .)


state 162

    (10) while -> WHILE logical DOBLEPOINT salto code salto END .

    IF              reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    WHILE           reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    BEGIN           reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    FOR             reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    NUMBER          reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    STRING          reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    LOCAL           reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    GLOBAL          reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    CONSTANTS       reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    INSTANCEVAR     reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    CLASSVAR        reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    $end            reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    END             reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    ELSE            reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    ELSIF           reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)
    NEWLINE         reduce using rule 10 (while -> WHILE logical DOBLEPOINT salto code salto END .)


state 163

    (65) for -> FOR iterador IN expresiones DO code END .

    IF              reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    WHILE           reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    BEGIN           reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    FOR             reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    NUMBER          reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    STRING          reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    LOCAL           reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    GLOBAL          reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    CONSTANTS       reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    INSTANCEVAR     reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    CLASSVAR        reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    $end            reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    END             reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    ELSE            reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    ELSIF           reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)
    NEWLINE         reduce using rule 65 (for -> FOR iterador IN expresiones DO code END .)


state 164

    (67) for -> FOR iterador IN array DO code END .

    IF              reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    WHILE           reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    BEGIN           reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    FOR             reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    NUMBER          reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    STRING          reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    LOCAL           reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    GLOBAL          reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    CONSTANTS       reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    INSTANCEVAR     reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    CLASSVAR        reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    $end            reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    END             reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    ELSE            reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    ELSIF           reduce using rule 67 (for -> FOR iterador IN array DO code END .)
    NEWLINE         reduce using rule 67 (for -> FOR iterador IN array DO code END .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 3 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 3 resolved as shift
WARNING: shift/reduce conflict for IF in state 25 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 25 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 25 resolved as shift
WARNING: shift/reduce conflict for FOR in state 25 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 25 resolved as shift
WARNING: shift/reduce conflict for STRING in state 25 resolved as shift
WARNING: shift/reduce conflict for LOCAL in state 25 resolved as shift
WARNING: shift/reduce conflict for GLOBAL in state 25 resolved as shift
WARNING: shift/reduce conflict for CONSTANTS in state 25 resolved as shift
WARNING: shift/reduce conflict for INSTANCEVAR in state 25 resolved as shift
WARNING: shift/reduce conflict for CLASSVAR in state 25 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 38 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 47 resolved as shift
WARNING: shift/reduce conflict for STRING in state 47 resolved as shift
WARNING: shift/reduce conflict for LOCAL in state 47 resolved as shift
WARNING: shift/reduce conflict for GLOBAL in state 47 resolved as shift
WARNING: shift/reduce conflict for CONSTANTS in state 47 resolved as shift
WARNING: shift/reduce conflict for INSTANCEVAR in state 47 resolved as shift
WARNING: shift/reduce conflict for CLASSVAR in state 47 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 74 resolved as shift
WARNING: shift/reduce conflict for STRING in state 74 resolved as shift
WARNING: shift/reduce conflict for LOCAL in state 74 resolved as shift
WARNING: shift/reduce conflict for GLOBAL in state 74 resolved as shift
WARNING: shift/reduce conflict for CONSTANTS in state 74 resolved as shift
WARNING: shift/reduce conflict for INSTANCEVAR in state 74 resolved as shift
WARNING: shift/reduce conflict for CLASSVAR in state 74 resolved as shift
WARNING: shift/reduce conflict for ANDLOG in state 115 resolved as shift
WARNING: shift/reduce conflict for ORLOG in state 115 resolved as shift
WARNING: shift/reduce conflict for NOTLOG in state 115 resolved as shift
WARNING: shift/reduce conflict for AND in state 115 resolved as shift
WARNING: shift/reduce conflict for OR in state 115 resolved as shift
WARNING: shift/reduce conflict for NOT in state 115 resolved as shift
WARNING: shift/reduce conflict for ANDLOG in state 117 resolved as shift
WARNING: shift/reduce conflict for ORLOG in state 117 resolved as shift
WARNING: shift/reduce conflict for NOTLOG in state 117 resolved as shift
WARNING: shift/reduce conflict for AND in state 117 resolved as shift
WARNING: shift/reduce conflict for OR in state 117 resolved as shift
WARNING: shift/reduce conflict for NOT in state 117 resolved as shift
