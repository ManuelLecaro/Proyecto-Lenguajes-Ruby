
# parsetab.py
# This file is automatically generated. Do not edit.
# pylint: disable=W,C,R
_tabversion = '3.10'

_lr_method = 'LALR'

_lr_signature = 'ADD ADDASS ALIAS AND ANDLOG ASS BEGIN BOOLEAN BREAK CASE CLASS CLASSVAR COMA CONSTANTS DEF DEFINED DIV DIVASS DO DOBLEPOINT DOUBLESECUENCEPOINT ELSE ELSIF END ENSURE EQUAL ERROR EXP EXPASS FALSE FILE FLOAT FOR GLOBAL GREATHER GREATHEREQ IF IN INSTANCEVAR INT LBRACK LINE LOCAL LOWER LOWEREQ MOD MODASS MODULE MUL MULASS NEXT NIL NOT NOTEQ NOTLOG NUMBER OR ORLOG PSEUDO RBRACK REDO RESCUE RETRY RETURN SELF STRING SUB SUBASS SUPER THEN TRUE UNDEF UNLESS UNTIL WHEN WHILE YIELDassign : variable ASS expr\n              | variable ASS sexprmath : term arith term\n            | term arith math\n            | variable asig termvariable : LOCAL\n                | GLOBAL \n                | CONSTANTS \n                | INSTANCEVAR \n                | CLASSVARasig : ASS\n            | ADDASS\n            | SUBASS\n            | MULASS\n            | DIVASS\n            | MODASS\n            | EXPASSexpr :  math\n             | term\n             | variable\n             | assignsexpr : sterm MUL term\n             | sterm ADD sexpr\n             | stermterm : NUMBERsterm : STRINGarith : EXP\n             | MUL\n             | DIV\n             | MOD\n             | ADD\n             | SUBlogic : variable comparison variable\n             | variable EQUAL BOOLEAN\n             | variable comparison term\n             | variable comparison sterm\n             | logic logcompare logic\n             | logic logcompare BOOLEAN\n             | BOOLEAN logcompare BOOLEAN\n             | BOOLEAN logcompare logic\n             | term comparison variable\n             | sterm comparison variable\n             comparison : EQUAL\n                  | NOTEQ\n                  | GREATHER\n                  | LOWER\n                  | GREATHEREQ\n                  | LOWEREQlogcompare : ANDLOG\n                  | ORLOG\n                  | NOTLOG\n                  | AND\n                  | OR\n                  | NOTsalto : \n if : IF logic salto expr salto\n          | IF logic THEN salto expr salto\n          | if END\n          | if else END\n          | if elsif ENDelse : ELSE salto expr salto elsif : ELSIF logic salto expr salto\n             | ELSIF logic THEN salto expr salto\n             | elsif elsif\n             | elsif elsecode : expr\n            | ifwhile : WHILE logic salto code salto END\n             | WHILE logic DO salto code END\n             | WHILE  logic DOBLEPOINT code END\n             | BEGIN salto code END WHILE logiciterador : variable\n                | variable "," variableexpresiones : term DOUBLESECUENCEPOINT termfor : FOR iterador IN expresiones salto code salto END\n           | FOR iterador IN expresiones DO salto code salto END\n           | FOR iterador IN array salto code salto END\n           | FOR iterador IN array DO salto code salto ENDarray : LBRACK defarray RBRACKdefarray : NUMBER \n                | NUMBER COMA defarray\n                | STRING\n                | STRING COMA defarray\n                | INT\n                | INT COMA defarray\n                | FLOAT\n                | FLOAT COMA defarray\n                | BOOLEAN\n                | BOOLEAN COMA defarrayassarray : variable ASS array\n                | arrayindex : variable LBRACK INT RBRACKslice : variable LBRACK defslice RBRACKdefslice : INT DOBLEPOINT INT\n                    | INT DOBLEPOINT\n                    | DOBLEPOINT INT'
    
_lr_action_items = {'MULASS':([1,3,4,6,7,15,38,],[-8,-6,-10,-9,-7,20,20,]),'$end':([1,2,3,4,6,7,9,10,11,12,13,14,15,16,17,35,36,37,39,40,],[-8,0,-6,-10,-9,-7,-21,-1,-18,-2,-24,-26,-20,-19,-25,-22,-23,-5,-3,-4,]),'INSTANCEVAR':([0,8,24,28,29,30,31,32,33,34,],[6,6,6,-29,-28,-32,-31,-27,-30,6,]),'SUB':([16,17,39,],[30,-25,30,]),'MUL':([13,14,16,17,39,],[18,-26,29,-25,29,]),'NUMBER':([8,18,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,41,],[17,17,-14,17,-15,-17,17,-12,-16,-13,-29,-28,-32,-31,-27,-30,17,-11,]),'EXP':([16,17,39,],[32,-25,32,]),'STRING':([8,19,24,],[14,14,14,]),'GLOBAL':([0,8,24,28,29,30,31,32,33,34,],[7,7,7,-29,-28,-32,-31,-27,-30,7,]),'DIV':([16,17,39,],[28,-25,28,]),'MODASS':([1,3,4,6,7,15,38,],[-8,-6,-10,-9,-7,26,26,]),'CLASSVAR':([0,8,24,28,29,30,31,32,33,34,],[4,4,4,-29,-28,-32,-31,-27,-30,4,]),'EXPASS':([1,3,4,6,7,15,38,],[-8,-6,-10,-9,-7,23,23,]),'LOCAL':([0,8,24,28,29,30,31,32,33,34,],[3,3,3,-29,-28,-32,-31,-27,-30,3,]),'ASS':([1,3,4,5,6,7,15,38,],[-8,-6,-10,8,-9,-7,24,41,]),'ADDASS':([1,3,4,6,7,15,38,],[-8,-6,-10,-9,-7,25,25,]),'DIVASS':([1,3,4,6,7,15,38,],[-8,-6,-10,-9,-7,22,22,]),'SUBASS':([1,3,4,6,7,15,38,],[-8,-6,-10,-9,-7,27,27,]),'CONSTANTS':([0,8,24,28,29,30,31,32,33,34,],[1,1,1,-29,-28,-32,-31,-27,-30,1,]),'MOD':([16,17,39,],[33,-25,33,]),'ADD':([13,14,16,17,39,],[19,-26,31,-25,31,]),}

_lr_action = {}
for _k, _v in _lr_action_items.items():
   for _x,_y in zip(_v[0],_v[1]):
      if not _x in _lr_action:  _lr_action[_x] = {}
      _lr_action[_x][_k] = _y
del _lr_action_items

_lr_goto_items = {'asig':([15,38,],[21,21,]),'assign':([0,8,24,],[2,9,9,]),'sexpr':([8,19,24,],[12,36,12,]),'sterm':([8,19,24,],[13,13,13,]),'variable':([0,8,24,34,],[5,15,15,38,]),'term':([8,18,21,24,34,],[16,35,37,16,39,]),'expr':([8,24,],[10,10,]),'arith':([16,39,],[34,34,]),'math':([8,24,34,],[11,11,40,]),}

_lr_goto = {}
for _k, _v in _lr_goto_items.items():
   for _x, _y in zip(_v[0], _v[1]):
       if not _x in _lr_goto: _lr_goto[_x] = {}
       _lr_goto[_x][_k] = _y
del _lr_goto_items
_lr_productions = [
  ("S' -> assign","S'",1,None,None,None),
  ('assign -> variable ASS expr','assign',3,'p_assign','gramarRuby.py',10),
  ('assign -> variable ASS sexpr','assign',3,'p_assign','gramarRuby.py',11),
  ('math -> term arith term','math',3,'p_math','gramarRuby.py',15),
  ('math -> term arith math','math',3,'p_math','gramarRuby.py',16),
  ('math -> variable asig term','math',3,'p_math','gramarRuby.py',17),
  ('variable -> LOCAL','variable',1,'p_variable','gramarRuby.py',21),
  ('variable -> GLOBAL','variable',1,'p_variable','gramarRuby.py',22),
  ('variable -> CONSTANTS','variable',1,'p_variable','gramarRuby.py',23),
  ('variable -> INSTANCEVAR','variable',1,'p_variable','gramarRuby.py',24),
  ('variable -> CLASSVAR','variable',1,'p_variable','gramarRuby.py',25),
  ('asig -> ASS','asig',1,'p_asig','gramarRuby.py',29),
  ('asig -> ADDASS','asig',1,'p_asig','gramarRuby.py',30),
  ('asig -> SUBASS','asig',1,'p_asig','gramarRuby.py',31),
  ('asig -> MULASS','asig',1,'p_asig','gramarRuby.py',32),
  ('asig -> DIVASS','asig',1,'p_asig','gramarRuby.py',33),
  ('asig -> MODASS','asig',1,'p_asig','gramarRuby.py',34),
  ('asig -> EXPASS','asig',1,'p_asig','gramarRuby.py',35),
  ('expr -> math','expr',1,'p_expr','gramarRuby.py',39),
  ('expr -> term','expr',1,'p_expr','gramarRuby.py',40),
  ('expr -> variable','expr',1,'p_expr','gramarRuby.py',41),
  ('expr -> assign','expr',1,'p_expr','gramarRuby.py',42),
  ('sexpr -> sterm MUL term','sexpr',3,'p_sexpr','gramarRuby.py',47),
  ('sexpr -> sterm ADD sexpr','sexpr',3,'p_sexpr','gramarRuby.py',48),
  ('sexpr -> sterm','sexpr',1,'p_sexpr','gramarRuby.py',49),
  ('term -> NUMBER','term',1,'p_term','gramarRuby.py',53),
  ('sterm -> STRING','sterm',1,'p_sterm','gramarRuby.py',57),
  ('arith -> EXP','arith',1,'p_arith','gramarRuby.py',61),
  ('arith -> MUL','arith',1,'p_arith','gramarRuby.py',62),
  ('arith -> DIV','arith',1,'p_arith','gramarRuby.py',63),
  ('arith -> MOD','arith',1,'p_arith','gramarRuby.py',64),
  ('arith -> ADD','arith',1,'p_arith','gramarRuby.py',65),
  ('arith -> SUB','arith',1,'p_arith','gramarRuby.py',66),
  ('logic -> variable comparison variable','logic',3,'p_logic','gramarRuby.py',70),
  ('logic -> variable EQUAL BOOLEAN','logic',3,'p_logic','gramarRuby.py',71),
  ('logic -> variable comparison term','logic',3,'p_logic','gramarRuby.py',72),
  ('logic -> variable comparison sterm','logic',3,'p_logic','gramarRuby.py',73),
  ('logic -> logic logcompare logic','logic',3,'p_logic','gramarRuby.py',74),
  ('logic -> logic logcompare BOOLEAN','logic',3,'p_logic','gramarRuby.py',75),
  ('logic -> BOOLEAN logcompare BOOLEAN','logic',3,'p_logic','gramarRuby.py',76),
  ('logic -> BOOLEAN logcompare logic','logic',3,'p_logic','gramarRuby.py',77),
  ('logic -> term comparison variable','logic',3,'p_logic','gramarRuby.py',78),
  ('logic -> sterm comparison variable','logic',3,'p_logic','gramarRuby.py',79),
  ('comparison -> EQUAL','comparison',1,'p_comparison','gramarRuby.py',84),
  ('comparison -> NOTEQ','comparison',1,'p_comparison','gramarRuby.py',85),
  ('comparison -> GREATHER','comparison',1,'p_comparison','gramarRuby.py',86),
  ('comparison -> LOWER','comparison',1,'p_comparison','gramarRuby.py',87),
  ('comparison -> GREATHEREQ','comparison',1,'p_comparison','gramarRuby.py',88),
  ('comparison -> LOWEREQ','comparison',1,'p_comparison','gramarRuby.py',89),
  ('logcompare -> ANDLOG','logcompare',1,'p_logcompare','gramarRuby.py',93),
  ('logcompare -> ORLOG','logcompare',1,'p_logcompare','gramarRuby.py',94),
  ('logcompare -> NOTLOG','logcompare',1,'p_logcompare','gramarRuby.py',95),
  ('logcompare -> AND','logcompare',1,'p_logcompare','gramarRuby.py',96),
  ('logcompare -> OR','logcompare',1,'p_logcompare','gramarRuby.py',97),
  ('logcompare -> NOT','logcompare',1,'p_logcompare','gramarRuby.py',98),
  ('salto -> <empty>','salto',0,'p_salto','gramarRuby.py',107),
  ('if -> IF logic salto expr salto','if',5,'p_if','gramarRuby.py',114),
  ('if -> IF logic THEN salto expr salto','if',6,'p_if','gramarRuby.py',115),
  ('if -> if END','if',2,'p_if','gramarRuby.py',116),
  ('if -> if else END','if',3,'p_if','gramarRuby.py',117),
  ('if -> if elsif END','if',3,'p_if','gramarRuby.py',118),
  ('else -> ELSE salto expr salto','else',4,'p_else','gramarRuby.py',122),
  ('elsif -> ELSIF logic salto expr salto','elsif',5,'p_elsif','gramarRuby.py',126),
  ('elsif -> ELSIF logic THEN salto expr salto','elsif',6,'p_elsif','gramarRuby.py',127),
  ('elsif -> elsif elsif','elsif',2,'p_elsif','gramarRuby.py',128),
  ('elsif -> elsif else','elsif',2,'p_elsif','gramarRuby.py',129),
  ('code -> expr','code',1,'p_code','gramarRuby.py',133),
  ('code -> if','code',1,'p_code','gramarRuby.py',134),
  ('while -> WHILE logic salto code salto END','while',6,'p_while','gramarRuby.py',144),
  ('while -> WHILE logic DO salto code END','while',6,'p_while','gramarRuby.py',145),
  ('while -> WHILE logic DOBLEPOINT code END','while',5,'p_while','gramarRuby.py',146),
  ('while -> BEGIN salto code END WHILE logic','while',6,'p_while','gramarRuby.py',147),
  ('iterador -> variable','iterador',1,'p_iterador','gramarRuby.py',151),
  ('iterador -> variable , variable','iterador',3,'p_iterador','gramarRuby.py',152),
  ('expresiones -> term DOUBLESECUENCEPOINT term','expresiones',3,'p_expresiones','gramarRuby.py',156),
  ('for -> FOR iterador IN expresiones salto code salto END','for',8,'p_for','gramarRuby.py',160),
  ('for -> FOR iterador IN expresiones DO salto code salto END','for',9,'p_for','gramarRuby.py',161),
  ('for -> FOR iterador IN array salto code salto END','for',8,'p_for','gramarRuby.py',162),
  ('for -> FOR iterador IN array DO salto code salto END','for',9,'p_for','gramarRuby.py',163),
  ('array -> LBRACK defarray RBRACK','array',3,'p_array','gramarRuby.py',167),
  ('defarray -> NUMBER','defarray',1,'p_defarray','gramarRuby.py',171),
  ('defarray -> NUMBER COMA defarray','defarray',3,'p_defarray','gramarRuby.py',172),
  ('defarray -> STRING','defarray',1,'p_defarray','gramarRuby.py',173),
  ('defarray -> STRING COMA defarray','defarray',3,'p_defarray','gramarRuby.py',174),
  ('defarray -> INT','defarray',1,'p_defarray','gramarRuby.py',175),
  ('defarray -> INT COMA defarray','defarray',3,'p_defarray','gramarRuby.py',176),
  ('defarray -> FLOAT','defarray',1,'p_defarray','gramarRuby.py',177),
  ('defarray -> FLOAT COMA defarray','defarray',3,'p_defarray','gramarRuby.py',178),
  ('defarray -> BOOLEAN','defarray',1,'p_defarray','gramarRuby.py',179),
  ('defarray -> BOOLEAN COMA defarray','defarray',3,'p_defarray','gramarRuby.py',180),
  ('assarray -> variable ASS array','assarray',3,'p_assarray','gramarRuby.py',186),
  ('assarray -> array','assarray',1,'p_assarray','gramarRuby.py',187),
  ('index -> variable LBRACK INT RBRACK','index',4,'p_index','gramarRuby.py',191),
  ('slice -> variable LBRACK defslice RBRACK','slice',4,'p_slice','gramarRuby.py',195),
  ('defslice -> INT DOBLEPOINT INT','defslice',3,'p_defslice','gramarRuby.py',199),
  ('defslice -> INT DOBLEPOINT','defslice',2,'p_defslice','gramarRuby.py',200),
  ('defslice -> DOBLEPOINT INT','defslice',2,'p_defslice','gramarRuby.py',201),
]
